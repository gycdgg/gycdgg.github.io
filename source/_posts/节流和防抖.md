---
title: 节流和防抖
date: 2018-07-17 17:16:49
tags: 点滴
category: JavaScript
---

最近看公司的代码，很多时候为了减少请求数量，对input的输入响应的事件是onblur。
每次输入数据，需要做一下onblur操作，很吓人有没有。。。
还记得以前做滚动懒加载的时候，直接对scrollbar监听了onchange，并且进行计算，计算之后ajax。毫无疑问页面会很卡。。。。

很多第三方的框架都有实现节流和防抖，自己实现一下吧。

### 频繁触发的事件
```html
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    #container {
      width: 100%;
      height: 200px;
      line-height: 200px;
      text-align: center;
      color: #fff;
      background-color: #444;
      font-size: 30px;
    }
  </style>
</head>
  <body>
    <div id="container"></div>
    <script>
        let count = 0
        let container = document.getElementById('container')
        function fn(e){
          console.log(e)
          container.innerHTML = count++
        }
        container.onmousemove = fn
      </script>
  </body>
</html>
```
当鼠标从左边滑到右边就会触发160多次事件，假想函数内部逻辑复杂或者做一下ajax请求的时候呢，假设1秒触发了60次，每个回调都必须很快（1000/60ms）的完成，不然就会卡顿。

节流和防抖就是为了解决这种问题。
<hr/>
### 函数防抖

当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
```js
function fn(){
  container.innerHTML = count++
}
container.onmousemove = debounce(fn,200)

function debounce(fn, time:200){
  let timeout = null
  return function(){
    if(timeout !== null){
      clearTimeout(timeout)
      }
      timeout = setTimeout(fn,time)
  }
}
```
利用了闭包保存timeout的值，只要在规定的时间内(默认200ms)还在触发事件，timeout就不为null，**setTimeout*返回值为定时器id，可以用于取消定时器**，
在这里定时器设置之后会被一一取消，假设某个时间点没有触发事件，那么最后设置的一个定时器没有被取消，并且在指定的时间会执行。

利用apply改变上下文环境(否则在fn内部拿不到event对象)
```js
        function debounce(fn, time = 300){
          let timeout = null
          return function(){
            let that = this
            if(timeout !== null){
              clearTimeout(timeout)
            }
            timeout = setTimeout(() => {
              fn.apply(that, arguments)
            },time)
          }
        }
```
<hr/>
### 函数节流

固定的时间间隔只做一次，比如滚动事件，鼠标滚动事件一直会触发，但是在1秒内只执行一次事件处理程序，也能起到节省资源的作用。

>节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
      #container {
        width: 100%;
        height: 200px;
        line-height: 200px;
        text-align: center;
        color: #fff;
        background-color: #444;
        font-size: 30px;
      }
    </style>
</head>
<body>
  <h1>鼠标持续滑动，一秒执行一次函数</h1>
  <div id="container"></div>
</body>
<script>
  let container = document.getElementById('container')
  var count = 0
  function fn(e){
    console.log(e)
    container.innerHTML = count++
  }
  container.onmousemove = throttle(fn,1000)
  function throttle(fn, delay = 1000){
    let pre = new Date
    return function(){
      let cur = new Date
      if(cur - pre > delay){
        fn.apply(this,arguments)
        pre = cur
      }
    }
  }
</script>
</html>
```

delay在这里是根据前后事件戳差值来对比的。用定时器也是比较美滋滋的解决方案。
```js
  let container = document.getElementById('container')
  var count = 0
  function fn(e){
    console.log(e)
    container.innerHTML = count++
  }
  container.onmousemove = throttle(fn,3000)
  function throttle(fn, delay = 1000){
    let timer = null
    return function(){
      if(!timer){
        timer = setTimeout(()=>{
          fn.apply(this,arguments)
          timer = null
        },delay)
      }
    }
  }
```
也可以结合事件戳和定时器一起实现
<hr/>

## 总结
* 防抖：捕获持续触发的事件最后的一次触发来调用事件处理函数
* 节流： 隔一段时间调用一次事件处理函数
* 相同点：都是为了解决持续触发事件一直调用事件处理函数的问题
* 不同点：不同的应用场景.例如滚动加载，需要用户滚动的过程计算滚动条到底部的距离，这里就不适合防抖， 因为用户不会刻意的停顿一段时间。
