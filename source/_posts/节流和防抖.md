---
title: 节流和防抖
date: 2018-07-17 17:16:49
tags: 点滴
category: JavaScript
---

最近看公司的代码，很多时候为了减少请求数量，对input的输入响应的事件是onblur。
每次输入数据，需要做一下onblur操作，很吓人有没有。。。
还记得以前做滚动懒加载的时候，直接对scrollbar监听了onchange，并且进行计算，计算之后ajax。毫无疑问页面会很卡。。。。

很多第三方的框架都有实现节流和防抖，自己实现一下吧。

### 频繁触发的事件
```html
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    #container {
      width: 100%;
      height: 200px;
      line-height: 200px;
      text-align: center;
      color: #fff;
      background-color: #444;
      font-size: 30px;
    }
  </style>
</head>
  <body>
    <div id="container"></div>
    <script>
        let count = 0
        let container = document.getElementById('container')
        container.onmousemove = function(e){
          container.innerHTML = count++
        }
      </script>
  </body>
</html>
```
当鼠标从左边滑到右边就会触发160多次事件，假想函数内部逻辑复杂或者做一下ajax请求的时候呢，假设1秒触发了60次，每个回调都必须很快（1000/60ms）的完成，不然就会卡顿。

节流和防抖就是为了解决这种问题。

### 函数防抖

当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
```js
function fn(){
  container.innerHTML = count++
}
container.onmousemove = debounce(fn,200)

function debounce(fn, time:200){
  let timeout = null
  return function(){
    if(timeout !== null){
      clearTimeout(timeout)
      }
      timeout = setTimeout(fn,time)
  }
}
```
利用了闭包保存timeout的值，只要在规定的时间内(默认200ms)还在触发事件，timeout就不为null，**setTimeout*返回值为定时器id，可以用于取消定时器**，
在这里定时器设置之后会被一一取消，假设某个时间点没有触发事件，那么最后设置的一个定时器没有被取消，并且在指定的时间会执行。