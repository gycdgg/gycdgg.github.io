{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/switchTab.js","path":"js/switchTab.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/nest.js","path":"js/nest.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/_config.yml","hash":"5f6b506637680c5bd94025b0e6f6373c7f9ed7e1","modified":1528820047335},{"_id":"themes/BlueLake/README.en.md","hash":"b9f84036214ec79a8c319c5383696e0076305dfe","modified":1528820047334},{"_id":"themes/BlueLake/LICENSE","hash":"3e191ca3f51efc111863c4941051291a696ef43e","modified":1528820047334},{"_id":"themes/BlueLake/package.json","hash":"e06eea20c64b2821631a49e8902e645bad2c5102","modified":1528820047350},{"_id":"themes/BlueLake/README.md","hash":"152969bd5a7e94a595d058f085c517b65d3b61d2","modified":1528820047334},{"_id":"source/_posts/2017年小结.md","hash":"0ae2895f2bc357c1cac99603be2b08198e82f799","modified":1528820047302},{"_id":"source/_posts/Js事件机制（下）.md","hash":"f51ab0840a636337dc85e4482ef2a6cab022bd85","modified":1528820047304},{"_id":"source/_posts/bind实现.md","hash":"34c93651a0ae319674c420f7165abfa576500f0e","modified":1528820047304},{"_id":"source/_posts/Js事件机制（上）.md","hash":"36db56043ac91f884c81731685cc7bf280031439","modified":1529418391239},{"_id":"source/_posts/css中的长度单位与居中.md","hash":"8e9ce25b504017e3ac24931a41dc822f9c275576","modified":1528820047305},{"_id":"source/_posts/es6之let.md","hash":"57afc3670cde212b7107fc971cf9be0e8a070473","modified":1528820047306},{"_id":"source/_posts/css之圣杯布局.md","hash":"d596b6fab95e5a05a2aa7d523f8e2e0e7f545e6c","modified":1528820047305},{"_id":"source/_posts/javascript权威指南-第三章（类型）.md","hash":"4b26e23c900a1267d2b89cda566f274b4bd91430","modified":1529590556917},{"_id":"source/_posts/javascript权威指南-第二十章（客户端存储）.md","hash":"a31babe3be03a4155fbd8dfe63287e869db8c5b2","modified":1528820047308},{"_id":"source/_posts/js继承.md","hash":"b480d72394d8aee118c24199463fd8fdeeaa69d1","modified":1529591748121},{"_id":"source/_posts/你不知道的Javascript上卷——上.md","hash":"9bd646292c9c2869f1df6b56ddf63d7b68049d7b","modified":1529591410127},{"_id":"source/_posts/你不知道的Javascript上卷——下.md","hash":"8e645891f9cd8d3b2b4e24df8f6daf110e6ff2db","modified":1528820047310},{"_id":"source/_posts/你不知道的Javascript上卷——中.md","hash":"332b3c76e1987875984e6cecb816b0ce7d34f7c7","modified":1528820047311},{"_id":"source/_posts/指令集.md","hash":"c7c2d87e34c93b030cfe55f88d9a777997f75c67","modified":1529850656226},{"_id":"source/_posts/字符串加法与全排列问题.md","hash":"27f69a5519d474c46c5678d88843512ac8b25cf2","modified":1528820047311},{"_id":"source/_posts/青蛙跳阶梯和丢色子问题.md","hash":"88d83926120b139c45425245e69a62cabf9a277a","modified":1529330725686},{"_id":"source/about/index.md","hash":"c726a72af2cc2e8bfd3782505684071e7df04f52","modified":1528820047312},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"3e78b20edc66b153cb6b708734ad9aa5381266bc","modified":1528820047335},{"_id":"themes/BlueLake/languages/en.yml","hash":"88f4e4cffce5598f949192d7e76c863a0d409981","modified":1528820047336},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"83ee131065111147d20ec13c4634a27ee4fd541d","modified":1528820047336},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"d9f90ef2c6b4d8c95d142d021a5f47dda8462715","modified":1528820047336},{"_id":"themes/BlueLake/languages/ko.yml","hash":"20c7df4087ee65d75e96f68c71fdb050eb63677f","modified":1528820047336},{"_id":"themes/BlueLake/languages/tr.yml","hash":"abd179304d4e3771efdbfa2c59bfdc121a489d99","modified":1528820047337},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"61f419488d4a8f62c2b90ee766b6e68ba2e88bd7","modified":1528820047337},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"0755af57d92a07ecff0e327f78eb25b0623a5852","modified":1528820047337},{"_id":"themes/BlueLake/layout/archive.jade","hash":"0497469c869f0ac28f150295dbddf6920e6582c1","modified":1528820047347},{"_id":"themes/BlueLake/layout/base.jade","hash":"2e65a06a499fbb67c72f8345d71222e40e9ef523","modified":1528820047347},{"_id":"themes/BlueLake/layout/category.jade","hash":"384e2e2588ecab3f518f03f11f2b052d3827fad8","modified":1528820047348},{"_id":"themes/BlueLake/layout/page.jade","hash":"7d2a48f6a902605fd6cfc237e3c2f9c02d76492e","modified":1528820047348},{"_id":"themes/BlueLake/layout/post.jade","hash":"3025e7e259d69551a35f17db3c3981aaa77fe7bc","modified":1528820047349},{"_id":"themes/BlueLake/layout/index.jade","hash":"ba1ea647af5c134b1a950638ea864663b29d4e22","modified":1528820047348},{"_id":"themes/BlueLake/layout/tag.jade","hash":"835da21846c730f0e3e344dc7e2e59154030b4f7","modified":1528820047349},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1528820047350},{"_id":"themes/BlueLake/source/favicon.ico","hash":"6d352d98ad3f628d333135bafbb41c98e7588172","modified":1528820047351},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"af9a4a65eba65c5140921326f2b5cae9db5d7d28","modified":1528820047339},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"52e4cacd58d5e0061924189ad75e0c3bf622aa7f","modified":1528820047338},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"a1565211d970489a34ab05aaba3fd6cc31af2844","modified":1528820047338},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e5572679df2a469f2e7c634e77c7010691d751d0","modified":1528820047340},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"25e28dc48c392a5d10db1ed0f8a5899598d643d5","modified":1528820047340},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1528820047341},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1528820047341},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1528820047342},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"1c988c7e1f716036e428ee16b8005a7b1bfb33c7","modified":1528820047342},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"28d79fbb9d8ecc5692d3063e439f16224188abac","modified":1528820047342},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1528820047342},{"_id":"themes/BlueLake/layout/_partial/switchTab.jade","hash":"ca4fc865219d3fa255da20d74eceb32b74622630","modified":1528820047343},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1528820047343},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"082ae16dad18ada28913772675861d7230134bea","modified":1528820047344},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"3e4141538285aef2bd019832ba62bafd094c6097","modified":1528820047343},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"ba43bd011d64cd86fa420677c9000d328f4f6114","modified":1528820047344},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"ff46afdedc1ab3c075ffed686b98f23aed066124","modified":1528820047344},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"f8ae55d5514fe493651ec04fbe73cb5fc482f7cd","modified":1528820047345},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"a0309137277323f2fd61a3c6691e1bc51026f711","modified":1528820047345},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"3df9a00a21d3bc151026b2d403a99c28fe1ccd13","modified":1528820047346},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1528820047341},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"53e99461ae7f8efb2a1e78ad3090dd93d18bcd5c","modified":1528820047346},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"be9ad73454b7029311caafd8e1faa469a5d4f58d","modified":1528820047350},{"_id":"themes/BlueLake/source/css/style.styl","hash":"5852cc541b74868e6464c7224b65683ea5aaa8d8","modified":1528820047351},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1528820047352},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"2b6a0b21bf63bdf746130117baf432fcb44ad210","modified":1528820047352},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1528820047353},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1528820047353},{"_id":"themes/BlueLake/source/js/switchTab.js","hash":"aeec80861657c28c7e1b13ee9c20861c6d010276","modified":1528820047356},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1528820047356},{"_id":"themes/BlueLake/source/js/nest.js","hash":"0b98396ed74282c4fd83328afc6170d1f4796cc5","modified":1528820047355},{"_id":"themes/BlueLake/source/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1528820047357},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1528820047356},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1528820047355},{"_id":"public/baidusitemap.xml","hash":"dce0bab3029ba3d4b37df2b8380889bc49f78723","modified":1530357899847},{"_id":"public/atom.xml","hash":"d768fc2c7d6b0a8c6d1439d9625b6d26d1f59c09","modified":1530357899853},{"_id":"public/content.json","hash":"e3a3e02606362c49e7b4a42d0282fcff6f93b8e9","modified":1530357899853},{"_id":"public/sitemap.xml","hash":"84ad5d94bfab79146fbe90fb8a9e8bb678350604","modified":1530357899854},{"_id":"public/about/index.html","hash":"30372cc22ec377695bdc54a548c200dd48bbfd42","modified":1530357899858},{"_id":"public/2018/06/13/bind实现/index.html","hash":"93827875fe7e2517110a2f61c6704a3aba537b99","modified":1530357899858},{"_id":"public/2018/05/17/指令集/index.html","hash":"f956c46f453842d06808e479c2e21c956d8de13a","modified":1530357899859},{"_id":"public/2018/04/20/青蛙跳阶梯和丢色子问题/index.html","hash":"f5e497b22431580600bd6d8f6e1145d279364e36","modified":1530357899859},{"_id":"public/2018/03/26/css中的长度单位与居中/index.html","hash":"1154f74fea5c1e63df8f1f99666a984a79ee59e6","modified":1530357899859},{"_id":"public/2018/03/26/你不知道的Javascript上卷——上/index.html","hash":"d5aae4e28541f74ccce7215e4a11643b0f35d62d","modified":1530357899859},{"_id":"public/2018/03/13/2017年小结/index.html","hash":"f477c3b205cfffb8c37377b8c06940d517db0ade","modified":1530357899859},{"_id":"public/2018/03/13/javascript权威指南-第三章（类型）/index.html","hash":"903ee699f38a0de4e4f9ad4f88682477ecd0c228","modified":1530357899859},{"_id":"public/archives/index.html","hash":"4fc15d8b3b9d839049797812db5a1952f79548cf","modified":1530357899859},{"_id":"public/archives/page/2/index.html","hash":"e10adcbc91f91231dde2e51526fc83a56f07deed","modified":1530357899859},{"_id":"public/archives/2018/index.html","hash":"c6f538e3cbbe9bbfac1bef919550734541141cd2","modified":1530357899859},{"_id":"public/archives/2018/page/2/index.html","hash":"3c2118b8c6f6958f1f5cc9ee7d7c029d922afb70","modified":1530357899860},{"_id":"public/archives/2018/03/index.html","hash":"b82372ecc4028966135c41642e6ff00917a897a7","modified":1530357899860},{"_id":"public/archives/2018/04/index.html","hash":"9e49576a6e4965ce00811494662903e49593a6c4","modified":1530357899860},{"_id":"public/archives/2018/05/index.html","hash":"016f7c0d828732e2cdc59d01386b9c409951f08b","modified":1530357899860},{"_id":"public/archives/2018/06/index.html","hash":"6e670f4628c137047fe5bf2b14adabba5323adb4","modified":1530357899860},{"_id":"public/categories/JavaScript/index.html","hash":"c269598e10d0a998751349cfe7d7cfad8ea524c1","modified":1530357899860},{"_id":"public/categories/Diary/index.html","hash":"969f361c2cc37b122efb2a4279074df1953467f8","modified":1530357899860},{"_id":"public/categories/CSS/index.html","hash":"fabff806e8c2b2a271073bb418b193e18738b8ec","modified":1530357899860},{"_id":"public/categories/读书笔记/index.html","hash":"6852a90d0956e2ac9611511d2ea28d33cb2f7ee1","modified":1530357899860},{"_id":"public/index.html","hash":"34a2430cd8ae45e4137a39973497632a161b9a3c","modified":1530357899860},{"_id":"public/page/2/index.html","hash":"c55c069a5995ede3d49ac1d99897bac632a330e0","modified":1530357899860},{"_id":"public/tags/Javascript事件/index.html","hash":"8a08daf90eff73cea73cc43030bdc0e77b66ae3d","modified":1530357899860},{"_id":"public/tags/随便写写/index.html","hash":"b61b187d723591fb310ce0ff4cc90e308fd12b97","modified":1530357899860},{"_id":"public/tags/点滴/index.html","hash":"1fa8ecf3023b26b748b5210aeb57ea34710ab365","modified":1530357899860},{"_id":"public/tags/小知识/index.html","hash":"4b6842d9f7bee53d3b672d7b4079e2a1e7a244fb","modified":1530357899861},{"_id":"public/tags/es6/index.html","hash":"de81939d60ca1bf9fe3b5dc1a0880c5121cc9ae0","modified":1530357899861},{"_id":"public/tags/页面布局/index.html","hash":"173bb464b49b10da5218e53ffff54d11d32af9fe","modified":1530357899861},{"_id":"public/tags/读书笔记/index.html","hash":"c185f2c6121d796cc31efb835b5e6f4e5c2a73b6","modified":1530357899861},{"_id":"public/tags/算法/index.html","hash":"1c9adb1433426e47f867001966795bb82603f235","modified":1530357899861},{"_id":"public/2018/05/07/js继承/index.html","hash":"708b8813931213748b36cfacf248832b468c9438","modified":1530357899861},{"_id":"public/2018/04/26/你不知道的Javascript上卷——下/index.html","hash":"c2aa056a053625c142cec6a41d8e23fb2a10e2f7","modified":1530357899861},{"_id":"public/2018/04/22/字符串加法与全排列问题/index.html","hash":"1a905f2d11ebd12118e1ae71f8dd47e48c1e4813","modified":1530357899861},{"_id":"public/2018/03/29/你不知道的Javascript上卷——中/index.html","hash":"0b33cac07d0ad36f22f383fad7594ad27c0ec610","modified":1530357899861},{"_id":"public/2018/03/21/css之圣杯布局/index.html","hash":"1510863c1ae2fad5f81878e7c2eda2e57d176388","modified":1530357899861},{"_id":"public/2018/03/14/Js事件机制（下）/index.html","hash":"408fe6a64c15b480c6b3e406734cf07808ea2523","modified":1530357899861},{"_id":"public/2018/03/13/javascript权威指南-第二十章（客户端存储）/index.html","hash":"e584edf42c8664dc3f19bbeb6e2b14d5bea0d456","modified":1530357899861},{"_id":"public/2018/03/13/es6之let/index.html","hash":"86461cf81361e8ecf3b7ecbf6ec5cbaf0560cd54","modified":1530357899861},{"_id":"public/2018/03/13/Js事件机制（上）/index.html","hash":"7b6da68150382faad01d2a0f872e228000cba2a5","modified":1530357899861},{"_id":"public/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1530357899864},{"_id":"public/favicon.ico","hash":"6d352d98ad3f628d333135bafbb41c98e7588172","modified":1530357899864},{"_id":"public/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1530357899864},{"_id":"public/iconfont/iconfont.svg","hash":"2b6a0b21bf63bdf746130117baf432fcb44ad210","modified":1530357899865},{"_id":"public/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1530357899865},{"_id":"public/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1530357899865},{"_id":"public/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1530357900187},{"_id":"public/css/highlight.css","hash":"932879716cbce6f9a1b830070ed514082398f1ca","modified":1530357900191},{"_id":"public/js/switchTab.js","hash":"aeec80861657c28c7e1b13ee9c20861c6d010276","modified":1530357900191},{"_id":"public/js/nest.js","hash":"0b98396ed74282c4fd83328afc6170d1f4796cc5","modified":1530357900191},{"_id":"public/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1530357900191},{"_id":"public/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1530357900191},{"_id":"public/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1530357900191},{"_id":"public/css/style.css","hash":"45a02c24123d7107ed700c695506d5ef7c274fc1","modified":1530357900191}],"Category":[{"name":"JavaScript","_id":"cjj1bkvlz0002msvm14ykrm08"},{"name":"Diary","_id":"cjj1bkvm40007msvmmfawin1q"},{"name":"CSS","_id":"cjj1bkvmb000kmsvm3o8dehsk"},{"name":"读书笔记","_id":"cjj1bkvmf000rmsvmvqqrjqfu"}],"Data":[],"Page":[{"title":"about","date":"2018-03-13T05:16:33.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-03-13 13:16:33\n---\n","updated":"2018-06-12T16:14:07.312Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjj1bkw7i001vmsvmk8e60cxw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Js事件机制（下）","date":"2018-03-14T07:13:12.000Z","_content":"上文介绍了事件流和事件类型，本文介绍事件对象和事件代理\n## 事件对象\n> 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包括所有与事件有关的信息。\n\n#### DOM中的事件对象\n兼容DOM的浏览器将一个event对象传入到事件处理程序中。无论指定的事件使用什么方法，DOM 0 级和 DOM 2级，都会传入event对象\n```html\n<input onclick=\"alert(event.type)\"/>\n<input onclick = \"handleClick(event)\"/>\n<script>\n  //HTML事件，html中参数必须为event\n  function handleClick(e){\n    console.log(e.type)\n  }\n  let btn = document.getElementById(\"myBtn\")\n  // DOM 0 级事件\n  btn.onclick = function(e){\n  console.log(e.type)\n  }\n  btn.addEventListener(\"click\", function(e){\n    console.log(e.type)\n  },false)\n</script>\n```\n\nHTML原生事件，DOM 0 级事件，DOM 2 级事件都可以获取到event对象。\nEvent对象成员\n\n|属性/方法| 类型 | 读/写 | 说明 |\n| :-: | :-: | :-: |  :-: |\n| bubbles | Boolean| 只读 | 表明事件是否冒泡|\n|cancelable| boolean | 只读 |  表明是否可以取消事件的默认行为|\n|currentTarget | Element | 只读 | 表明事件处理程序当前处理的那个程序|\n|defaultPrevented | boolean | 只读 | 为true表示事件已经调用过preventDefault|\n|details | Interger | 只读 | 与事件相关的细节信息|\n|eventPhrase| Interger | 只读 |调用事件处理程序的阶段，1表示捕获，2表示目标阶段，3表示冒泡|\n|preventDefault()| Function | 只读 | 取消事件的默认行为|\n|stopImmediatePropagation() | Function | 只读| 取消事件的进一步冒泡，同时阻止任何事件处理程序被调用|\n|stopPropagation() | Function| 只读 | 取消事件的进一步冒泡|\n|target | Element|  只读 | 事件的目标DOM|\n|trusted | Boolean | 只读| true表示是浏览器生成的|\n|type | String| 只读 | 被触发的事件类型|\n|view | AbstractView | 只读 | 与事件关联的抽象视图|\n\n**只有在事件处理程序执行期间，event对象才会存在， 执行完会销毁**\n\n#### IE中的事件对象\n在使用DOM 0 级方法添加事件处理函数时，event对象作为window对象的一个属性存在。\n```js\n btn.onclick = function(){\n  var event = window.event;\n  console.log(event.type) //\"click\"\n}\n```\n如果用atttchEvent添加的，那么就会有一个event对象作为参数传入事件处理函数中\n```js\n  btn.attachEvent(\"onclick\", function(event){\n    console.log(event.type)\n  })\n```\nIE的event对象同样也包含于创建他的事件相关的属性和方法。\n\n|属性/方法| 类型 | 读/写 | 说明 |\n| :-: | :-: | :-: |  :-: |\n| cancelBubble | Boolean| 读/写 | default value 为 false，当设置为true时等同于DOM中的stopPropagation()|\n|returnValue| boolean | 读/写 | default value 为 true，当设置为false时等同于DOM中的preventDefault|\n|srcElement | Element | 只读 | 与DOM事件中的target相同|\n|type | boolean | 只读 | 被触发的事件类型|\n\n#### 跨浏览器的事件对象\n虽然DOM和IE的event对象不同，但是基于他们之间的相似性依然可以拿出跨浏览器的方案来。\n```js\nlet eventUtil = {\n  addHandler: function(element,type,handler) {\n    if (element.addEventListener) {\n      element.addEventListener(type,handler,false)\n    } else if(event.attachEvent) {\n      element.attachEvent(\"on\" + type, handler)\n    } else {\n      element[\"on\" + type] = handler\n    }\n  },\n  getEvent: function (event) {\n     return event || window.event\n  },\n  getTarget: function (event) {\n    return event.target || event.srcElement\n  },\n  stopProparation: function (event) {\n    if(event.stopPropagation) {\n      event.stopPropagation()\n    } else {\n      event.cancelBubble = true\n    }\n  },\n  preventDefault: function (event) {\n    if (event.preventDefault)\n    {\n      event.preventDefault()\n    } else {\n      event.returnValue = false\n    }\n  },\n  removeHandle: function (event) {\n    if (element.removeEventListener) {\n      element.removeEventListener(type,handler,false)\n    } else if(event.detachEvent) {\n      element.detachEvent(\"on\" + type, handler)\n    } else {\n      element[\"on\" + type] = null\n    }\n  }\n}\n```\n#### 事件代理\n通过之前的学习，我们知道事件处理程序让HTML与JS交互提供了可能。但是每次给DOM元素添加一个事件函数，那么就会在内存中加入一个对象，对象越多，性能也会有很大的影响。其次必须首先指定所有事件处理程序，这个过程需要很多的DOM访问，会影响整个页面的交互就绪时间。\n举个例子。\n```html\n<ul id = \"ul\">\n  <li id = \"li1\">1</li>\n  <li id = \"li2\">2</li>\n  <li id = \"li3\">3</li>\n  .....\n<ul>\n<script>\n  let li1 = document.getElementById('li1')\n  let li2 = document.getElementById('li2')\n  let li3 = document.getElementById('li3')\n  eventUtil.addHandler(li1,\"click\", function(event){\n    console.log(event.target)\n  })\n  eventUtil.addHandler(li2,\"click\", function(event){\n    console.log(event.target.id)\n  })\n  eventUtil.addHandler(li3,\"click\", function(event){\n    console.log(event.target.id)\n  })\n</script>\n```\n这种方式无疑很粗暴的，如果有成百上千个li，必然需要很大的代码量，就算采用的遍历的方式，代码量会少，但是遍历和过多的直接操作DOM也是不可取的。\n这个时候需要引入事件代理。\n\n**事件代理（有些人会叫事件委托）：只需要在DOM树中尽量最高的层次添加一个事件处理程序，利用事件冒泡的原理，子元素的事件也可以捕获到**\n\n还是上面的例子，用事件代理的方式实现\n```js\nlet ul = document.getElementById(\"ul\")\neventUtil.addHandler(ul, \"click\",function(event){\n  event = eventUtil.getEvent(event)\n  let target = eventUtil.getTarget(event)\n  switch (target.id) {\n    case \"li1\":\n      console.log(target.id)\n      break\n    case \"li2\":\n      console.log(target.id)\n      break\n    case \"li3\":\n      console.log(target.id)\n      break \n  }\n})\n```\n最适合采用事件委托的事件包括click,mousedown,mouseup,keydown,keyup和keypress。\n封装一下事件代理 delegate\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <ul id = 'test' style=\"height:200px; background:red\">\n    <li>123</li>\n    <li>456</li>\n    <li>789</li>\n  </ul>\n</body>\n<script>\n  let ul = document.getElementById('test')\n\n  function delegate(parent,type,selector,fn){\n    function handle(e){\n      let _e = window.e || e\n      let target = _e.target || _e.srcElement\n      if(target.id === selector || target.nodeName.toLowerCase() === selector){\n        fn(_e)\n      }\n    }\n    parent[type] = handle\n  }\n  delegate(ul,'onclick','li',function(e){\n    e.target.innerHTML = e.target.innerHTML.split('').reverse().join('')\n  })\n</script>\n</html>\n\n```\n\n**事件代理的本质还是利用了事件冒泡**\n\n\n\n","source":"_posts/Js事件机制（下）.md","raw":"---\ntitle: Js事件机制（下）\ndate: 2018-03-14 15:13:12\ntags: Javascript事件\ncategory: JavaScript\n---\n上文介绍了事件流和事件类型，本文介绍事件对象和事件代理\n## 事件对象\n> 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包括所有与事件有关的信息。\n\n#### DOM中的事件对象\n兼容DOM的浏览器将一个event对象传入到事件处理程序中。无论指定的事件使用什么方法，DOM 0 级和 DOM 2级，都会传入event对象\n```html\n<input onclick=\"alert(event.type)\"/>\n<input onclick = \"handleClick(event)\"/>\n<script>\n  //HTML事件，html中参数必须为event\n  function handleClick(e){\n    console.log(e.type)\n  }\n  let btn = document.getElementById(\"myBtn\")\n  // DOM 0 级事件\n  btn.onclick = function(e){\n  console.log(e.type)\n  }\n  btn.addEventListener(\"click\", function(e){\n    console.log(e.type)\n  },false)\n</script>\n```\n\nHTML原生事件，DOM 0 级事件，DOM 2 级事件都可以获取到event对象。\nEvent对象成员\n\n|属性/方法| 类型 | 读/写 | 说明 |\n| :-: | :-: | :-: |  :-: |\n| bubbles | Boolean| 只读 | 表明事件是否冒泡|\n|cancelable| boolean | 只读 |  表明是否可以取消事件的默认行为|\n|currentTarget | Element | 只读 | 表明事件处理程序当前处理的那个程序|\n|defaultPrevented | boolean | 只读 | 为true表示事件已经调用过preventDefault|\n|details | Interger | 只读 | 与事件相关的细节信息|\n|eventPhrase| Interger | 只读 |调用事件处理程序的阶段，1表示捕获，2表示目标阶段，3表示冒泡|\n|preventDefault()| Function | 只读 | 取消事件的默认行为|\n|stopImmediatePropagation() | Function | 只读| 取消事件的进一步冒泡，同时阻止任何事件处理程序被调用|\n|stopPropagation() | Function| 只读 | 取消事件的进一步冒泡|\n|target | Element|  只读 | 事件的目标DOM|\n|trusted | Boolean | 只读| true表示是浏览器生成的|\n|type | String| 只读 | 被触发的事件类型|\n|view | AbstractView | 只读 | 与事件关联的抽象视图|\n\n**只有在事件处理程序执行期间，event对象才会存在， 执行完会销毁**\n\n#### IE中的事件对象\n在使用DOM 0 级方法添加事件处理函数时，event对象作为window对象的一个属性存在。\n```js\n btn.onclick = function(){\n  var event = window.event;\n  console.log(event.type) //\"click\"\n}\n```\n如果用atttchEvent添加的，那么就会有一个event对象作为参数传入事件处理函数中\n```js\n  btn.attachEvent(\"onclick\", function(event){\n    console.log(event.type)\n  })\n```\nIE的event对象同样也包含于创建他的事件相关的属性和方法。\n\n|属性/方法| 类型 | 读/写 | 说明 |\n| :-: | :-: | :-: |  :-: |\n| cancelBubble | Boolean| 读/写 | default value 为 false，当设置为true时等同于DOM中的stopPropagation()|\n|returnValue| boolean | 读/写 | default value 为 true，当设置为false时等同于DOM中的preventDefault|\n|srcElement | Element | 只读 | 与DOM事件中的target相同|\n|type | boolean | 只读 | 被触发的事件类型|\n\n#### 跨浏览器的事件对象\n虽然DOM和IE的event对象不同，但是基于他们之间的相似性依然可以拿出跨浏览器的方案来。\n```js\nlet eventUtil = {\n  addHandler: function(element,type,handler) {\n    if (element.addEventListener) {\n      element.addEventListener(type,handler,false)\n    } else if(event.attachEvent) {\n      element.attachEvent(\"on\" + type, handler)\n    } else {\n      element[\"on\" + type] = handler\n    }\n  },\n  getEvent: function (event) {\n     return event || window.event\n  },\n  getTarget: function (event) {\n    return event.target || event.srcElement\n  },\n  stopProparation: function (event) {\n    if(event.stopPropagation) {\n      event.stopPropagation()\n    } else {\n      event.cancelBubble = true\n    }\n  },\n  preventDefault: function (event) {\n    if (event.preventDefault)\n    {\n      event.preventDefault()\n    } else {\n      event.returnValue = false\n    }\n  },\n  removeHandle: function (event) {\n    if (element.removeEventListener) {\n      element.removeEventListener(type,handler,false)\n    } else if(event.detachEvent) {\n      element.detachEvent(\"on\" + type, handler)\n    } else {\n      element[\"on\" + type] = null\n    }\n  }\n}\n```\n#### 事件代理\n通过之前的学习，我们知道事件处理程序让HTML与JS交互提供了可能。但是每次给DOM元素添加一个事件函数，那么就会在内存中加入一个对象，对象越多，性能也会有很大的影响。其次必须首先指定所有事件处理程序，这个过程需要很多的DOM访问，会影响整个页面的交互就绪时间。\n举个例子。\n```html\n<ul id = \"ul\">\n  <li id = \"li1\">1</li>\n  <li id = \"li2\">2</li>\n  <li id = \"li3\">3</li>\n  .....\n<ul>\n<script>\n  let li1 = document.getElementById('li1')\n  let li2 = document.getElementById('li2')\n  let li3 = document.getElementById('li3')\n  eventUtil.addHandler(li1,\"click\", function(event){\n    console.log(event.target)\n  })\n  eventUtil.addHandler(li2,\"click\", function(event){\n    console.log(event.target.id)\n  })\n  eventUtil.addHandler(li3,\"click\", function(event){\n    console.log(event.target.id)\n  })\n</script>\n```\n这种方式无疑很粗暴的，如果有成百上千个li，必然需要很大的代码量，就算采用的遍历的方式，代码量会少，但是遍历和过多的直接操作DOM也是不可取的。\n这个时候需要引入事件代理。\n\n**事件代理（有些人会叫事件委托）：只需要在DOM树中尽量最高的层次添加一个事件处理程序，利用事件冒泡的原理，子元素的事件也可以捕获到**\n\n还是上面的例子，用事件代理的方式实现\n```js\nlet ul = document.getElementById(\"ul\")\neventUtil.addHandler(ul, \"click\",function(event){\n  event = eventUtil.getEvent(event)\n  let target = eventUtil.getTarget(event)\n  switch (target.id) {\n    case \"li1\":\n      console.log(target.id)\n      break\n    case \"li2\":\n      console.log(target.id)\n      break\n    case \"li3\":\n      console.log(target.id)\n      break \n  }\n})\n```\n最适合采用事件委托的事件包括click,mousedown,mouseup,keydown,keyup和keypress。\n封装一下事件代理 delegate\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <ul id = 'test' style=\"height:200px; background:red\">\n    <li>123</li>\n    <li>456</li>\n    <li>789</li>\n  </ul>\n</body>\n<script>\n  let ul = document.getElementById('test')\n\n  function delegate(parent,type,selector,fn){\n    function handle(e){\n      let _e = window.e || e\n      let target = _e.target || _e.srcElement\n      if(target.id === selector || target.nodeName.toLowerCase() === selector){\n        fn(_e)\n      }\n    }\n    parent[type] = handle\n  }\n  delegate(ul,'onclick','li',function(e){\n    e.target.innerHTML = e.target.innerHTML.split('').reverse().join('')\n  })\n</script>\n</html>\n\n```\n\n**事件代理的本质还是利用了事件冒泡**\n\n\n\n","slug":"Js事件机制（下）","published":1,"updated":"2018-06-12T16:14:07.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvlq0000msvmj1t2omfg","content":"<p>上文介绍了事件流和事件类型，本文介绍事件对象和事件代理</p>\n<h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><blockquote>\n<p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包括所有与事件有关的信息。</p>\n</blockquote>\n<h4 id=\"DOM中的事件对象\"><a href=\"#DOM中的事件对象\" class=\"headerlink\" title=\"DOM中的事件对象\"></a>DOM中的事件对象</h4><p>兼容DOM的浏览器将一个event对象传入到事件处理程序中。无论指定的事件使用什么方法，DOM 0 级和 DOM 2级，都会传入event对象<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert(event.type)\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">onclick</span> = <span class=\"string\">\"handleClick(event)\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  //HTML事件，html中参数必须为event</span></span><br><span class=\"line\"><span class=\"undefined\">  function handleClick(e)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    console.log(e.type)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  let btn = document.getElementById(\"myBtn\")</span></span><br><span class=\"line\"><span class=\"undefined\">  // DOM 0 级事件</span></span><br><span class=\"line\"><span class=\"undefined\">  btn.onclick = function(e)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  console.log(e.type)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  btn.addEventListener(\"click\", function(e)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    console.log(e.type)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;,false)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>HTML原生事件，DOM 0 级事件，DOM 2 级事件都可以获取到event对象。<br>Event对象成员</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性/方法</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">读/写</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">bubbles</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">表明事件是否冒泡</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cancelable</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">表明是否可以取消事件的默认行为</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">currentTarget</td>\n<td style=\"text-align:center\">Element</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">表明事件处理程序当前处理的那个程序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">defaultPrevented</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">为true表示事件已经调用过preventDefault</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">details</td>\n<td style=\"text-align:center\">Interger</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">与事件相关的细节信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eventPhrase</td>\n<td style=\"text-align:center\">Interger</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">调用事件处理程序的阶段，1表示捕获，2表示目标阶段，3表示冒泡</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">preventDefault()</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">取消事件的默认行为</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">stopImmediatePropagation()</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">取消事件的进一步冒泡，同时阻止任何事件处理程序被调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">stopPropagation()</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">取消事件的进一步冒泡</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">Element</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">事件的目标DOM</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">trusted</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">true表示是浏览器生成的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">type</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">被触发的事件类型</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">view</td>\n<td style=\"text-align:center\">AbstractView</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">与事件关联的抽象视图</td>\n</tr>\n</tbody>\n</table>\n<p><strong>只有在事件处理程序执行期间，event对象才会存在， 执行完会销毁</strong></p>\n<h4 id=\"IE中的事件对象\"><a href=\"#IE中的事件对象\" class=\"headerlink\" title=\"IE中的事件对象\"></a>IE中的事件对象</h4><p>在使用DOM 0 级方法添加事件处理函数时，event对象作为window对象的一个属性存在。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(event.type) <span class=\"comment\">//\"click\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用atttchEvent添加的，那么就会有一个event对象作为参数传入事件处理函数中<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.attachEvent(<span class=\"string\">\"onclick\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(event.type)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>IE的event对象同样也包含于创建他的事件相关的属性和方法。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性/方法</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">读/写</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cancelBubble</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">读/写</td>\n<td style=\"text-align:center\">default value 为 false，当设置为true时等同于DOM中的stopPropagation()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">returnValue</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">读/写</td>\n<td style=\"text-align:center\">default value 为 true，当设置为false时等同于DOM中的preventDefault</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">srcElement</td>\n<td style=\"text-align:center\">Element</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">与DOM事件中的target相同</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">type</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">被触发的事件类型</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"跨浏览器的事件对象\"><a href=\"#跨浏览器的事件对象\" class=\"headerlink\" title=\"跨浏览器的事件对象\"></a>跨浏览器的事件对象</h4><p>虽然DOM和IE的event对象不同，但是基于他们之间的相似性依然可以拿出跨浏览器的方案来。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> eventUtil = &#123;</span><br><span class=\"line\">  addHandler: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element,type,handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element.addEventListener) &#123;</span><br><span class=\"line\">      element.addEventListener(type,handler,<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(event.attachEvent) &#123;</span><br><span class=\"line\">      element.attachEvent(<span class=\"string\">\"on\"</span> + type, handler)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      element[<span class=\"string\">\"on\"</span> + type] = handler</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getEvent: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> event || <span class=\"built_in\">window</span>.event</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getTarget: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> event.target || event.srcElement</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  stopProparation: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(event.stopPropagation) &#123;</span><br><span class=\"line\">      event.stopPropagation()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      event.cancelBubble = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  preventDefault: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.preventDefault)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      event.preventDefault()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      event.returnValue = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  removeHandle: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element.removeEventListener) &#123;</span><br><span class=\"line\">      element.removeEventListener(type,handler,<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(event.detachEvent) &#123;</span><br><span class=\"line\">      element.detachEvent(<span class=\"string\">\"on\"</span> + type, handler)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      element[<span class=\"string\">\"on\"</span> + type] = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h4><p>通过之前的学习，我们知道事件处理程序让HTML与JS交互提供了可能。但是每次给DOM元素添加一个事件函数，那么就会在内存中加入一个对象，对象越多，性能也会有很大的影响。其次必须首先指定所有事件处理程序，这个过程需要很多的DOM访问，会影响整个页面的交互就绪时间。<br>举个例子。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span> = <span class=\"string\">\"ul\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span> = <span class=\"string\">\"li1\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span> = <span class=\"string\">\"li2\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span> = <span class=\"string\">\"li3\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  .....</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> li1 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'li1'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> li2 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'li2'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> li3 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'li3'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  eventUtil.addHandler(li1,<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(event.target)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">  eventUtil.addHandler(li2,<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(event.target.id)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">  eventUtil.addHandler(li3,<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(event.target.id)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这种方式无疑很粗暴的，如果有成百上千个li，必然需要很大的代码量，就算采用的遍历的方式，代码量会少，但是遍历和过多的直接操作DOM也是不可取的。<br>这个时候需要引入事件代理。</p>\n<p><strong>事件代理（有些人会叫事件委托）：只需要在DOM树中尽量最高的层次添加一个事件处理程序，利用事件冒泡的原理，子元素的事件也可以捕获到</strong></p>\n<p>还是上面的例子，用事件代理的方式实现<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"ul\"</span>)</span><br><span class=\"line\">eventUtil.addHandler(ul, <span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = eventUtil.getEvent(event)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> target = eventUtil.getTarget(event)</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (target.id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"li1\"</span>:</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(target.id)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"li2\"</span>:</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(target.id)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"li3\"</span>:</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(target.id)</span><br><span class=\"line\">      <span class=\"keyword\">break</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>最适合采用事件委托的事件包括click,mousedown,mouseup,keydown,keyup和keypress。<br>封装一下事件代理 delegate<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span> = <span class=\"string\">'test'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height:200px; background:red\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>456<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>789<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>)</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegate</span>(<span class=\"params\">parent,type,selector,fn</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">let</span> _e = <span class=\"built_in\">window</span>.e || e</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">let</span> target = _e.target || _e.srcElement</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">if</span>(target.id === selector || target.nodeName.toLowerCase() === selector)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        fn(_e)</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    parent[type] = handle</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">  delegate(ul,<span class=\"string\">'onclick'</span>,<span class=\"string\">'li'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    e.target.innerHTML = e.target.innerHTML.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>事件代理的本质还是利用了事件冒泡</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>上文介绍了事件流和事件类型，本文介绍事件对象和事件代理</p>\n<h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><blockquote>\n<p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包括所有与事件有关的信息。</p>\n</blockquote>\n<h4 id=\"DOM中的事件对象\"><a href=\"#DOM中的事件对象\" class=\"headerlink\" title=\"DOM中的事件对象\"></a>DOM中的事件对象</h4><p>兼容DOM的浏览器将一个event对象传入到事件处理程序中。无论指定的事件使用什么方法，DOM 0 级和 DOM 2级，都会传入event对象<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert(event.type)\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">onclick</span> = <span class=\"string\">\"handleClick(event)\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  //HTML事件，html中参数必须为event</span></span><br><span class=\"line\"><span class=\"undefined\">  function handleClick(e)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    console.log(e.type)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  let btn = document.getElementById(\"myBtn\")</span></span><br><span class=\"line\"><span class=\"undefined\">  // DOM 0 级事件</span></span><br><span class=\"line\"><span class=\"undefined\">  btn.onclick = function(e)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">  console.log(e.type)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  btn.addEventListener(\"click\", function(e)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">    console.log(e.type)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;,false)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>HTML原生事件，DOM 0 级事件，DOM 2 级事件都可以获取到event对象。<br>Event对象成员</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性/方法</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">读/写</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">bubbles</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">表明事件是否冒泡</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cancelable</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">表明是否可以取消事件的默认行为</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">currentTarget</td>\n<td style=\"text-align:center\">Element</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">表明事件处理程序当前处理的那个程序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">defaultPrevented</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">为true表示事件已经调用过preventDefault</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">details</td>\n<td style=\"text-align:center\">Interger</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">与事件相关的细节信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eventPhrase</td>\n<td style=\"text-align:center\">Interger</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">调用事件处理程序的阶段，1表示捕获，2表示目标阶段，3表示冒泡</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">preventDefault()</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">取消事件的默认行为</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">stopImmediatePropagation()</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">取消事件的进一步冒泡，同时阻止任何事件处理程序被调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">stopPropagation()</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">取消事件的进一步冒泡</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">Element</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">事件的目标DOM</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">trusted</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">true表示是浏览器生成的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">type</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">被触发的事件类型</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">view</td>\n<td style=\"text-align:center\">AbstractView</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">与事件关联的抽象视图</td>\n</tr>\n</tbody>\n</table>\n<p><strong>只有在事件处理程序执行期间，event对象才会存在， 执行完会销毁</strong></p>\n<h4 id=\"IE中的事件对象\"><a href=\"#IE中的事件对象\" class=\"headerlink\" title=\"IE中的事件对象\"></a>IE中的事件对象</h4><p>在使用DOM 0 级方法添加事件处理函数时，event对象作为window对象的一个属性存在。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(event.type) <span class=\"comment\">//\"click\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用atttchEvent添加的，那么就会有一个event对象作为参数传入事件处理函数中<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.attachEvent(<span class=\"string\">\"onclick\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(event.type)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>IE的event对象同样也包含于创建他的事件相关的属性和方法。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性/方法</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">读/写</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cancelBubble</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">读/写</td>\n<td style=\"text-align:center\">default value 为 false，当设置为true时等同于DOM中的stopPropagation()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">returnValue</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">读/写</td>\n<td style=\"text-align:center\">default value 为 true，当设置为false时等同于DOM中的preventDefault</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">srcElement</td>\n<td style=\"text-align:center\">Element</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">与DOM事件中的target相同</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">type</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">只读</td>\n<td style=\"text-align:center\">被触发的事件类型</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"跨浏览器的事件对象\"><a href=\"#跨浏览器的事件对象\" class=\"headerlink\" title=\"跨浏览器的事件对象\"></a>跨浏览器的事件对象</h4><p>虽然DOM和IE的event对象不同，但是基于他们之间的相似性依然可以拿出跨浏览器的方案来。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> eventUtil = &#123;</span><br><span class=\"line\">  addHandler: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element,type,handler</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element.addEventListener) &#123;</span><br><span class=\"line\">      element.addEventListener(type,handler,<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(event.attachEvent) &#123;</span><br><span class=\"line\">      element.attachEvent(<span class=\"string\">\"on\"</span> + type, handler)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      element[<span class=\"string\">\"on\"</span> + type] = handler</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getEvent: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> event || <span class=\"built_in\">window</span>.event</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getTarget: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> event.target || event.srcElement</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  stopProparation: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(event.stopPropagation) &#123;</span><br><span class=\"line\">      event.stopPropagation()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      event.cancelBubble = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  preventDefault: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.preventDefault)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      event.preventDefault()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      event.returnValue = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  removeHandle: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element.removeEventListener) &#123;</span><br><span class=\"line\">      element.removeEventListener(type,handler,<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(event.detachEvent) &#123;</span><br><span class=\"line\">      element.detachEvent(<span class=\"string\">\"on\"</span> + type, handler)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      element[<span class=\"string\">\"on\"</span> + type] = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h4><p>通过之前的学习，我们知道事件处理程序让HTML与JS交互提供了可能。但是每次给DOM元素添加一个事件函数，那么就会在内存中加入一个对象，对象越多，性能也会有很大的影响。其次必须首先指定所有事件处理程序，这个过程需要很多的DOM访问，会影响整个页面的交互就绪时间。<br>举个例子。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span> = <span class=\"string\">\"ul\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span> = <span class=\"string\">\"li1\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span> = <span class=\"string\">\"li2\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span> = <span class=\"string\">\"li3\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  .....</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> li1 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'li1'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> li2 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'li2'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> li3 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'li3'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  eventUtil.addHandler(li1,<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(event.target)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">  eventUtil.addHandler(li2,<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(event.target.id)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">  eventUtil.addHandler(li3,<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(event.target.id)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这种方式无疑很粗暴的，如果有成百上千个li，必然需要很大的代码量，就算采用的遍历的方式，代码量会少，但是遍历和过多的直接操作DOM也是不可取的。<br>这个时候需要引入事件代理。</p>\n<p><strong>事件代理（有些人会叫事件委托）：只需要在DOM树中尽量最高的层次添加一个事件处理程序，利用事件冒泡的原理，子元素的事件也可以捕获到</strong></p>\n<p>还是上面的例子，用事件代理的方式实现<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"ul\"</span>)</span><br><span class=\"line\">eventUtil.addHandler(ul, <span class=\"string\">\"click\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = eventUtil.getEvent(event)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> target = eventUtil.getTarget(event)</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (target.id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"li1\"</span>:</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(target.id)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"li2\"</span>:</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(target.id)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"li3\"</span>:</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(target.id)</span><br><span class=\"line\">      <span class=\"keyword\">break</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>最适合采用事件委托的事件包括click,mousedown,mouseup,keydown,keyup和keypress。<br>封装一下事件代理 delegate<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span> = <span class=\"string\">'test'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height:200px; background:red\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>456<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>789<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>)</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegate</span>(<span class=\"params\">parent,type,selector,fn</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">let</span> _e = <span class=\"built_in\">window</span>.e || e</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">let</span> target = _e.target || _e.srcElement</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">if</span>(target.id === selector || target.nodeName.toLowerCase() === selector)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        fn(_e)</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    parent[type] = handle</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">  delegate(ul,<span class=\"string\">'onclick'</span>,<span class=\"string\">'li'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    e.target.innerHTML = e.target.innerHTML.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>事件代理的本质还是利用了事件冒泡</strong></p>\n"},{"title":"2017年小结","date":"2018-03-13T07:34:03.000Z","_content":"\n## 写在毕业一年之际\n2017年，毕业一年了。做前端也满打满算一年了。\n\n### what i have done\n一年待了3家公司，不看理由，就冲这一点，感觉自己这方面做的不够好。跳槽中途的狗血不想吐槽了，跳槽的理由也不说了。这一年从最开始学习React开始，当时还是一个前端小白，本科也是学的自动化，自学了半个月只能写写静态页面，很庆幸遇到了亮哥这样的leader，一个10年工作经验的老程序员，看到了很多这个阶段程序员该有的素养，写东西也好，带的团队也让人很舒服，可以说这辈子不奢求能再遇到像亮哥这样的leader了。亮哥曾说过：**我做了这么久的开发，java转js，不管是java还是js，我只能说会用，或者说熟练使用他们做东西，不敢说精通**。我React，node啥的，算得上会用，不敢说熟练。其实这个年纪了，比较希望一个stable platform to settle down.\n中途去了一家Pre A互联网公司，跟亮哥提离职的时候，想了很久，说很想去互联网公司看一下，看一下他们的运作模式，看了之后也算是见识了很多，但是更多的还是失望。最大的感触，互联网整体环境还是**浮躁**的，尤其是规模和体量没到那一步的时候，天天画大饼，天天要融资， 每天都是鸡血。其实做的产品我自己都不能认可，我都觉得不好用，各种华而不实的需求。不过那段时间代码量上去了，天天写的比较多。我担心的是，一个浮躁的公司，人也会浮躁的吧，所以我走了\n### 前端圈的浮躁\n上面说到了浮躁，整个前端圈子也挺浮躁的，水平参差不齐，新的轮子炒来炒去，培训班每个月一大批出来的人，会用几个api就敢说精通js了。其实也一直害怕自己太浮躁，所以经常会看看书，之前水平不够，看的也很浅，或者说很多看不懂，做了一年了，也需要一个时间沉淀一下了。书读百遍，其义自现。\n最近开发强度很小，有很多自己支配的时间，也给自己定了一些小任务。\n### 最近干点啥呢\n前几天仔细读了犀牛书部分章节，也做了了一点记录。准备花2天时间好好看看underscore源码了，跟着敲敲，下一步就是系统的重新看一下css了，看了几个博客还是不太系统。然后就是之前从0开始写了一个react的前后端项目，之前写了个开头。不管读书还是源码学习，demo等都会同步到github。\n###\n","source":"_posts/2017年小结.md","raw":"---\ntitle: 2017年小结\ndate: 2018-03-13 15:34:03\ntags: 随便写写\ncategory: Diary\n---\n\n## 写在毕业一年之际\n2017年，毕业一年了。做前端也满打满算一年了。\n\n### what i have done\n一年待了3家公司，不看理由，就冲这一点，感觉自己这方面做的不够好。跳槽中途的狗血不想吐槽了，跳槽的理由也不说了。这一年从最开始学习React开始，当时还是一个前端小白，本科也是学的自动化，自学了半个月只能写写静态页面，很庆幸遇到了亮哥这样的leader，一个10年工作经验的老程序员，看到了很多这个阶段程序员该有的素养，写东西也好，带的团队也让人很舒服，可以说这辈子不奢求能再遇到像亮哥这样的leader了。亮哥曾说过：**我做了这么久的开发，java转js，不管是java还是js，我只能说会用，或者说熟练使用他们做东西，不敢说精通**。我React，node啥的，算得上会用，不敢说熟练。其实这个年纪了，比较希望一个stable platform to settle down.\n中途去了一家Pre A互联网公司，跟亮哥提离职的时候，想了很久，说很想去互联网公司看一下，看一下他们的运作模式，看了之后也算是见识了很多，但是更多的还是失望。最大的感触，互联网整体环境还是**浮躁**的，尤其是规模和体量没到那一步的时候，天天画大饼，天天要融资， 每天都是鸡血。其实做的产品我自己都不能认可，我都觉得不好用，各种华而不实的需求。不过那段时间代码量上去了，天天写的比较多。我担心的是，一个浮躁的公司，人也会浮躁的吧，所以我走了\n### 前端圈的浮躁\n上面说到了浮躁，整个前端圈子也挺浮躁的，水平参差不齐，新的轮子炒来炒去，培训班每个月一大批出来的人，会用几个api就敢说精通js了。其实也一直害怕自己太浮躁，所以经常会看看书，之前水平不够，看的也很浅，或者说很多看不懂，做了一年了，也需要一个时间沉淀一下了。书读百遍，其义自现。\n最近开发强度很小，有很多自己支配的时间，也给自己定了一些小任务。\n### 最近干点啥呢\n前几天仔细读了犀牛书部分章节，也做了了一点记录。准备花2天时间好好看看underscore源码了，跟着敲敲，下一步就是系统的重新看一下css了，看了几个博客还是不太系统。然后就是之前从0开始写了一个react的前后端项目，之前写了个开头。不管读书还是源码学习，demo等都会同步到github。\n###\n","slug":"2017年小结","published":1,"updated":"2018-06-12T16:14:07.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvlv0001msvmanbtl8lg","content":"<h2 id=\"写在毕业一年之际\"><a href=\"#写在毕业一年之际\" class=\"headerlink\" title=\"写在毕业一年之际\"></a>写在毕业一年之际</h2><p>2017年，毕业一年了。做前端也满打满算一年了。</p>\n<h3 id=\"what-i-have-done\"><a href=\"#what-i-have-done\" class=\"headerlink\" title=\"what i have done\"></a>what i have done</h3><p>一年待了3家公司，不看理由，就冲这一点，感觉自己这方面做的不够好。跳槽中途的狗血不想吐槽了，跳槽的理由也不说了。这一年从最开始学习React开始，当时还是一个前端小白，本科也是学的自动化，自学了半个月只能写写静态页面，很庆幸遇到了亮哥这样的leader，一个10年工作经验的老程序员，看到了很多这个阶段程序员该有的素养，写东西也好，带的团队也让人很舒服，可以说这辈子不奢求能再遇到像亮哥这样的leader了。亮哥曾说过：<strong>我做了这么久的开发，java转js，不管是java还是js，我只能说会用，或者说熟练使用他们做东西，不敢说精通</strong>。我React，node啥的，算得上会用，不敢说熟练。其实这个年纪了，比较希望一个stable platform to settle down.<br>中途去了一家Pre A互联网公司，跟亮哥提离职的时候，想了很久，说很想去互联网公司看一下，看一下他们的运作模式，看了之后也算是见识了很多，但是更多的还是失望。最大的感触，互联网整体环境还是<strong>浮躁</strong>的，尤其是规模和体量没到那一步的时候，天天画大饼，天天要融资， 每天都是鸡血。其实做的产品我自己都不能认可，我都觉得不好用，各种华而不实的需求。不过那段时间代码量上去了，天天写的比较多。我担心的是，一个浮躁的公司，人也会浮躁的吧，所以我走了</p>\n<h3 id=\"前端圈的浮躁\"><a href=\"#前端圈的浮躁\" class=\"headerlink\" title=\"前端圈的浮躁\"></a>前端圈的浮躁</h3><p>上面说到了浮躁，整个前端圈子也挺浮躁的，水平参差不齐，新的轮子炒来炒去，培训班每个月一大批出来的人，会用几个api就敢说精通js了。其实也一直害怕自己太浮躁，所以经常会看看书，之前水平不够，看的也很浅，或者说很多看不懂，做了一年了，也需要一个时间沉淀一下了。书读百遍，其义自现。<br>最近开发强度很小，有很多自己支配的时间，也给自己定了一些小任务。</p>\n<h3 id=\"最近干点啥呢\"><a href=\"#最近干点啥呢\" class=\"headerlink\" title=\"最近干点啥呢\"></a>最近干点啥呢</h3><p>前几天仔细读了犀牛书部分章节，也做了了一点记录。准备花2天时间好好看看underscore源码了，跟着敲敲，下一步就是系统的重新看一下css了，看了几个博客还是不太系统。然后就是之前从0开始写了一个react的前后端项目，之前写了个开头。不管读书还是源码学习，demo等都会同步到github。</p>\n<p>###</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"写在毕业一年之际\"><a href=\"#写在毕业一年之际\" class=\"headerlink\" title=\"写在毕业一年之际\"></a>写在毕业一年之际</h2><p>2017年，毕业一年了。做前端也满打满算一年了。</p>\n<h3 id=\"what-i-have-done\"><a href=\"#what-i-have-done\" class=\"headerlink\" title=\"what i have done\"></a>what i have done</h3><p>一年待了3家公司，不看理由，就冲这一点，感觉自己这方面做的不够好。跳槽中途的狗血不想吐槽了，跳槽的理由也不说了。这一年从最开始学习React开始，当时还是一个前端小白，本科也是学的自动化，自学了半个月只能写写静态页面，很庆幸遇到了亮哥这样的leader，一个10年工作经验的老程序员，看到了很多这个阶段程序员该有的素养，写东西也好，带的团队也让人很舒服，可以说这辈子不奢求能再遇到像亮哥这样的leader了。亮哥曾说过：<strong>我做了这么久的开发，java转js，不管是java还是js，我只能说会用，或者说熟练使用他们做东西，不敢说精通</strong>。我React，node啥的，算得上会用，不敢说熟练。其实这个年纪了，比较希望一个stable platform to settle down.<br>中途去了一家Pre A互联网公司，跟亮哥提离职的时候，想了很久，说很想去互联网公司看一下，看一下他们的运作模式，看了之后也算是见识了很多，但是更多的还是失望。最大的感触，互联网整体环境还是<strong>浮躁</strong>的，尤其是规模和体量没到那一步的时候，天天画大饼，天天要融资， 每天都是鸡血。其实做的产品我自己都不能认可，我都觉得不好用，各种华而不实的需求。不过那段时间代码量上去了，天天写的比较多。我担心的是，一个浮躁的公司，人也会浮躁的吧，所以我走了</p>\n<h3 id=\"前端圈的浮躁\"><a href=\"#前端圈的浮躁\" class=\"headerlink\" title=\"前端圈的浮躁\"></a>前端圈的浮躁</h3><p>上面说到了浮躁，整个前端圈子也挺浮躁的，水平参差不齐，新的轮子炒来炒去，培训班每个月一大批出来的人，会用几个api就敢说精通js了。其实也一直害怕自己太浮躁，所以经常会看看书，之前水平不够，看的也很浅，或者说很多看不懂，做了一年了，也需要一个时间沉淀一下了。书读百遍，其义自现。<br>最近开发强度很小，有很多自己支配的时间，也给自己定了一些小任务。</p>\n<h3 id=\"最近干点啥呢\"><a href=\"#最近干点啥呢\" class=\"headerlink\" title=\"最近干点啥呢\"></a>最近干点啥呢</h3><p>前几天仔细读了犀牛书部分章节，也做了了一点记录。准备花2天时间好好看看underscore源码了，跟着敲敲，下一步就是系统的重新看一下css了，看了几个博客还是不太系统。然后就是之前从0开始写了一个react的前后端项目，之前写了个开头。不管读书还是源码学习，demo等都会同步到github。</p>\n<p>###</p>\n"},{"title":"bind实现","_content":"\n## 概述\n首先是MDN上的描述啦：bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。\n> fun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n**thisArg**：\n当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。\n\n**arg1, arg2, ...**：\n当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。\n\n我们只要基本实现上面的功能就可以了。\n\n### bind乞丐版\n\n先不考虑多个参数的情况\n```js\nlet obj1 = { a: '11111' }\nfunction test(){\n  return this.a\n}\nFunction.prototype._bind = function(obj){\n\tlet that = this\n\treturn function(){\n\t\treturn that.apply(obj)\n\t}\n}\ntest._bind(obj1)() // 11111\n```\n_bind方法返回一个函数，函数在词法作用域以外的地方被调用，产生了一个闭包。\n这里的let that = this可以不写，而是把下面的函数改成箭头函数。\n\n### 进阶版之es6\n现在需要考虑多个参数的情况\nes6的解构赋值和rest操作简化了一下数组操作\n```js\nlet obj1 = {a: 111}\n\nfunction test(b,c){\n  return [this.a , b , c]\n}\nFunction.prototype._bind = function(obj,...args){\n  return (..._args) => {\n    console.log([...args,..._args])\n    return this.apply(obj,[...args,..._args])\n  }\n}\ntest._bind(obj1,1000,1)(10000) // [111,1000,1]\ntest.bind(obj1,1000,1)(10000) // [111,1000,1]\n```\n\n### 进阶版之es5\nes5不支持rest操作，所以对参数的操作只能改成数组操作。\narguments对象不是数组，只是内置了iterator接口，可以被遍历等。但是没有数组的内置方法。\n```js\nlet obj1 = {a: 111}\n\nfunction test(b,c){\n  return [this.a , b , c]\n}\nFunction.prototype._bind = function(){\n  var slice = Array.prototype.slice\n  var that = this\n  var obj = arguments[0]\n  var arg = slice.call(arguments,1)\n  return function(){\n    return that.apply(obj,arg.concat(slice.call(arguments,0)))\n  }\n}\ntest._bind(obj1,1000,1)(10000) // [111,1000,1]\n```\n## 未完待续\n111111","source":"_posts/bind实现.md","raw":"---\ntitle: bind实现\ntags: 点滴\ncategory: JavaScript\n---\n\n## 概述\n首先是MDN上的描述啦：bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。\n> fun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n**thisArg**：\n当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。\n\n**arg1, arg2, ...**：\n当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。\n\n我们只要基本实现上面的功能就可以了。\n\n### bind乞丐版\n\n先不考虑多个参数的情况\n```js\nlet obj1 = { a: '11111' }\nfunction test(){\n  return this.a\n}\nFunction.prototype._bind = function(obj){\n\tlet that = this\n\treturn function(){\n\t\treturn that.apply(obj)\n\t}\n}\ntest._bind(obj1)() // 11111\n```\n_bind方法返回一个函数，函数在词法作用域以外的地方被调用，产生了一个闭包。\n这里的let that = this可以不写，而是把下面的函数改成箭头函数。\n\n### 进阶版之es6\n现在需要考虑多个参数的情况\nes6的解构赋值和rest操作简化了一下数组操作\n```js\nlet obj1 = {a: 111}\n\nfunction test(b,c){\n  return [this.a , b , c]\n}\nFunction.prototype._bind = function(obj,...args){\n  return (..._args) => {\n    console.log([...args,..._args])\n    return this.apply(obj,[...args,..._args])\n  }\n}\ntest._bind(obj1,1000,1)(10000) // [111,1000,1]\ntest.bind(obj1,1000,1)(10000) // [111,1000,1]\n```\n\n### 进阶版之es5\nes5不支持rest操作，所以对参数的操作只能改成数组操作。\narguments对象不是数组，只是内置了iterator接口，可以被遍历等。但是没有数组的内置方法。\n```js\nlet obj1 = {a: 111}\n\nfunction test(b,c){\n  return [this.a , b , c]\n}\nFunction.prototype._bind = function(){\n  var slice = Array.prototype.slice\n  var that = this\n  var obj = arguments[0]\n  var arg = slice.call(arguments,1)\n  return function(){\n    return that.apply(obj,arg.concat(slice.call(arguments,0)))\n  }\n}\ntest._bind(obj1,1000,1)(10000) // [111,1000,1]\n```\n## 未完待续\n111111","slug":"bind实现","published":1,"date":"2018-06-12T16:14:07.304Z","updated":"2018-06-12T16:14:07.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvm10004msvm0i4brax3","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>首先是MDN上的描述啦：bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p>\n<blockquote>\n<p>fun.bind(thisArg[, arg1[, arg2[, …]]])</p>\n</blockquote>\n<p><strong>thisArg</strong>：<br>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</p>\n<p><strong>arg1, arg2, …</strong>：<br>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</p>\n<p>我们只要基本实现上面的功能就可以了。</p>\n<h3 id=\"bind乞丐版\"><a href=\"#bind乞丐版\" class=\"headerlink\" title=\"bind乞丐版\"></a>bind乞丐版</h3><p>先不考虑多个参数的情况<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123; <span class=\"attr\">a</span>: <span class=\"string\">'11111'</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype._bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> that.apply(obj)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test._bind(obj1)() <span class=\"comment\">// 11111</span></span><br></pre></td></tr></table></figure></p>\n<p>_bind方法返回一个函数，函数在词法作用域以外的地方被调用，产生了一个闭包。<br>这里的let that = this可以不写，而是把下面的函数改成箭头函数。</p>\n<h3 id=\"进阶版之es6\"><a href=\"#进阶版之es6\" class=\"headerlink\" title=\"进阶版之es6\"></a>进阶版之es6</h3><p>现在需要考虑多个参数的情况<br>es6的解构赋值和rest操作简化了一下数组操作<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;<span class=\"attr\">a</span>: <span class=\"number\">111</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">b,c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">this</span>.a , b , c]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype._bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj,...args</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">..._args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log([...args,..._args])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.apply(obj,[...args,..._args])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test._bind(obj1,<span class=\"number\">1000</span>,<span class=\"number\">1</span>)(<span class=\"number\">10000</span>) <span class=\"comment\">// [111,1000,1]</span></span><br><span class=\"line\">test.bind(obj1,<span class=\"number\">1000</span>,<span class=\"number\">1</span>)(<span class=\"number\">10000</span>) <span class=\"comment\">// [111,1000,1]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"进阶版之es5\"><a href=\"#进阶版之es5\" class=\"headerlink\" title=\"进阶版之es5\"></a>进阶版之es5</h3><p>es5不支持rest操作，所以对参数的操作只能改成数组操作。<br>arguments对象不是数组，只是内置了iterator接口，可以被遍历等。但是没有数组的内置方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;<span class=\"attr\">a</span>: <span class=\"number\">111</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">b,c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">this</span>.a , b , c]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype._bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arg = slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(obj,arg.concat(slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">0</span>)))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test._bind(obj1,<span class=\"number\">1000</span>,<span class=\"number\">1</span>)(<span class=\"number\">10000</span>) <span class=\"comment\">// [111,1000,1]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2><p>111111</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>首先是MDN上的描述啦：bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p>\n<blockquote>\n<p>fun.bind(thisArg[, arg1[, arg2[, …]]])</p>\n</blockquote>\n<p><strong>thisArg</strong>：<br>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</p>\n<p><strong>arg1, arg2, …</strong>：<br>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</p>\n<p>我们只要基本实现上面的功能就可以了。</p>\n<h3 id=\"bind乞丐版\"><a href=\"#bind乞丐版\" class=\"headerlink\" title=\"bind乞丐版\"></a>bind乞丐版</h3><p>先不考虑多个参数的情况<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123; <span class=\"attr\">a</span>: <span class=\"string\">'11111'</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype._bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> that.apply(obj)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test._bind(obj1)() <span class=\"comment\">// 11111</span></span><br></pre></td></tr></table></figure></p>\n<p>_bind方法返回一个函数，函数在词法作用域以外的地方被调用，产生了一个闭包。<br>这里的let that = this可以不写，而是把下面的函数改成箭头函数。</p>\n<h3 id=\"进阶版之es6\"><a href=\"#进阶版之es6\" class=\"headerlink\" title=\"进阶版之es6\"></a>进阶版之es6</h3><p>现在需要考虑多个参数的情况<br>es6的解构赋值和rest操作简化了一下数组操作<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;<span class=\"attr\">a</span>: <span class=\"number\">111</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">b,c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">this</span>.a , b , c]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype._bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj,...args</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">..._args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log([...args,..._args])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.apply(obj,[...args,..._args])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test._bind(obj1,<span class=\"number\">1000</span>,<span class=\"number\">1</span>)(<span class=\"number\">10000</span>) <span class=\"comment\">// [111,1000,1]</span></span><br><span class=\"line\">test.bind(obj1,<span class=\"number\">1000</span>,<span class=\"number\">1</span>)(<span class=\"number\">10000</span>) <span class=\"comment\">// [111,1000,1]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"进阶版之es5\"><a href=\"#进阶版之es5\" class=\"headerlink\" title=\"进阶版之es5\"></a>进阶版之es5</h3><p>es5不支持rest操作，所以对参数的操作只能改成数组操作。<br>arguments对象不是数组，只是内置了iterator接口，可以被遍历等。但是没有数组的内置方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;<span class=\"attr\">a</span>: <span class=\"number\">111</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">b,c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">this</span>.a , b , c]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype._bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arg = slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> that.apply(obj,arg.concat(slice.call(<span class=\"built_in\">arguments</span>,<span class=\"number\">0</span>)))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test._bind(obj1,<span class=\"number\">1000</span>,<span class=\"number\">1</span>)(<span class=\"number\">10000</span>) <span class=\"comment\">// [111,1000,1]</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2><p>111111</p>\n"},{"title":"Js事件机制（上）","date":"2018-03-13T07:04:46.000Z","_content":"很早就想好好总结一下事件机制了，终于有动力写了。文章分为上下2部分\nJS和HTML的交互是通过事件来实现的。事件就是文档中发生的一些特定的交互瞬间。\n\n## 事件流\n> 当浏览器发展到第四代时（IE4 和  netscape Communicator 4）,开发团队遇到了一个有意思的问题：页面的哪一部分会拥有某个特定的事件，可以想象在一张纸上画一组同心圆，如果把手指放在圆心上，那么你的手指指向的不是一个圆，而是所有的圆。2家公司看待事件的想法是一致的。当你点击了一个按钮，他们都认为是点击不仅仅发生在按钮上。也就是说 当你点击按钮，你也点击了按钮的容器元素，甚至可以说点击了整个页面。\n**事件流**描述的是，页面接收事件的顺序。IE和Netscape开发团队居然提出了完全相反的事件流的概念。IE的事件流是事件冒泡流，netScape是事件捕获流。\n\n\n![image](http://upload-images.jianshu.io/upload_images/7821791-664099d3b7629a47..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 事件冒泡\nIE的事件流叫事件冒泡（event bubbling）\n所有的现代浏览器都是支持事件冒泡，但是具体实现上有一点区别。\n*IE5.5及其更早的版本会跳过html直接到document*\n\n#### 事件捕获\nnetscape 团队提出的另一种事件流叫事件捕获。事件捕获的思想是不太具体的节点应该更早的接收到事件，具体的节点应该最后接受到事件。它的目的是在事件到达预定目标之前捕获它。\n\n#### DOM事件流\n> IE9、Opera、Firefox、Chrome、Safari都是支持DOM事件流的。**IE8及更早的版本不支持**\n\nDOM2级事件规定事件流包括3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段。\n首先发生的事件捕获，为截取事件提供了机会。然后是实际的目标接受事件，最后一个阶段是冒泡阶段。\n## DOM事件级别\nDom事件主要分为3个级别，DOM 0 级、DOM2级、DOM3级，但是还有一个HTML事件，直接内嵌在HTML里面的。\n\n#### HTML事件\n```html\n<button onclick = \"handleClick()\">click</button>\n<script>\n  function handleClick(){\n    console.log('do something')\n  }\n<script>\n```\n这种强耦合的的事件方法存在2个弊端，首先是时差问题，用户可能在HTML元素一渲染在页面的时候就点击按钮，但是当时的事件处理程序组可能还没有执行条件，比如这个demo中handleClick是在页面的最底部定义的，如果用户在页面解析handleClick函数之前就点击了按钮，会引发错误。\n其次这种强耦合也是不被提倡的。\n\n#### DOM 0 级事件\n```html\n<button id = 'myBtn'>click</button>\n<script>\n  var btn = document.getElementById('myBtn')\n  btn.onclick = function (){\n    console.log('do something', this.id)\n  }\n<script>\n```\nDOM0级事件是将一个函数赋给一个dom对象的处理函数属性。\n可以通过给事件处理属性赋值null来解绑事件。\n这个demo中就是讲函数赋给了btn的onclick属性\n通过以下的demo可以看出来，**DOM 0 级事件的处理程序会在冒泡阶段被处理。**\n```html\n<!DOCTYPE HTML>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <body>\n        <div id=\"box\" style=\"height:100px;width:300px;background-color:pink;\"></div>\n        <button id=\"reset\">还原</button>\n        <script>\n            //IE8-浏览器返回div body html document\n            //其他浏览器返回div body html document window\n            reset.onclick = function () {\n                history.go();\n            }\n            box.onclick = function () {\n                box.innerHTML += 'div\\n';\n            }\n            document.body.onclick = function () {\n                box.innerHTML += 'body\\n';\n            }\n            document.documentElement.onclick = function () {\n                box.innerHTML += 'html\\n';\n            }\n            document.onclick = function () {\n                box.innerHTML += 'document\\n';\n            }\n            window.onclick = function () {\n                box.innerHTML += 'window\\n';\n            }\n        </script\n    </body>\n</html>\n```\n\n#### DOM 2 级事件\n > IE9、Firefix、Safari、Chrome、Opera支持DOM 2 级事件处理程序\n\nDom 2 级事件定义了2个方法，用于指定和删除事件处理程序：addEventListener 和 removeEventListener。\n他们都接受3个参数\n* 需要处理的事件名：click，scroll，focuse // **注意没有 on，不是onclick**\n* 事件的处理函数： 可以是函数名字\n* useCapture： true表示在捕获阶段调用处理程序，false表示冒泡阶段调用。*默认为false*\n\nremoveEventListener的事件处理程序函数必须与addEventListener的相同。匿名函数没办法移除\n```js\nbtn.addEventListener(\"click\", handleClick, true)\nbtn.removeEventListener(\"click\", handleClick, true)\n```\n大多数情况下，都是将是将事件处理程序添加到时间流的冒泡阶段，这样可以最大限度的兼容各种浏览器，但是也不排除有些场合需要在到达目标事件之前捕获它。\n```html\n<!DOCTYPE HTML>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <body>\n        <div id=\"box\" style=\"height:100px;width:300px;background-color:pink;\"></div>\n        <button id=\"reset\">还原</button>\n        <script>\n            //IE8-浏览器不支持\n            //其他浏览器返回window document html body div\n            reset.onclick = function () {\n                history.go();\n            }\n            box.addEventListener('click', function () {\n                box.innerHTML += 'div\\n'\n            }, true)\n            document.body.addEventListener('click', function () {\n                box.innerHTML += 'body\\n';\n            }, true);\n            document.documentElement.addEventListener('click', function () {\n                box.innerHTML += 'html\\n';\n            }, true);\n            document.addEventListener('click', function () {\n                box.innerHTML += 'document\\n';\n            }, true);\n            window.addEventListener('click', function () {\n                box.innerHTML += 'window\\n';\n            }, true);\n        </script>\n    </body>\n</html>\n```\n#### DOM 3 级事件\nDOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：\n* UI事件，当用户与页面上的元素交互时触发，如：load、scroll\n* 焦点事件，当元素获得或失去焦点时触发，如：blur、focus\n* 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup\n* 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel\n* 文本事件，当在文档中输入文本时触发，如：textInput\n* 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress\n* 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart\n* 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified\n同时DOM3级事件也允许使用者自定义一些事件。\n\n### IE事件处理程序\n> 支持IE事件处理程序的浏览器只有IE和Opera\n\n上文说到IE9以后才支持addEventListener和removeEventListener，IE9以前浏览器有类似的方法，attachEvent和detachEvent，但是这2个方法只接受2个参数，事件名称和事件处理程序函数。由于IE8及其之前的版本并不支持DOM事件流，只有事件冒泡，所以没有第三个参数也是意料之中的。\n那这个和DOM 0 级事件有什么区别呢？\nDOM 0 级事件处理函数中的this指代的是当前DOM元素，attachEvent中this指代的是window\n```js\nlet btn = document.getElementById(\"myBtn\")\nbtn.attachEventListener(\"onclick\",function(){\n  console.log(\"clicked\")\n})\nbtn.attachEventListener(\"onclick\",function(){\n  console.log(\"hello world\")\n})\n```\n顺序是先hello world 再clicked，这是和addEventListener不一样的地方。还有就是\"click\"&&\"onclick\"\n\n## 小结\n本文介绍了事件流和几种不同级别的DOM事件，不同浏览器的处理方式需要认真对待。\n\n","source":"_posts/Js事件机制（上）.md","raw":"---\ntitle: Js事件机制（上）\ndate: 2018-03-13 15:04:46\ntags: Javascript事件\ncategory: JavaScript\n---\n很早就想好好总结一下事件机制了，终于有动力写了。文章分为上下2部分\nJS和HTML的交互是通过事件来实现的。事件就是文档中发生的一些特定的交互瞬间。\n\n## 事件流\n> 当浏览器发展到第四代时（IE4 和  netscape Communicator 4）,开发团队遇到了一个有意思的问题：页面的哪一部分会拥有某个特定的事件，可以想象在一张纸上画一组同心圆，如果把手指放在圆心上，那么你的手指指向的不是一个圆，而是所有的圆。2家公司看待事件的想法是一致的。当你点击了一个按钮，他们都认为是点击不仅仅发生在按钮上。也就是说 当你点击按钮，你也点击了按钮的容器元素，甚至可以说点击了整个页面。\n**事件流**描述的是，页面接收事件的顺序。IE和Netscape开发团队居然提出了完全相反的事件流的概念。IE的事件流是事件冒泡流，netScape是事件捕获流。\n\n\n![image](http://upload-images.jianshu.io/upload_images/7821791-664099d3b7629a47..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 事件冒泡\nIE的事件流叫事件冒泡（event bubbling）\n所有的现代浏览器都是支持事件冒泡，但是具体实现上有一点区别。\n*IE5.5及其更早的版本会跳过html直接到document*\n\n#### 事件捕获\nnetscape 团队提出的另一种事件流叫事件捕获。事件捕获的思想是不太具体的节点应该更早的接收到事件，具体的节点应该最后接受到事件。它的目的是在事件到达预定目标之前捕获它。\n\n#### DOM事件流\n> IE9、Opera、Firefox、Chrome、Safari都是支持DOM事件流的。**IE8及更早的版本不支持**\n\nDOM2级事件规定事件流包括3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段。\n首先发生的事件捕获，为截取事件提供了机会。然后是实际的目标接受事件，最后一个阶段是冒泡阶段。\n## DOM事件级别\nDom事件主要分为3个级别，DOM 0 级、DOM2级、DOM3级，但是还有一个HTML事件，直接内嵌在HTML里面的。\n\n#### HTML事件\n```html\n<button onclick = \"handleClick()\">click</button>\n<script>\n  function handleClick(){\n    console.log('do something')\n  }\n<script>\n```\n这种强耦合的的事件方法存在2个弊端，首先是时差问题，用户可能在HTML元素一渲染在页面的时候就点击按钮，但是当时的事件处理程序组可能还没有执行条件，比如这个demo中handleClick是在页面的最底部定义的，如果用户在页面解析handleClick函数之前就点击了按钮，会引发错误。\n其次这种强耦合也是不被提倡的。\n\n#### DOM 0 级事件\n```html\n<button id = 'myBtn'>click</button>\n<script>\n  var btn = document.getElementById('myBtn')\n  btn.onclick = function (){\n    console.log('do something', this.id)\n  }\n<script>\n```\nDOM0级事件是将一个函数赋给一个dom对象的处理函数属性。\n可以通过给事件处理属性赋值null来解绑事件。\n这个demo中就是讲函数赋给了btn的onclick属性\n通过以下的demo可以看出来，**DOM 0 级事件的处理程序会在冒泡阶段被处理。**\n```html\n<!DOCTYPE HTML>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <body>\n        <div id=\"box\" style=\"height:100px;width:300px;background-color:pink;\"></div>\n        <button id=\"reset\">还原</button>\n        <script>\n            //IE8-浏览器返回div body html document\n            //其他浏览器返回div body html document window\n            reset.onclick = function () {\n                history.go();\n            }\n            box.onclick = function () {\n                box.innerHTML += 'div\\n';\n            }\n            document.body.onclick = function () {\n                box.innerHTML += 'body\\n';\n            }\n            document.documentElement.onclick = function () {\n                box.innerHTML += 'html\\n';\n            }\n            document.onclick = function () {\n                box.innerHTML += 'document\\n';\n            }\n            window.onclick = function () {\n                box.innerHTML += 'window\\n';\n            }\n        </script\n    </body>\n</html>\n```\n\n#### DOM 2 级事件\n > IE9、Firefix、Safari、Chrome、Opera支持DOM 2 级事件处理程序\n\nDom 2 级事件定义了2个方法，用于指定和删除事件处理程序：addEventListener 和 removeEventListener。\n他们都接受3个参数\n* 需要处理的事件名：click，scroll，focuse // **注意没有 on，不是onclick**\n* 事件的处理函数： 可以是函数名字\n* useCapture： true表示在捕获阶段调用处理程序，false表示冒泡阶段调用。*默认为false*\n\nremoveEventListener的事件处理程序函数必须与addEventListener的相同。匿名函数没办法移除\n```js\nbtn.addEventListener(\"click\", handleClick, true)\nbtn.removeEventListener(\"click\", handleClick, true)\n```\n大多数情况下，都是将是将事件处理程序添加到时间流的冒泡阶段，这样可以最大限度的兼容各种浏览器，但是也不排除有些场合需要在到达目标事件之前捕获它。\n```html\n<!DOCTYPE HTML>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <body>\n        <div id=\"box\" style=\"height:100px;width:300px;background-color:pink;\"></div>\n        <button id=\"reset\">还原</button>\n        <script>\n            //IE8-浏览器不支持\n            //其他浏览器返回window document html body div\n            reset.onclick = function () {\n                history.go();\n            }\n            box.addEventListener('click', function () {\n                box.innerHTML += 'div\\n'\n            }, true)\n            document.body.addEventListener('click', function () {\n                box.innerHTML += 'body\\n';\n            }, true);\n            document.documentElement.addEventListener('click', function () {\n                box.innerHTML += 'html\\n';\n            }, true);\n            document.addEventListener('click', function () {\n                box.innerHTML += 'document\\n';\n            }, true);\n            window.addEventListener('click', function () {\n                box.innerHTML += 'window\\n';\n            }, true);\n        </script>\n    </body>\n</html>\n```\n#### DOM 3 级事件\nDOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：\n* UI事件，当用户与页面上的元素交互时触发，如：load、scroll\n* 焦点事件，当元素获得或失去焦点时触发，如：blur、focus\n* 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup\n* 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel\n* 文本事件，当在文档中输入文本时触发，如：textInput\n* 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress\n* 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart\n* 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified\n同时DOM3级事件也允许使用者自定义一些事件。\n\n### IE事件处理程序\n> 支持IE事件处理程序的浏览器只有IE和Opera\n\n上文说到IE9以后才支持addEventListener和removeEventListener，IE9以前浏览器有类似的方法，attachEvent和detachEvent，但是这2个方法只接受2个参数，事件名称和事件处理程序函数。由于IE8及其之前的版本并不支持DOM事件流，只有事件冒泡，所以没有第三个参数也是意料之中的。\n那这个和DOM 0 级事件有什么区别呢？\nDOM 0 级事件处理函数中的this指代的是当前DOM元素，attachEvent中this指代的是window\n```js\nlet btn = document.getElementById(\"myBtn\")\nbtn.attachEventListener(\"onclick\",function(){\n  console.log(\"clicked\")\n})\nbtn.attachEventListener(\"onclick\",function(){\n  console.log(\"hello world\")\n})\n```\n顺序是先hello world 再clicked，这是和addEventListener不一样的地方。还有就是\"click\"&&\"onclick\"\n\n## 小结\n本文介绍了事件流和几种不同级别的DOM事件，不同浏览器的处理方式需要认真对待。\n\n","slug":"Js事件机制（上）","published":1,"updated":"2018-06-19T14:26:31.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvm20005msvmg82o1qea","content":"<p>很早就想好好总结一下事件机制了，终于有动力写了。文章分为上下2部分<br>JS和HTML的交互是通过事件来实现的。事件就是文档中发生的一些特定的交互瞬间。</p>\n<h2 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h2><blockquote>\n<p>当浏览器发展到第四代时（IE4 和  netscape Communicator 4）,开发团队遇到了一个有意思的问题：页面的哪一部分会拥有某个特定的事件，可以想象在一张纸上画一组同心圆，如果把手指放在圆心上，那么你的手指指向的不是一个圆，而是所有的圆。2家公司看待事件的想法是一致的。当你点击了一个按钮，他们都认为是点击不仅仅发生在按钮上。也就是说 当你点击按钮，你也点击了按钮的容器元素，甚至可以说点击了整个页面。<br><strong>事件流</strong>描述的是，页面接收事件的顺序。IE和Netscape开发团队居然提出了完全相反的事件流的概念。IE的事件流是事件冒泡流，netScape是事件捕获流。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/7821791-664099d3b7629a47..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h4><p>IE的事件流叫事件冒泡（event bubbling）<br>所有的现代浏览器都是支持事件冒泡，但是具体实现上有一点区别。<br><em>IE5.5及其更早的版本会跳过html直接到document</em></p>\n<h4 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h4><p>netscape 团队提出的另一种事件流叫事件捕获。事件捕获的思想是不太具体的节点应该更早的接收到事件，具体的节点应该最后接受到事件。它的目的是在事件到达预定目标之前捕获它。</p>\n<h4 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h4><blockquote>\n<p>IE9、Opera、Firefox、Chrome、Safari都是支持DOM事件流的。<strong>IE8及更早的版本不支持</strong></p>\n</blockquote>\n<p>DOM2级事件规定事件流包括3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段。<br>首先发生的事件捕获，为截取事件提供了机会。然后是实际的目标接受事件，最后一个阶段是冒泡阶段。</p>\n<h2 id=\"DOM事件级别\"><a href=\"#DOM事件级别\" class=\"headerlink\" title=\"DOM事件级别\"></a>DOM事件级别</h2><p>Dom事件主要分为3个级别，DOM 0 级、DOM2级、DOM3级，但是还有一个HTML事件，直接内嵌在HTML里面的。</p>\n<h4 id=\"HTML事件\"><a href=\"#HTML事件\" class=\"headerlink\" title=\"HTML事件\"></a>HTML事件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span> = <span class=\"string\">\"handleClick()\"</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'do something'</span>)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br></pre></td></tr></table></figure>\n<p>这种强耦合的的事件方法存在2个弊端，首先是时差问题，用户可能在HTML元素一渲染在页面的时候就点击按钮，但是当时的事件处理程序组可能还没有执行条件，比如这个demo中handleClick是在页面的最底部定义的，如果用户在页面解析handleClick函数之前就点击了按钮，会引发错误。<br>其次这种强耦合也是不被提倡的。</p>\n<h4 id=\"DOM-0-级事件\"><a href=\"#DOM-0-级事件\" class=\"headerlink\" title=\"DOM 0 级事件\"></a>DOM 0 级事件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span> = <span class=\"string\">'myBtn'</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myBtn'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'do something'</span>, <span class=\"keyword\">this</span>.id)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br></pre></td></tr></table></figure>\n<p>DOM0级事件是将一个函数赋给一个dom对象的处理函数属性。<br>可以通过给事件处理属性赋值null来解绑事件。<br>这个demo中就是讲函数赋给了btn的onclick属性<br>通过以下的demo可以看出来，<strong>DOM 0 级事件的处理程序会在冒泡阶段被处理。</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"box\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height:100px;width:300px;background-color:pink;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"reset\"</span>&gt;</span>还原<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//IE8-浏览器返回div body html document</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//其他浏览器返回div body html document window</span></span></span><br><span class=\"line\"><span class=\"javascript\">            reset.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                history.go();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            box.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'div\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'body\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.documentElement.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'html\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'document\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">window</span>.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'window\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &lt;/script</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"DOM-2-级事件\"><a href=\"#DOM-2-级事件\" class=\"headerlink\" title=\"DOM 2 级事件\"></a>DOM 2 级事件</h4><blockquote>\n<p>IE9、Firefix、Safari、Chrome、Opera支持DOM 2 级事件处理程序</p>\n</blockquote>\n<p>Dom 2 级事件定义了2个方法，用于指定和删除事件处理程序：addEventListener 和 removeEventListener。<br>他们都接受3个参数</p>\n<ul>\n<li>需要处理的事件名：click，scroll，focuse // <strong>注意没有 on，不是onclick</strong></li>\n<li>事件的处理函数： 可以是函数名字</li>\n<li>useCapture： true表示在捕获阶段调用处理程序，false表示冒泡阶段调用。<em>默认为false</em></li>\n</ul>\n<p>removeEventListener的事件处理程序函数必须与addEventListener的相同。匿名函数没办法移除<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, handleClick, <span class=\"literal\">true</span>)</span><br><span class=\"line\">btn.removeEventListener(<span class=\"string\">\"click\"</span>, handleClick, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p>大多数情况下，都是将是将事件处理程序添加到时间流的冒泡阶段，这样可以最大限度的兼容各种浏览器，但是也不排除有些场合需要在到达目标事件之前捕获它。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"box\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height:100px;width:300px;background-color:pink;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"reset\"</span>&gt;</span>还原<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//IE8-浏览器不支持</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//其他浏览器返回window document html body div</span></span></span><br><span class=\"line\"><span class=\"javascript\">            reset.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                history.go();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            box.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'div\\n'</span></span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.body.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'body\\n'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.documentElement.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'html\\n'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'document\\n'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'window\\n'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"DOM-3-级事件\"><a href=\"#DOM-3-级事件\" class=\"headerlink\" title=\"DOM 3 级事件\"></a>DOM 3 级事件</h4><p>DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：</p>\n<ul>\n<li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li>\n<li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li>\n<li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li>\n<li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li>\n<li>文本事件，当在文档中输入文本时触发，如：textInput</li>\n<li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li>\n<li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li>\n<li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified<br>同时DOM3级事件也允许使用者自定义一些事件。</li>\n</ul>\n<h3 id=\"IE事件处理程序\"><a href=\"#IE事件处理程序\" class=\"headerlink\" title=\"IE事件处理程序\"></a>IE事件处理程序</h3><blockquote>\n<p>支持IE事件处理程序的浏览器只有IE和Opera</p>\n</blockquote>\n<p>上文说到IE9以后才支持addEventListener和removeEventListener，IE9以前浏览器有类似的方法，attachEvent和detachEvent，但是这2个方法只接受2个参数，事件名称和事件处理程序函数。由于IE8及其之前的版本并不支持DOM事件流，只有事件冒泡，所以没有第三个参数也是意料之中的。<br>那这个和DOM 0 级事件有什么区别呢？<br>DOM 0 级事件处理函数中的this指代的是当前DOM元素，attachEvent中this指代的是window<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>)</span><br><span class=\"line\">btn.attachEventListener(<span class=\"string\">\"onclick\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"clicked\"</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">btn.attachEventListener(<span class=\"string\">\"onclick\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello world\"</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>顺序是先hello world 再clicked，这是和addEventListener不一样的地方。还有就是”click”&amp;&amp;”onclick”</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文介绍了事件流和几种不同级别的DOM事件，不同浏览器的处理方式需要认真对待。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很早就想好好总结一下事件机制了，终于有动力写了。文章分为上下2部分<br>JS和HTML的交互是通过事件来实现的。事件就是文档中发生的一些特定的交互瞬间。</p>\n<h2 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h2><blockquote>\n<p>当浏览器发展到第四代时（IE4 和  netscape Communicator 4）,开发团队遇到了一个有意思的问题：页面的哪一部分会拥有某个特定的事件，可以想象在一张纸上画一组同心圆，如果把手指放在圆心上，那么你的手指指向的不是一个圆，而是所有的圆。2家公司看待事件的想法是一致的。当你点击了一个按钮，他们都认为是点击不仅仅发生在按钮上。也就是说 当你点击按钮，你也点击了按钮的容器元素，甚至可以说点击了整个页面。<br><strong>事件流</strong>描述的是，页面接收事件的顺序。IE和Netscape开发团队居然提出了完全相反的事件流的概念。IE的事件流是事件冒泡流，netScape是事件捕获流。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/7821791-664099d3b7629a47..jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h4><p>IE的事件流叫事件冒泡（event bubbling）<br>所有的现代浏览器都是支持事件冒泡，但是具体实现上有一点区别。<br><em>IE5.5及其更早的版本会跳过html直接到document</em></p>\n<h4 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h4><p>netscape 团队提出的另一种事件流叫事件捕获。事件捕获的思想是不太具体的节点应该更早的接收到事件，具体的节点应该最后接受到事件。它的目的是在事件到达预定目标之前捕获它。</p>\n<h4 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h4><blockquote>\n<p>IE9、Opera、Firefox、Chrome、Safari都是支持DOM事件流的。<strong>IE8及更早的版本不支持</strong></p>\n</blockquote>\n<p>DOM2级事件规定事件流包括3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段。<br>首先发生的事件捕获，为截取事件提供了机会。然后是实际的目标接受事件，最后一个阶段是冒泡阶段。</p>\n<h2 id=\"DOM事件级别\"><a href=\"#DOM事件级别\" class=\"headerlink\" title=\"DOM事件级别\"></a>DOM事件级别</h2><p>Dom事件主要分为3个级别，DOM 0 级、DOM2级、DOM3级，但是还有一个HTML事件，直接内嵌在HTML里面的。</p>\n<h4 id=\"HTML事件\"><a href=\"#HTML事件\" class=\"headerlink\" title=\"HTML事件\"></a>HTML事件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span> = <span class=\"string\">\"handleClick()\"</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'do something'</span>)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br></pre></td></tr></table></figure>\n<p>这种强耦合的的事件方法存在2个弊端，首先是时差问题，用户可能在HTML元素一渲染在页面的时候就点击按钮，但是当时的事件处理程序组可能还没有执行条件，比如这个demo中handleClick是在页面的最底部定义的，如果用户在页面解析handleClick函数之前就点击了按钮，会引发错误。<br>其次这种强耦合也是不被提倡的。</p>\n<h4 id=\"DOM-0-级事件\"><a href=\"#DOM-0-级事件\" class=\"headerlink\" title=\"DOM 0 级事件\"></a>DOM 0 级事件</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span> = <span class=\"string\">'myBtn'</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myBtn'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'do something'</span>, <span class=\"keyword\">this</span>.id)</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br></pre></td></tr></table></figure>\n<p>DOM0级事件是将一个函数赋给一个dom对象的处理函数属性。<br>可以通过给事件处理属性赋值null来解绑事件。<br>这个demo中就是讲函数赋给了btn的onclick属性<br>通过以下的demo可以看出来，<strong>DOM 0 级事件的处理程序会在冒泡阶段被处理。</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"box\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height:100px;width:300px;background-color:pink;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"reset\"</span>&gt;</span>还原<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//IE8-浏览器返回div body html document</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//其他浏览器返回div body html document window</span></span></span><br><span class=\"line\"><span class=\"javascript\">            reset.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                history.go();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            box.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'div\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'body\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.documentElement.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'html\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'document\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">window</span>.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'window\\n'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &lt;/script</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"DOM-2-级事件\"><a href=\"#DOM-2-级事件\" class=\"headerlink\" title=\"DOM 2 级事件\"></a>DOM 2 级事件</h4><blockquote>\n<p>IE9、Firefix、Safari、Chrome、Opera支持DOM 2 级事件处理程序</p>\n</blockquote>\n<p>Dom 2 级事件定义了2个方法，用于指定和删除事件处理程序：addEventListener 和 removeEventListener。<br>他们都接受3个参数</p>\n<ul>\n<li>需要处理的事件名：click，scroll，focuse // <strong>注意没有 on，不是onclick</strong></li>\n<li>事件的处理函数： 可以是函数名字</li>\n<li>useCapture： true表示在捕获阶段调用处理程序，false表示冒泡阶段调用。<em>默认为false</em></li>\n</ul>\n<p>removeEventListener的事件处理程序函数必须与addEventListener的相同。匿名函数没办法移除<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, handleClick, <span class=\"literal\">true</span>)</span><br><span class=\"line\">btn.removeEventListener(<span class=\"string\">\"click\"</span>, handleClick, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p>大多数情况下，都是将是将事件处理程序添加到时间流的冒泡阶段，这样可以最大限度的兼容各种浏览器，但是也不排除有些场合需要在到达目标事件之前捕获它。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"box\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height:100px;width:300px;background-color:pink;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"reset\"</span>&gt;</span>还原<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//IE8-浏览器不支持</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//其他浏览器返回window document html body div</span></span></span><br><span class=\"line\"><span class=\"javascript\">            reset.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                history.go();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            box.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'div\\n'</span></span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.body.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'body\\n'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.documentElement.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'html\\n'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'document\\n'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                box.innerHTML += <span class=\"string\">'window\\n'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"DOM-3-级事件\"><a href=\"#DOM-3-级事件\" class=\"headerlink\" title=\"DOM 3 级事件\"></a>DOM 3 级事件</h4><p>DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：</p>\n<ul>\n<li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li>\n<li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li>\n<li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li>\n<li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li>\n<li>文本事件，当在文档中输入文本时触发，如：textInput</li>\n<li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li>\n<li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li>\n<li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified<br>同时DOM3级事件也允许使用者自定义一些事件。</li>\n</ul>\n<h3 id=\"IE事件处理程序\"><a href=\"#IE事件处理程序\" class=\"headerlink\" title=\"IE事件处理程序\"></a>IE事件处理程序</h3><blockquote>\n<p>支持IE事件处理程序的浏览器只有IE和Opera</p>\n</blockquote>\n<p>上文说到IE9以后才支持addEventListener和removeEventListener，IE9以前浏览器有类似的方法，attachEvent和detachEvent，但是这2个方法只接受2个参数，事件名称和事件处理程序函数。由于IE8及其之前的版本并不支持DOM事件流，只有事件冒泡，所以没有第三个参数也是意料之中的。<br>那这个和DOM 0 级事件有什么区别呢？<br>DOM 0 级事件处理函数中的this指代的是当前DOM元素，attachEvent中this指代的是window<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>)</span><br><span class=\"line\">btn.attachEventListener(<span class=\"string\">\"onclick\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"clicked\"</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">btn.attachEventListener(<span class=\"string\">\"onclick\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello world\"</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>顺序是先hello world 再clicked，这是和addEventListener不一样的地方。还有就是”click”&amp;&amp;”onclick”</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文介绍了事件流和几种不同级别的DOM事件，不同浏览器的处理方式需要认真对待。</p>\n"},{"title":"css中的长度单位与居中","date":"2018-03-26T07:45:39.000Z","_content":"\ncss居中问题一只是经典问题啦，实现的方式有很多，但是还是需要记录一下。\n\n## 长度单位\n1. px：(pixel)像素，像素px是相对于显示器屏幕分辨率而言的(引自CSS2.0手册)。电子屏幕上组成一幅图画或照片的最基本单元；\n2. pt: (point)点，印刷行业常用单位，等于1/72英寸，就是我们在Word或者WPS等办公软件中使用的字体大小单位；\n3. ppi: (pixel per inch)每英寸像素数，该值越高，则屏幕越细腻，用于计算机和电视屏幕上每英寸显示的像素点的数量；\n4. dpi: (dot per inch)每英寸多少点，该值越高，则图片越细腻，用于打印；\n5. dp: (dip，Density-independent pixel) 是安卓开发用的长度单位，1dp表示在屏幕像素点密度为160ppi时1px长度；\n6. sp: (scale-independent pixel)安卓开发用的字体大小单位；\n7. em:(emphasize) 是相对长度单位，相对于当前对象内文本的字体尺寸，即em的计算是基于父级元素font-size的；\n8. rem: （root em，根em）是css3新增的一个相对单位，与em的区别在于，它是相对于html根元素的(在body标签里面设置字体大小不起作用)；\n9. vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。\n10. vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。\n11. vmin：vw和vh中较小的那个。\n12. vmax：vw和vh中较大的那个。\n\nvw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Android browser4.4+支持，chrome for android39支持\n\n## 居中\n\n### 水平居中\n\n","source":"_posts/css中的长度单位与居中.md","raw":"---\ntitle: css中的长度单位与居中\ndate: 2018-03-26 15:45:39\ntags: 小知识\ncategory: CSS\n---\n\ncss居中问题一只是经典问题啦，实现的方式有很多，但是还是需要记录一下。\n\n## 长度单位\n1. px：(pixel)像素，像素px是相对于显示器屏幕分辨率而言的(引自CSS2.0手册)。电子屏幕上组成一幅图画或照片的最基本单元；\n2. pt: (point)点，印刷行业常用单位，等于1/72英寸，就是我们在Word或者WPS等办公软件中使用的字体大小单位；\n3. ppi: (pixel per inch)每英寸像素数，该值越高，则屏幕越细腻，用于计算机和电视屏幕上每英寸显示的像素点的数量；\n4. dpi: (dot per inch)每英寸多少点，该值越高，则图片越细腻，用于打印；\n5. dp: (dip，Density-independent pixel) 是安卓开发用的长度单位，1dp表示在屏幕像素点密度为160ppi时1px长度；\n6. sp: (scale-independent pixel)安卓开发用的字体大小单位；\n7. em:(emphasize) 是相对长度单位，相对于当前对象内文本的字体尺寸，即em的计算是基于父级元素font-size的；\n8. rem: （root em，根em）是css3新增的一个相对单位，与em的区别在于，它是相对于html根元素的(在body标签里面设置字体大小不起作用)；\n9. vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。\n10. vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。\n11. vmin：vw和vh中较小的那个。\n12. vmax：vw和vh中较大的那个。\n\nvw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Android browser4.4+支持，chrome for android39支持\n\n## 居中\n\n### 水平居中\n\n","slug":"css中的长度单位与居中","published":1,"updated":"2018-06-12T16:14:07.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvm30006msvmclrtit7y","content":"<p>css居中问题一只是经典问题啦，实现的方式有很多，但是还是需要记录一下。</p>\n<h2 id=\"长度单位\"><a href=\"#长度单位\" class=\"headerlink\" title=\"长度单位\"></a>长度单位</h2><ol>\n<li>px：(pixel)像素，像素px是相对于显示器屏幕分辨率而言的(引自CSS2.0手册)。电子屏幕上组成一幅图画或照片的最基本单元；</li>\n<li>pt: (point)点，印刷行业常用单位，等于1/72英寸，就是我们在Word或者WPS等办公软件中使用的字体大小单位；</li>\n<li>ppi: (pixel per inch)每英寸像素数，该值越高，则屏幕越细腻，用于计算机和电视屏幕上每英寸显示的像素点的数量；</li>\n<li>dpi: (dot per inch)每英寸多少点，该值越高，则图片越细腻，用于打印；</li>\n<li>dp: (dip，Density-independent pixel) 是安卓开发用的长度单位，1dp表示在屏幕像素点密度为160ppi时1px长度；</li>\n<li>sp: (scale-independent pixel)安卓开发用的字体大小单位；</li>\n<li>em:(emphasize) 是相对长度单位，相对于当前对象内文本的字体尺寸，即em的计算是基于父级元素font-size的；</li>\n<li>rem: （root em，根em）是css3新增的一个相对单位，与em的区别在于，它是相对于html根元素的(在body标签里面设置字体大小不起作用)；</li>\n<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</li>\n<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</li>\n<li>vmin：vw和vh中较小的那个。</li>\n<li>vmax：vw和vh中较大的那个。</li>\n</ol>\n<p>vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Android browser4.4+支持，chrome for android39支持</p>\n<h2 id=\"居中\"><a href=\"#居中\" class=\"headerlink\" title=\"居中\"></a>居中</h2><h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3>","site":{"data":{}},"excerpt":"","more":"<p>css居中问题一只是经典问题啦，实现的方式有很多，但是还是需要记录一下。</p>\n<h2 id=\"长度单位\"><a href=\"#长度单位\" class=\"headerlink\" title=\"长度单位\"></a>长度单位</h2><ol>\n<li>px：(pixel)像素，像素px是相对于显示器屏幕分辨率而言的(引自CSS2.0手册)。电子屏幕上组成一幅图画或照片的最基本单元；</li>\n<li>pt: (point)点，印刷行业常用单位，等于1/72英寸，就是我们在Word或者WPS等办公软件中使用的字体大小单位；</li>\n<li>ppi: (pixel per inch)每英寸像素数，该值越高，则屏幕越细腻，用于计算机和电视屏幕上每英寸显示的像素点的数量；</li>\n<li>dpi: (dot per inch)每英寸多少点，该值越高，则图片越细腻，用于打印；</li>\n<li>dp: (dip，Density-independent pixel) 是安卓开发用的长度单位，1dp表示在屏幕像素点密度为160ppi时1px长度；</li>\n<li>sp: (scale-independent pixel)安卓开发用的字体大小单位；</li>\n<li>em:(emphasize) 是相对长度单位，相对于当前对象内文本的字体尺寸，即em的计算是基于父级元素font-size的；</li>\n<li>rem: （root em，根em）是css3新增的一个相对单位，与em的区别在于，它是相对于html根元素的(在body标签里面设置字体大小不起作用)；</li>\n<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</li>\n<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</li>\n<li>vmin：vw和vh中较小的那个。</li>\n<li>vmax：vw和vh中较大的那个。</li>\n</ol>\n<p>vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Android browser4.4+支持，chrome for android39支持</p>\n<h2 id=\"居中\"><a href=\"#居中\" class=\"headerlink\" title=\"居中\"></a>居中</h2><h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3>"},{"title":"es6之let","date":"2018-03-13T07:26:31.000Z","_content":"## 概述\n在写上一篇文章，关于cookie的操作时有一个demo，涉及到一个作用域的问题，实验了一下，然后又归纳小结了一波，主要还是参考[阮大的es6入门](http://es6.ruanyifeng.com/#docs/let)，也算是面试经常问的问题，let和var的区别，之前都会回答块级作用域，具体一点的，申明提前，暂时性死区的都会大概提一提。想想还是好好梳理一下好了。\n\n### 不存在变量提升\n变量提升可以换一个词，在代码编译阶段做的申明提前操作。\n随便看几个demo，和var的对比很容易看出来\n```js\nconsole.log(a) // undefined\nvar a = 'var'\n\nconsole.log(b) // 报错，b is not defined\nlet b = 'let'\n```\n那么再看一个demo,涉及到作用域的\n```js\nvar globalObj = {a:1}\nvar func = function() {\n    console.log(globalObj)  //undefined\n    globalObj.b = 2         //报错，cannot 'b' of undefined\n    var globalObj = asdasd\n}\nconsole.log(globalObj)\n```\n虽然globalObj是全局作用域下，func也在里面，但是在内部局部的globalObj优先级高，虽然globalObj在内层是undefined也不影响。\n今天在看犀牛书关于cookie操作的时候有个demo就有这个问题p591\n\n### 暂时性死区\nES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n继续用上一个demo，换成es6的版本，报的错不一样。\n这么做个人感觉挺好，也算是一种规范，以前变量申明之前是可以用这个变量的，值是undefined，这样造成了很多意想不到的情况。\ntips：typeOf方法也有可能报错啦\n```js\nlet globalObj = {a:1}\nconst func = () => {\n    console.log(globalObj)  //Identifier 'globalObj' has already been declared\n    globalObj.b = 2\n    let globalObj = asdasd\n}\nconsole.log(globalObj)\n```\n\n### 不允许重复申明\n```js\nvar a = 1\nvar a = 2\nlet b = 3\nlet b = 4 // b报错， b has been declared\n```\ntip: 函数的形参也可以理解为申明了局部变量，所以也不能再次申明\n### 块级作用域\n先看一下函数作用域不好的地方\n```js\nvar tmp = new Date();\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = 'hello world';\n  }\n}\nf(); // undefined\n```\n阮大给的这个demo挺nice的，f调用的时候本来是想tmp没有暴露到f的作用域下，引擎对tmp执行RHS查询，找到上一层作用域的tmp，但是if条件里面的逻辑没有形成作用域，tem在f函数中为局部变量。\n```js\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++) {\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n```\n初学者写这种代码都没注意到内存泄露等问题，暴露过多的全局变量肯定是不好的。","source":"_posts/es6之let.md","raw":"---\ntitle: es6之let\ndate: 2018-03-13 15:26:31\ntags: es6\ncategory: 读书笔记\n---\n## 概述\n在写上一篇文章，关于cookie的操作时有一个demo，涉及到一个作用域的问题，实验了一下，然后又归纳小结了一波，主要还是参考[阮大的es6入门](http://es6.ruanyifeng.com/#docs/let)，也算是面试经常问的问题，let和var的区别，之前都会回答块级作用域，具体一点的，申明提前，暂时性死区的都会大概提一提。想想还是好好梳理一下好了。\n\n### 不存在变量提升\n变量提升可以换一个词，在代码编译阶段做的申明提前操作。\n随便看几个demo，和var的对比很容易看出来\n```js\nconsole.log(a) // undefined\nvar a = 'var'\n\nconsole.log(b) // 报错，b is not defined\nlet b = 'let'\n```\n那么再看一个demo,涉及到作用域的\n```js\nvar globalObj = {a:1}\nvar func = function() {\n    console.log(globalObj)  //undefined\n    globalObj.b = 2         //报错，cannot 'b' of undefined\n    var globalObj = asdasd\n}\nconsole.log(globalObj)\n```\n虽然globalObj是全局作用域下，func也在里面，但是在内部局部的globalObj优先级高，虽然globalObj在内层是undefined也不影响。\n今天在看犀牛书关于cookie操作的时候有个demo就有这个问题p591\n\n### 暂时性死区\nES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n继续用上一个demo，换成es6的版本，报的错不一样。\n这么做个人感觉挺好，也算是一种规范，以前变量申明之前是可以用这个变量的，值是undefined，这样造成了很多意想不到的情况。\ntips：typeOf方法也有可能报错啦\n```js\nlet globalObj = {a:1}\nconst func = () => {\n    console.log(globalObj)  //Identifier 'globalObj' has already been declared\n    globalObj.b = 2\n    let globalObj = asdasd\n}\nconsole.log(globalObj)\n```\n\n### 不允许重复申明\n```js\nvar a = 1\nvar a = 2\nlet b = 3\nlet b = 4 // b报错， b has been declared\n```\ntip: 函数的形参也可以理解为申明了局部变量，所以也不能再次申明\n### 块级作用域\n先看一下函数作用域不好的地方\n```js\nvar tmp = new Date();\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = 'hello world';\n  }\n}\nf(); // undefined\n```\n阮大给的这个demo挺nice的，f调用的时候本来是想tmp没有暴露到f的作用域下，引擎对tmp执行RHS查询，找到上一层作用域的tmp，但是if条件里面的逻辑没有形成作用域，tem在f函数中为局部变量。\n```js\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++) {\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n```\n初学者写这种代码都没注意到内存泄露等问题，暴露过多的全局变量肯定是不好的。","slug":"es6之let","published":1,"updated":"2018-06-12T16:14:07.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvm5000amsvm8xeo7s63","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>在写上一篇文章，关于cookie的操作时有一个demo，涉及到一个作用域的问题，实验了一下，然后又归纳小结了一波，主要还是参考<a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">阮大的es6入门</a>，也算是面试经常问的问题，let和var的区别，之前都会回答块级作用域，具体一点的，申明提前，暂时性死区的都会大概提一提。想想还是好好梳理一下好了。</p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>变量提升可以换一个词，在代码编译阶段做的申明提前操作。<br>随便看几个demo，和var的对比很容易看出来<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'var'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// 报错，b is not defined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"string\">'let'</span></span><br></pre></td></tr></table></figure></p>\n<p>那么再看一个demo,涉及到作用域的<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globalObj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(globalObj)  <span class=\"comment\">//undefined</span></span><br><span class=\"line\">    globalObj.b = <span class=\"number\">2</span>         <span class=\"comment\">//报错，cannot 'b' of undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> globalObj = asdasd</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(globalObj)</span><br></pre></td></tr></table></figure></p>\n<p>虽然globalObj是全局作用域下，func也在里面，但是在内部局部的globalObj优先级高，虽然globalObj在内层是undefined也不影响。<br>今天在看犀牛书关于cookie操作的时候有个demo就有这个问题p591</p>\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>继续用上一个demo，换成es6的版本，报的错不一样。<br>这么做个人感觉挺好，也算是一种规范，以前变量申明之前是可以用这个变量的，值是undefined，这样造成了很多意想不到的情况。<br>tips：typeOf方法也有可能报错啦<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> globalObj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> func = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(globalObj)  <span class=\"comment\">//Identifier 'globalObj' has already been declared</span></span><br><span class=\"line\">    globalObj.b = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> globalObj = asdasd</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(globalObj)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不允许重复申明\"><a href=\"#不允许重复申明\" class=\"headerlink\" title=\"不允许重复申明\"></a>不允许重复申明</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">4</span> <span class=\"comment\">// b报错， b has been declared</span></span><br></pre></td></tr></table></figure>\n<p>tip: 函数的形参也可以理解为申明了局部变量，所以也不能再次申明</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>先看一下函数作用域不好的地方<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>阮大给的这个demo挺nice的，f调用的时候本来是想tmp没有暴露到f的作用域下，引擎对tmp执行RHS查询，找到上一层作用域的tmp，但是if条件里面的逻辑没有形成作用域，tem在f函数中为局部变量。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>初学者写这种代码都没注意到内存泄露等问题，暴露过多的全局变量肯定是不好的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>在写上一篇文章，关于cookie的操作时有一个demo，涉及到一个作用域的问题，实验了一下，然后又归纳小结了一波，主要还是参考<a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"noopener\">阮大的es6入门</a>，也算是面试经常问的问题，let和var的区别，之前都会回答块级作用域，具体一点的，申明提前，暂时性死区的都会大概提一提。想想还是好好梳理一下好了。</p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>变量提升可以换一个词，在代码编译阶段做的申明提前操作。<br>随便看几个demo，和var的对比很容易看出来<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'var'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// 报错，b is not defined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"string\">'let'</span></span><br></pre></td></tr></table></figure></p>\n<p>那么再看一个demo,涉及到作用域的<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globalObj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(globalObj)  <span class=\"comment\">//undefined</span></span><br><span class=\"line\">    globalObj.b = <span class=\"number\">2</span>         <span class=\"comment\">//报错，cannot 'b' of undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> globalObj = asdasd</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(globalObj)</span><br></pre></td></tr></table></figure></p>\n<p>虽然globalObj是全局作用域下，func也在里面，但是在内部局部的globalObj优先级高，虽然globalObj在内层是undefined也不影响。<br>今天在看犀牛书关于cookie操作的时候有个demo就有这个问题p591</p>\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>继续用上一个demo，换成es6的版本，报的错不一样。<br>这么做个人感觉挺好，也算是一种规范，以前变量申明之前是可以用这个变量的，值是undefined，这样造成了很多意想不到的情况。<br>tips：typeOf方法也有可能报错啦<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> globalObj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> func = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(globalObj)  <span class=\"comment\">//Identifier 'globalObj' has already been declared</span></span><br><span class=\"line\">    globalObj.b = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> globalObj = asdasd</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(globalObj)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不允许重复申明\"><a href=\"#不允许重复申明\" class=\"headerlink\" title=\"不允许重复申明\"></a>不允许重复申明</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">4</span> <span class=\"comment\">// b报错， b has been declared</span></span><br></pre></td></tr></table></figure>\n<p>tip: 函数的形参也可以理解为申明了局部变量，所以也不能再次申明</p>\n<h3 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h3><p>先看一下函数作用域不好的地方<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>阮大给的这个demo挺nice的，f调用的时候本来是想tmp没有暴露到f的作用域下，引擎对tmp执行RHS查询，找到上一层作用域的tmp，但是if条件里面的逻辑没有形成作用域，tem在f函数中为局部变量。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>初学者写这种代码都没注意到内存泄露等问题，暴露过多的全局变量肯定是不好的。</p>\n"},{"title":"css之圣杯布局","date":"2018-03-21T03:08:15.000Z","_content":"## 概述\ncss一只是我很薄弱的一个点，也一直不够重视。最近写一个页面的时候，常见的圣杯布局就写得很难受，所以就趁机好好学习一把。哈哈\n\n## flex\n阮一峰老师写的很全面了，浅显易懂。从自己的角度理解一下\n\n<a href = \"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">flex布局——语法篇</a>\n\n<a href = \"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\">flex布局——实例篇</a>\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n#### 容器（container）的属性\n\n任何容器都可以指定为flex布局\n```css\n.box {\n    display: flex\n}\n```\n容器一共有以下6个属性,第一个为默认值\n> 这里注释是错误的。但是。。。我懒得改了\n```css\n.box {\n    // 项目的排列方向\n    flex-direction: row | row-reverse | column | column-reverse;\n\n    // 换行方式\n    flex-wrap: nowrap | wrap | wrap-reverse;\n\n    // flex-direction 和 flex-wrap的简写，默认为 row nowrap\n    flex-flow: <flex-direction> || <flex-wrap>;\n\n    // justify-content属性定义了项目在主轴上的对齐方式\n    justify-content: flex-start | flex-end | center | space-between | space-around;\n\n    // align-items属性定义项目在交叉轴上如何对齐。\n    align-items: flex-start | flex-end | center | baseline | stretch;\n\n    // align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n    align-content: flex-start | flex-end | center | space-between | space-around | stretch\n}\n\n```\n#### 项目的属性\n\n项目属性同样也有6个\n```css\n.item {\n    // order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n    order: <integer>;\n\n    // flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n    flex-grow: <number>; /* default 0 */\n\n    // flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n    flex-shrink:  <number>; /* default 1 */\n\n    //  flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n     flex-basis: <length> | auto; /* default auto */\n\n    // 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n\n  //align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n#### 相对定位实现\n\n直接看demo啦\n```html\n    <div class=\"container\">\n        <div class=\"main\">main</div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n    </div>\n```\n\n通过-margin和相对定位实现\n\n```css\n     .container {\n        padding: 0 200px 0 150px;\n        height: 100vh;\n        background-color: green\n    }\n\n    .main {\n        width: 100%;\n        background-color: red;\n        float: left\n    }\n\n    .left {\n        margin-left: -100%;\n        position: relative;\n        right: 150px;\n        width: 150px;\n        background-color: blue;\n        float: left\n    }\n\n    .right {\n        position: relative;\n        margin-left: -200px;\n        left:200px;\n        width: 200px;\n        float: left;        \n        background-color: pink\n    }\n```\n\n#### 双飞翼布局\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决 “中间栏div内容不被遮挡”问题的思路不一样。 \n\nhtml结构有所改变\n```html\n    <div class=\"container\">\n        <div class=\"main\">\n            <div class=\"content\">main</div> \n        </div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n    </div>\n```\n\n```css\n    .container {\n        height: 100vh;\n        text-align: center;\n        background-color: green\n    }\n    .content {\n        height:100%;\n        margin: 0 200px 0 150px;\n    }\n    .main {\n        width: 100%;\n        height: 100%;\n        background-color: red;\n        float: left\n    }\n\n    .left {\n        margin-left: -100%;\n        height: 100%;\n        width: 150px;\n        background-color: blue;\n        float: left\n    }\n\n    .right {\n        margin-left: -200px;\n        height: 100%;\n        width: 200px;\n        float: left;        \n        background-color: pink\n    }\n```\ncss简单了，不需要相对定位了\n\n\n#### flex实现\n```css\n    .container {\n        height: 100vh;\n        display: flex;\n        background-color: green\n    }\n\n    .main {\n        flex: 1;\n        height: 90vh;\n        background-color: red;\n    }\n\n    .left {\n        order: -1;\n        flex: 0 0 20%;\n        height: 90vh;\n        background-color: blue;\n    }\n\n    .right {\n        flex: 0 0 15%;\n        height: 90vh;\n        background-color: pink\n    }\n\n```\n\n个人最喜欢的实现方式\n\n#### 小节\n\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性）。\n\n\n","source":"_posts/css之圣杯布局.md","raw":"---\ntitle: css之圣杯布局\ndate: 2018-03-21 11:08:15\ntags: 页面布局\ncategory: CSS\n---\n## 概述\ncss一只是我很薄弱的一个点，也一直不够重视。最近写一个页面的时候，常见的圣杯布局就写得很难受，所以就趁机好好学习一把。哈哈\n\n## flex\n阮一峰老师写的很全面了，浅显易懂。从自己的角度理解一下\n\n<a href = \"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">flex布局——语法篇</a>\n\n<a href = \"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\">flex布局——实例篇</a>\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n#### 容器（container）的属性\n\n任何容器都可以指定为flex布局\n```css\n.box {\n    display: flex\n}\n```\n容器一共有以下6个属性,第一个为默认值\n> 这里注释是错误的。但是。。。我懒得改了\n```css\n.box {\n    // 项目的排列方向\n    flex-direction: row | row-reverse | column | column-reverse;\n\n    // 换行方式\n    flex-wrap: nowrap | wrap | wrap-reverse;\n\n    // flex-direction 和 flex-wrap的简写，默认为 row nowrap\n    flex-flow: <flex-direction> || <flex-wrap>;\n\n    // justify-content属性定义了项目在主轴上的对齐方式\n    justify-content: flex-start | flex-end | center | space-between | space-around;\n\n    // align-items属性定义项目在交叉轴上如何对齐。\n    align-items: flex-start | flex-end | center | baseline | stretch;\n\n    // align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n    align-content: flex-start | flex-end | center | space-between | space-around | stretch\n}\n\n```\n#### 项目的属性\n\n项目属性同样也有6个\n```css\n.item {\n    // order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n    order: <integer>;\n\n    // flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n    flex-grow: <number>; /* default 0 */\n\n    // flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n    flex-shrink:  <number>; /* default 1 */\n\n    //  flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n     flex-basis: <length> | auto; /* default auto */\n\n    // 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n\n  //align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n#### 相对定位实现\n\n直接看demo啦\n```html\n    <div class=\"container\">\n        <div class=\"main\">main</div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n    </div>\n```\n\n通过-margin和相对定位实现\n\n```css\n     .container {\n        padding: 0 200px 0 150px;\n        height: 100vh;\n        background-color: green\n    }\n\n    .main {\n        width: 100%;\n        background-color: red;\n        float: left\n    }\n\n    .left {\n        margin-left: -100%;\n        position: relative;\n        right: 150px;\n        width: 150px;\n        background-color: blue;\n        float: left\n    }\n\n    .right {\n        position: relative;\n        margin-left: -200px;\n        left:200px;\n        width: 200px;\n        float: left;        \n        background-color: pink\n    }\n```\n\n#### 双飞翼布局\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决 “中间栏div内容不被遮挡”问题的思路不一样。 \n\nhtml结构有所改变\n```html\n    <div class=\"container\">\n        <div class=\"main\">\n            <div class=\"content\">main</div> \n        </div>\n        <div class=\"left\">left</div>\n        <div class=\"right\">right</div>\n    </div>\n```\n\n```css\n    .container {\n        height: 100vh;\n        text-align: center;\n        background-color: green\n    }\n    .content {\n        height:100%;\n        margin: 0 200px 0 150px;\n    }\n    .main {\n        width: 100%;\n        height: 100%;\n        background-color: red;\n        float: left\n    }\n\n    .left {\n        margin-left: -100%;\n        height: 100%;\n        width: 150px;\n        background-color: blue;\n        float: left\n    }\n\n    .right {\n        margin-left: -200px;\n        height: 100%;\n        width: 200px;\n        float: left;        \n        background-color: pink\n    }\n```\ncss简单了，不需要相对定位了\n\n\n#### flex实现\n```css\n    .container {\n        height: 100vh;\n        display: flex;\n        background-color: green\n    }\n\n    .main {\n        flex: 1;\n        height: 90vh;\n        background-color: red;\n    }\n\n    .left {\n        order: -1;\n        flex: 0 0 20%;\n        height: 90vh;\n        background-color: blue;\n    }\n\n    .right {\n        flex: 0 0 15%;\n        height: 90vh;\n        background-color: pink\n    }\n\n```\n\n个人最喜欢的实现方式\n\n#### 小节\n\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性）。\n\n\n","slug":"css之圣杯布局","published":1,"updated":"2018-06-12T16:14:07.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvm6000cmsvm7ezht8sq","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>css一只是我很薄弱的一个点，也一直不够重视。最近写一个页面的时候，常见的圣杯布局就写得很难受，所以就趁机好好学习一把。哈哈</p>\n<h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><p>阮一峰老师写的很全面了，浅显易懂。从自己的角度理解一下</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">flex布局——语法篇</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">flex布局——实例篇</a></p>\n<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>\n<h4 id=\"容器（container）的属性\"><a href=\"#容器（container）的属性\" class=\"headerlink\" title=\"容器（container）的属性\"></a>容器（container）的属性</h4><p>任何容器都可以指定为flex布局<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>容器一共有以下6个属性,第一个为默认值</p>\n<blockquote>\n<p>这里注释是错误的。但是。。。我懒得改了<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    // 项目的排列方向</span><br><span class=\"line\">    flex-direction: row | row-reverse | column | column-reverse;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 换行方式</span><br><span class=\"line\">    flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\"></span><br><span class=\"line\">    // flex-direction 和 flex-wrap的简写，默认为 row nowrap</span><br><span class=\"line\">    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // justify-content属性定义了项目在主轴上的对齐方式</span><br><span class=\"line\">    justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class=\"line\"></span><br><span class=\"line\">    // align-items属性定义项目在交叉轴上如何对齐。</span><br><span class=\"line\">    align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\"></span><br><span class=\"line\">    // align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br><span class=\"line\">    align-content: flex-start | flex-end | center | space-between | space-around | stretch</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h4><p>项目属性同样也有6个<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">    // order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</span><br><span class=\"line\">    <span class=\"selector-tag\">order</span>: &lt;<span class=\"selector-tag\">integer</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br><span class=\"line\">    <span class=\"selector-tag\">flex-grow</span>: &lt;<span class=\"selector-tag\">number</span>&gt;; <span class=\"comment\">/* default 0 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    // flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class=\"line\">    <span class=\"selector-tag\">flex-shrink</span>:  &lt;<span class=\"selector-tag\">number</span>&gt;; <span class=\"comment\">/* default 1 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    //  flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class=\"line\">     flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class=\"line\"></span><br><span class=\"line\">    // 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</span><br><span class=\"line\">建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</span><br><span class=\"line\">  flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\">  //align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默</span><br><span class=\"line\">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"相对定位实现\"><a href=\"#相对定位实现\" class=\"headerlink\" title=\"相对定位实现\"></a>相对定位实现</h4><p>直接看demo啦<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"main\"</span>&gt;</span>main<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>left<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span>right<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>通过-margin和相对定位实现</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">200px</span> <span class=\"number\">0</span> <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;        </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: pink</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h4><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决 “中间栏div内容不被遮挡”问题的思路不一样。 </p>\n<p>html结构有所改变<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"main\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span>main<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>left<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span>right<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">200px</span> <span class=\"number\">0</span> <span class=\"number\">150px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;        </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: pink</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>css简单了，不需要相对定位了</p>\n<h4 id=\"flex实现\"><a href=\"#flex实现\" class=\"headerlink\" title=\"flex实现\"></a>flex实现</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">90vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">order</span>: -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">20%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">90vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">15%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">90vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: pink</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>个人最喜欢的实现方式</p>\n<h4 id=\"小节\"><a href=\"#小节\" class=\"headerlink\" title=\"小节\"></a>小节</h4><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>css一只是我很薄弱的一个点，也一直不够重视。最近写一个页面的时候，常见的圣杯布局就写得很难受，所以就趁机好好学习一把。哈哈</p>\n<h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><p>阮一峰老师写的很全面了，浅显易懂。从自己的角度理解一下</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">flex布局——语法篇</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">flex布局——实例篇</a></p>\n<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>\n<h4 id=\"容器（container）的属性\"><a href=\"#容器（container）的属性\" class=\"headerlink\" title=\"容器（container）的属性\"></a>容器（container）的属性</h4><p>任何容器都可以指定为flex布局<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>容器一共有以下6个属性,第一个为默认值</p>\n<blockquote>\n<p>这里注释是错误的。但是。。。我懒得改了<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    // 项目的排列方向</span><br><span class=\"line\">    flex-direction: row | row-reverse | column | column-reverse;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 换行方式</span><br><span class=\"line\">    flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\"></span><br><span class=\"line\">    // flex-direction 和 flex-wrap的简写，默认为 row nowrap</span><br><span class=\"line\">    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // justify-content属性定义了项目在主轴上的对齐方式</span><br><span class=\"line\">    justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class=\"line\"></span><br><span class=\"line\">    // align-items属性定义项目在交叉轴上如何对齐。</span><br><span class=\"line\">    align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\"></span><br><span class=\"line\">    // align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br><span class=\"line\">    align-content: flex-start | flex-end | center | space-between | space-around | stretch</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h4><p>项目属性同样也有6个<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">    // order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</span><br><span class=\"line\">    <span class=\"selector-tag\">order</span>: &lt;<span class=\"selector-tag\">integer</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br><span class=\"line\">    <span class=\"selector-tag\">flex-grow</span>: &lt;<span class=\"selector-tag\">number</span>&gt;; <span class=\"comment\">/* default 0 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    // flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class=\"line\">    <span class=\"selector-tag\">flex-shrink</span>:  &lt;<span class=\"selector-tag\">number</span>&gt;; <span class=\"comment\">/* default 1 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    //  flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class=\"line\">     flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class=\"line\"></span><br><span class=\"line\">    // 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</span><br><span class=\"line\">建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</span><br><span class=\"line\">  flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\">  //align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默</span><br><span class=\"line\">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"相对定位实现\"><a href=\"#相对定位实现\" class=\"headerlink\" title=\"相对定位实现\"></a>相对定位实现</h4><p>直接看demo啦<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"main\"</span>&gt;</span>main<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>left<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span>right<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>通过-margin和相对定位实现</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">200px</span> <span class=\"number\">0</span> <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;        </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: pink</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h4><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决 “中间栏div内容不被遮挡”问题的思路不一样。 </p>\n<p>html结构有所改变<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"main\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span>main<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>left<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span>right<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">200px</span> <span class=\"number\">0</span> <span class=\"number\">150px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;        </span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: pink</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>css简单了，不需要相对定位了</p>\n<h4 id=\"flex实现\"><a href=\"#flex实现\" class=\"headerlink\" title=\"flex实现\"></a>flex实现</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">90vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">order</span>: -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">20%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">90vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">15%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">90vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: pink</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>个人最喜欢的实现方式</p>\n<h4 id=\"小节\"><a href=\"#小节\" class=\"headerlink\" title=\"小节\"></a>小节</h4><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性）。</p>\n"},{"title":"javascript权威指南-第三章（类型）","date":"2018-03-13T07:29:36.000Z","_content":"## 概述\n这一章主要是讲类型、值、变量。以前觉得大概都知道，但是静下心来好好看，还是看到了很多以前理解错误的地方。\n### 数据类型\njs中的数据类型：分为基本类型和引用类型\nstring num boolean undefined null，引用类型就是指object这一个大的类别，包括function array等。\nnull可以理解为特殊的对象值。理解了这个，typeof返回什么之类的就很清晰了。\n### num\n1. Math.max(...args) 居然原生支持取出最大值/最小值的api\n2. Infinity 的概念。0/0 ,无穷大除以无穷大，或者强制转不能转成数字的操作都会返回NaN\n3. Infinity 和 NaN 都只是可读的\n4. NaN和谁都不相等。判断是不是NaN的方法 x != x.这个函数的作用和isNaN相识\n5. 实数有无数个，但是js只能表现有限的个数。That is to say,js中实数都是一个近似值。2进制的表示法表示不了0.1这样的数字，所以 0.3-0.2 === 0.2-0.1返回false \n\n### string\nstring是基本的数据类型，任何操作都不会改变它，虽然可以操作数组一样操作它。<a href = 'http://www.cnblogs.com/littledu/archive/2011/04/18/2019475.html'>注意区分slice、substring、substr的区别</a>\n简单来说，3个方法都可以截取字符串的一段，从开始位置到结束位置(不包括结束位置)，区别体现在位置参数为负数的时候\n\n### bool值\n涉及到一个强转的问题。null undefined 0 -0 NaN “ ” 都会转为false\n### null 和 undefined\nnull: 关键字。表示对象字符串num是无值的，也是一个对象，表示‘非对象’\n\nundefined：不是关键字。表示变量没有初始化\n### 包装对象\n存取字符串数字bool的属性的时候创建的对象，包装对象和原始值不全等\n这里还是有点坑的，只是不愿意去理解太多。\n### 不可变和可变\n一言以蔽之，基本类型都是不可变的，引用类型都是可变的。\n\n```js\nlet a = {a:1,b:2}\nlet b = a // b只是通过a拿到对象的引用，a,b指向的都是同一个内存空间\nb.a = 3\na //也会改变\n```\n可以看下<a href = 'https://gycdgg.github.io/2017/08/31/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D/'>对象拷贝简单实现</a>\n### 类型转换\n== 和 === 的区别在于==在比较之前做了一次类型转换。\n**太多规则，记不住。以后再看**\n\n### 变量作用域\n你不知道的js看了太多了。声明提前的操作在代码编译阶段，不是在执行阶段。一个有意思的代码块\n```js\nvar scope = 'global'\nfunction test(){\n    console.log(scope)  // undefined,不是global，一定要注意，局部变量始终在函数体中有定义\n    var scope = 'local'\n    console.log(scope)  // 'local'\n}\n```\n\n###总结\n都是自己理解上不太准确的地方，或者说容易忘记的地方。记录一下","source":"_posts/javascript权威指南-第三章（类型）.md","raw":"---\ntitle: javascript权威指南-第三章（类型）\ndate: 2018-03-13 15:29:36\ntags: 读书笔记\ncategory: 读书笔记\n---\n## 概述\n这一章主要是讲类型、值、变量。以前觉得大概都知道，但是静下心来好好看，还是看到了很多以前理解错误的地方。\n### 数据类型\njs中的数据类型：分为基本类型和引用类型\nstring num boolean undefined null，引用类型就是指object这一个大的类别，包括function array等。\nnull可以理解为特殊的对象值。理解了这个，typeof返回什么之类的就很清晰了。\n### num\n1. Math.max(...args) 居然原生支持取出最大值/最小值的api\n2. Infinity 的概念。0/0 ,无穷大除以无穷大，或者强制转不能转成数字的操作都会返回NaN\n3. Infinity 和 NaN 都只是可读的\n4. NaN和谁都不相等。判断是不是NaN的方法 x != x.这个函数的作用和isNaN相识\n5. 实数有无数个，但是js只能表现有限的个数。That is to say,js中实数都是一个近似值。2进制的表示法表示不了0.1这样的数字，所以 0.3-0.2 === 0.2-0.1返回false \n\n### string\nstring是基本的数据类型，任何操作都不会改变它，虽然可以操作数组一样操作它。<a href = 'http://www.cnblogs.com/littledu/archive/2011/04/18/2019475.html'>注意区分slice、substring、substr的区别</a>\n简单来说，3个方法都可以截取字符串的一段，从开始位置到结束位置(不包括结束位置)，区别体现在位置参数为负数的时候\n\n### bool值\n涉及到一个强转的问题。null undefined 0 -0 NaN “ ” 都会转为false\n### null 和 undefined\nnull: 关键字。表示对象字符串num是无值的，也是一个对象，表示‘非对象’\n\nundefined：不是关键字。表示变量没有初始化\n### 包装对象\n存取字符串数字bool的属性的时候创建的对象，包装对象和原始值不全等\n这里还是有点坑的，只是不愿意去理解太多。\n### 不可变和可变\n一言以蔽之，基本类型都是不可变的，引用类型都是可变的。\n\n```js\nlet a = {a:1,b:2}\nlet b = a // b只是通过a拿到对象的引用，a,b指向的都是同一个内存空间\nb.a = 3\na //也会改变\n```\n可以看下<a href = 'https://gycdgg.github.io/2017/08/31/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D/'>对象拷贝简单实现</a>\n### 类型转换\n== 和 === 的区别在于==在比较之前做了一次类型转换。\n**太多规则，记不住。以后再看**\n\n### 变量作用域\n你不知道的js看了太多了。声明提前的操作在代码编译阶段，不是在执行阶段。一个有意思的代码块\n```js\nvar scope = 'global'\nfunction test(){\n    console.log(scope)  // undefined,不是global，一定要注意，局部变量始终在函数体中有定义\n    var scope = 'local'\n    console.log(scope)  // 'local'\n}\n```\n\n###总结\n都是自己理解上不太准确的地方，或者说容易忘记的地方。记录一下","slug":"javascript权威指南-第三章（类型）","published":1,"updated":"2018-06-21T14:15:56.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvm9000gmsvmrqjrcoya","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>这一章主要是讲类型、值、变量。以前觉得大概都知道，但是静下心来好好看，还是看到了很多以前理解错误的地方。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>js中的数据类型：分为基本类型和引用类型<br>string num boolean undefined null，引用类型就是指object这一个大的类别，包括function array等。<br>null可以理解为特殊的对象值。理解了这个，typeof返回什么之类的就很清晰了。</p>\n<h3 id=\"num\"><a href=\"#num\" class=\"headerlink\" title=\"num\"></a>num</h3><ol>\n<li>Math.max(…args) 居然原生支持取出最大值/最小值的api</li>\n<li>Infinity 的概念。0/0 ,无穷大除以无穷大，或者强制转不能转成数字的操作都会返回NaN</li>\n<li>Infinity 和 NaN 都只是可读的</li>\n<li>NaN和谁都不相等。判断是不是NaN的方法 x != x.这个函数的作用和isNaN相识</li>\n<li>实数有无数个，但是js只能表现有限的个数。That is to say,js中实数都是一个近似值。2进制的表示法表示不了0.1这样的数字，所以 0.3-0.2 === 0.2-0.1返回false </li>\n</ol>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>string是基本的数据类型，任何操作都不会改变它，虽然可以操作数组一样操作它。<a href=\"http://www.cnblogs.com/littledu/archive/2011/04/18/2019475.html\" target=\"_blank\" rel=\"noopener\">注意区分slice、substring、substr的区别</a><br>简单来说，3个方法都可以截取字符串的一段，从开始位置到结束位置(不包括结束位置)，区别体现在位置参数为负数的时候</p>\n<h3 id=\"bool值\"><a href=\"#bool值\" class=\"headerlink\" title=\"bool值\"></a>bool值</h3><p>涉及到一个强转的问题。null undefined 0 -0 NaN “ ” 都会转为false</p>\n<h3 id=\"null-和-undefined\"><a href=\"#null-和-undefined\" class=\"headerlink\" title=\"null 和 undefined\"></a>null 和 undefined</h3><p>null: 关键字。表示对象字符串num是无值的，也是一个对象，表示‘非对象’</p>\n<p>undefined：不是关键字。表示变量没有初始化</p>\n<h3 id=\"包装对象\"><a href=\"#包装对象\" class=\"headerlink\" title=\"包装对象\"></a>包装对象</h3><p>存取字符串数字bool的属性的时候创建的对象，包装对象和原始值不全等<br>这里还是有点坑的，只是不愿意去理解太多。</p>\n<h3 id=\"不可变和可变\"><a href=\"#不可变和可变\" class=\"headerlink\" title=\"不可变和可变\"></a>不可变和可变</h3><p>一言以蔽之，基本类型都是不可变的，引用类型都是可变的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a <span class=\"comment\">// b只是通过a拿到对象的引用，a,b指向的都是同一个内存空间</span></span><br><span class=\"line\">b.a = <span class=\"number\">3</span></span><br><span class=\"line\">a <span class=\"comment\">//也会改变</span></span><br></pre></td></tr></table></figure>\n<p>可以看下<a href=\"https://gycdgg.github.io/2017/08/31/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D/\" target=\"_blank\" rel=\"noopener\">对象拷贝简单实现</a></p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>== 和 === 的区别在于==在比较之前做了一次类型转换。<br><strong>太多规则，记不住。以后再看</strong></p>\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>你不知道的js看了太多了。声明提前的操作在代码编译阶段，不是在执行阶段。一个有意思的代码块<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(scope)  <span class=\"comment\">// undefined,不是global，一定要注意，局部变量始终在函数体中有定义</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local'</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(scope)  <span class=\"comment\">// 'local'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>###总结<br>都是自己理解上不太准确的地方，或者说容易忘记的地方。记录一下</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>这一章主要是讲类型、值、变量。以前觉得大概都知道，但是静下心来好好看，还是看到了很多以前理解错误的地方。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>js中的数据类型：分为基本类型和引用类型<br>string num boolean undefined null，引用类型就是指object这一个大的类别，包括function array等。<br>null可以理解为特殊的对象值。理解了这个，typeof返回什么之类的就很清晰了。</p>\n<h3 id=\"num\"><a href=\"#num\" class=\"headerlink\" title=\"num\"></a>num</h3><ol>\n<li>Math.max(…args) 居然原生支持取出最大值/最小值的api</li>\n<li>Infinity 的概念。0/0 ,无穷大除以无穷大，或者强制转不能转成数字的操作都会返回NaN</li>\n<li>Infinity 和 NaN 都只是可读的</li>\n<li>NaN和谁都不相等。判断是不是NaN的方法 x != x.这个函数的作用和isNaN相识</li>\n<li>实数有无数个，但是js只能表现有限的个数。That is to say,js中实数都是一个近似值。2进制的表示法表示不了0.1这样的数字，所以 0.3-0.2 === 0.2-0.1返回false </li>\n</ol>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>string是基本的数据类型，任何操作都不会改变它，虽然可以操作数组一样操作它。<a href=\"http://www.cnblogs.com/littledu/archive/2011/04/18/2019475.html\" target=\"_blank\" rel=\"noopener\">注意区分slice、substring、substr的区别</a><br>简单来说，3个方法都可以截取字符串的一段，从开始位置到结束位置(不包括结束位置)，区别体现在位置参数为负数的时候</p>\n<h3 id=\"bool值\"><a href=\"#bool值\" class=\"headerlink\" title=\"bool值\"></a>bool值</h3><p>涉及到一个强转的问题。null undefined 0 -0 NaN “ ” 都会转为false</p>\n<h3 id=\"null-和-undefined\"><a href=\"#null-和-undefined\" class=\"headerlink\" title=\"null 和 undefined\"></a>null 和 undefined</h3><p>null: 关键字。表示对象字符串num是无值的，也是一个对象，表示‘非对象’</p>\n<p>undefined：不是关键字。表示变量没有初始化</p>\n<h3 id=\"包装对象\"><a href=\"#包装对象\" class=\"headerlink\" title=\"包装对象\"></a>包装对象</h3><p>存取字符串数字bool的属性的时候创建的对象，包装对象和原始值不全等<br>这里还是有点坑的，只是不愿意去理解太多。</p>\n<h3 id=\"不可变和可变\"><a href=\"#不可变和可变\" class=\"headerlink\" title=\"不可变和可变\"></a>不可变和可变</h3><p>一言以蔽之，基本类型都是不可变的，引用类型都是可变的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>,<span class=\"attr\">b</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a <span class=\"comment\">// b只是通过a拿到对象的引用，a,b指向的都是同一个内存空间</span></span><br><span class=\"line\">b.a = <span class=\"number\">3</span></span><br><span class=\"line\">a <span class=\"comment\">//也会改变</span></span><br></pre></td></tr></table></figure>\n<p>可以看下<a href=\"https://gycdgg.github.io/2017/08/31/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D/\" target=\"_blank\" rel=\"noopener\">对象拷贝简单实现</a></p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>== 和 === 的区别在于==在比较之前做了一次类型转换。<br><strong>太多规则，记不住。以后再看</strong></p>\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>你不知道的js看了太多了。声明提前的操作在代码编译阶段，不是在执行阶段。一个有意思的代码块<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(scope)  <span class=\"comment\">// undefined,不是global，一定要注意，局部变量始终在函数体中有定义</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local'</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(scope)  <span class=\"comment\">// 'local'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>###总结<br>都是自己理解上不太准确的地方，或者说容易忘记的地方。记录一下</p>\n"},{"title":"javascript权威指南-第二十章（客户端存储）","date":"2018-03-13T07:28:14.000Z","_content":"## 概述\n二十章讲的是客户端存储，很详细的介绍了常见的几种客户端存储的方式。涉及到一些同源策略的东西，所以就想看一下13章的安全性的问题。也记录一下\n\n### 安全性\n同源策略：脚本不能读取不同服务器载入的文档内容。比如说一个页面的脚本不能监听其他页面的用户输入信息，这就是同源策略。这么来看同源策略是必须的，不然浏览一个网页，所有的其他页面的信息都暴露了。\n    但是确实有场景需要读取其他页面的属性，可以使用document的domain属性，domain默认是载入文档的主机名，可以人为设置，比如home.example.com可以设置成example.com。不能设置成home.example或者ample.com之类的，也必须有一个.（避免出现com的情况）如果2个窗口的domain一致，就没有同源限制啦。\n    跨域资源共享：origin，请求头设置Access-Control-Allow-Origin\n\n\n#### XSS(粗略了讲了一点安全问题)\n\n对于url:http://www.example.com/greet.html?David\n```js\n    let name = decodeURIComponent(window.location.search.substring(1)) // search可以拿到？之后的字段（可以理解为query字段？？？），转码之后可以拿到David\n    alert(name)\n```\n但是如果调用http://http.www.example.com/greet.html?name=%3Cscript src=siteB/evil.js%3E%3C/script%3E\n这样会注入一个来自siteB的脚本，脚本在sideB中，但是可以在A中进行操作，比较危险\n\n防止XSS的，通过不可信的数据来的时候，去掉里面的HTML标签（包括script标签）,\n简单的实现安全函数\n```js\nname = name.replace(/</g, '<').replace(/</g,'>')\n```\n### localStorage和sessionStorage的区别\n两者的区别在于存储的**有效期**和**作用域**不同，也就是可以存储多长时间以及谁对数据有访问权。\nstorage都定义了存储、获取、删除的方法\n\n#### 有效期和作用域\nlocalStorage的作用域是文档源级别。文档源就是协议主机和端口一致，也就是说同一个浏览器开多个窗口打开一个页面，是可以共享localStorage的。但是受浏览器供应商的限制。\nsessionStorage的作用域也是文档源级别，但是不太相同，它是限定在窗口中的。在不同的标签中不共享。\nsessionStorage在浏览器或者标签页关闭，sessionStorage里面存的数据会被删除。\n\n#### 存储的API\n```js\nlocalStorage.setItem('x', 1)\nlocalStorage.getItem('X')\n/// 遍历\nfor(let i= 0; i< localStorage.length; i++ ){\n    let name = localStorage.key(i)\n    let value = localStorage.getItem(name)\n}\nlocalStorage.removeItem('X')    //删除X项\nlocalStorage.clear()            //全部删除\n```\n\n### cookie\n\n#### cookie属性：有效期和作用域\n    cookie的默认有效期是浏览器的会话期间。但是和sessionStorage有区别，cookie不局限在浏览器单个窗口，有效期和整个浏览器的进程有关。\n    通过max-age设置有效期设置有效期，他的作用域可以通过path和domain来配置，默认情况和创建他的web页面有关，对子页面可见。\n**如果路径设置成'/'就和localStorage一样的作用域了**\n\n#### 保存cookie\n```js\n// cookie中不允许包含分毫、逗号和空白符，所以一般采用encodeURIComponent转码\n// 最简单的cookie设置，浏览器关闭清除\ndocument.cookie = 'version=' + encodeURIComponent(document.lastModified)\n\n// 一个可选max-age、path、domain、secure属性的方法\n// 通过设置domain可以解决cookie跨域的问题\nconst setCookie = (name, value, daysTolive, path, path) = {\n    let cookie = `${name}=${encodeURLComponent(value)}`\n    if(typeOf daysToLive === 'number'){\n        cookie += `; max-age=${daysToLive * 60 * 60 * 24}`\n    }\n    if(path){\n        cookie += `; path=${path}`\n    }\n    if(domain){\n        cookie += `; domain=${domain}`\n    }\n    document.cookie = cookie\n}\n```\n#### 读取cookie\n通过document.cookie读取出来的是一个字符串，不同键值对通过f分号和空格隔开。value的解码方式取决于之前存储用的方式，例如上面用到的setCookie中用的方式是encodeURIComponent编码\n```js\nconst getCookie = (){\n    let cookieObj = {}\n    let cookieStr = document.cookie\n    if(cookieStr === ''){\n        return cookieObj\n    }\n    let cookieArr = cookieStr.split('; ')\n    for(let _cookie of cookieArr){\n        let p = _cookie.indexOf('=')\n        let name = _cookie.slice(0,p)\n        let value = _cookie.slice(p+1)\n        value = decodeURIComponent(value)\n        cookieObj[name] = value\n    }\n    return cookieObj\n}\n```\n#### cookie相关的存储\n实现类似于sessionStorage的getItem、setItem、remove、delete等功能\n```js\nconst cookieStorage(maxage, path) {\n    //自执行函数实例化一个cookie对象\n    let cookie = (()=>{\n        let cookieObj = {}\n        let cookieStr = document.cookie\n        if(cookieStr === ''){\n        return cookieObj\n        }\n        let cookieArr = cookieStr.split('; ')\n        for(let _cookie of cookieArr){\n            let p = _cookie.indexOf('=')\n            let name = _cookie.slice(0,p)\n            let value = _cookie.slice(p+1)\n            value = decodeURIComponent(value)\n            cookieObj[name] = value\n        }\n        return cookieObj\n    }())\n    // 拿出所有的key\n    let keys = Object.keys(cookie)\n    //存储API公共的属性和方法\n    this.length = keys.length\n    //返回第n个key的名字，即key方法\n    this.key = (n) => {\n        if (n<0 || n >= keys.length) return null\n        return keys[n]\n    }\n    //getItem方法\n    this.getItem = (name) => cookie[name] || null\n    // setItem方法\n    this.setItem = (key,value) => {\n        //首先判断要存储的cookie存在不,不存在先操作一次keys和length\n        if(!(key in keys)){\n            keys.push(key)\n            this.length++\n        }\n        // 针对cookie对象做的操作\n        cookie[key] = value\n        //接下来就是正式操作浏览器中的cookie\n        let domCookie = `${key}=${encodeURIComponent(value)}`\n        if(maxage) domCookie += `; max-age=${maxage}`\n        if(path) domCookie += `; path=${path}`\n        document.cookie = domCookie\n    }\n    // removeCookie\n    this.removeItem = (key) => {\n        if(!(key in cookie)) return\n        delete cookie[key]\n        this.length--\n        let p = keys.indexOf(key)\n        keys.splice(p,1)\n        document.cookie = \n    }\n    // clear\n    this.clear = () => {\n        for(let key of keys){\n            document.cookie = `${key}=; max-age=0`\n        }\n        cookie = {}\n        keys = []\n        this.length = 0\n    }\n}\n```","source":"_posts/javascript权威指南-第二十章（客户端存储）.md","raw":"---\ntitle: javascript权威指南-第二十章（客户端存储）\ndate: 2018-03-13 15:28:14\ntags: 读书笔记\ncategory: 读书笔记\n---\n## 概述\n二十章讲的是客户端存储，很详细的介绍了常见的几种客户端存储的方式。涉及到一些同源策略的东西，所以就想看一下13章的安全性的问题。也记录一下\n\n### 安全性\n同源策略：脚本不能读取不同服务器载入的文档内容。比如说一个页面的脚本不能监听其他页面的用户输入信息，这就是同源策略。这么来看同源策略是必须的，不然浏览一个网页，所有的其他页面的信息都暴露了。\n    但是确实有场景需要读取其他页面的属性，可以使用document的domain属性，domain默认是载入文档的主机名，可以人为设置，比如home.example.com可以设置成example.com。不能设置成home.example或者ample.com之类的，也必须有一个.（避免出现com的情况）如果2个窗口的domain一致，就没有同源限制啦。\n    跨域资源共享：origin，请求头设置Access-Control-Allow-Origin\n\n\n#### XSS(粗略了讲了一点安全问题)\n\n对于url:http://www.example.com/greet.html?David\n```js\n    let name = decodeURIComponent(window.location.search.substring(1)) // search可以拿到？之后的字段（可以理解为query字段？？？），转码之后可以拿到David\n    alert(name)\n```\n但是如果调用http://http.www.example.com/greet.html?name=%3Cscript src=siteB/evil.js%3E%3C/script%3E\n这样会注入一个来自siteB的脚本，脚本在sideB中，但是可以在A中进行操作，比较危险\n\n防止XSS的，通过不可信的数据来的时候，去掉里面的HTML标签（包括script标签）,\n简单的实现安全函数\n```js\nname = name.replace(/</g, '<').replace(/</g,'>')\n```\n### localStorage和sessionStorage的区别\n两者的区别在于存储的**有效期**和**作用域**不同，也就是可以存储多长时间以及谁对数据有访问权。\nstorage都定义了存储、获取、删除的方法\n\n#### 有效期和作用域\nlocalStorage的作用域是文档源级别。文档源就是协议主机和端口一致，也就是说同一个浏览器开多个窗口打开一个页面，是可以共享localStorage的。但是受浏览器供应商的限制。\nsessionStorage的作用域也是文档源级别，但是不太相同，它是限定在窗口中的。在不同的标签中不共享。\nsessionStorage在浏览器或者标签页关闭，sessionStorage里面存的数据会被删除。\n\n#### 存储的API\n```js\nlocalStorage.setItem('x', 1)\nlocalStorage.getItem('X')\n/// 遍历\nfor(let i= 0; i< localStorage.length; i++ ){\n    let name = localStorage.key(i)\n    let value = localStorage.getItem(name)\n}\nlocalStorage.removeItem('X')    //删除X项\nlocalStorage.clear()            //全部删除\n```\n\n### cookie\n\n#### cookie属性：有效期和作用域\n    cookie的默认有效期是浏览器的会话期间。但是和sessionStorage有区别，cookie不局限在浏览器单个窗口，有效期和整个浏览器的进程有关。\n    通过max-age设置有效期设置有效期，他的作用域可以通过path和domain来配置，默认情况和创建他的web页面有关，对子页面可见。\n**如果路径设置成'/'就和localStorage一样的作用域了**\n\n#### 保存cookie\n```js\n// cookie中不允许包含分毫、逗号和空白符，所以一般采用encodeURIComponent转码\n// 最简单的cookie设置，浏览器关闭清除\ndocument.cookie = 'version=' + encodeURIComponent(document.lastModified)\n\n// 一个可选max-age、path、domain、secure属性的方法\n// 通过设置domain可以解决cookie跨域的问题\nconst setCookie = (name, value, daysTolive, path, path) = {\n    let cookie = `${name}=${encodeURLComponent(value)}`\n    if(typeOf daysToLive === 'number'){\n        cookie += `; max-age=${daysToLive * 60 * 60 * 24}`\n    }\n    if(path){\n        cookie += `; path=${path}`\n    }\n    if(domain){\n        cookie += `; domain=${domain}`\n    }\n    document.cookie = cookie\n}\n```\n#### 读取cookie\n通过document.cookie读取出来的是一个字符串，不同键值对通过f分号和空格隔开。value的解码方式取决于之前存储用的方式，例如上面用到的setCookie中用的方式是encodeURIComponent编码\n```js\nconst getCookie = (){\n    let cookieObj = {}\n    let cookieStr = document.cookie\n    if(cookieStr === ''){\n        return cookieObj\n    }\n    let cookieArr = cookieStr.split('; ')\n    for(let _cookie of cookieArr){\n        let p = _cookie.indexOf('=')\n        let name = _cookie.slice(0,p)\n        let value = _cookie.slice(p+1)\n        value = decodeURIComponent(value)\n        cookieObj[name] = value\n    }\n    return cookieObj\n}\n```\n#### cookie相关的存储\n实现类似于sessionStorage的getItem、setItem、remove、delete等功能\n```js\nconst cookieStorage(maxage, path) {\n    //自执行函数实例化一个cookie对象\n    let cookie = (()=>{\n        let cookieObj = {}\n        let cookieStr = document.cookie\n        if(cookieStr === ''){\n        return cookieObj\n        }\n        let cookieArr = cookieStr.split('; ')\n        for(let _cookie of cookieArr){\n            let p = _cookie.indexOf('=')\n            let name = _cookie.slice(0,p)\n            let value = _cookie.slice(p+1)\n            value = decodeURIComponent(value)\n            cookieObj[name] = value\n        }\n        return cookieObj\n    }())\n    // 拿出所有的key\n    let keys = Object.keys(cookie)\n    //存储API公共的属性和方法\n    this.length = keys.length\n    //返回第n个key的名字，即key方法\n    this.key = (n) => {\n        if (n<0 || n >= keys.length) return null\n        return keys[n]\n    }\n    //getItem方法\n    this.getItem = (name) => cookie[name] || null\n    // setItem方法\n    this.setItem = (key,value) => {\n        //首先判断要存储的cookie存在不,不存在先操作一次keys和length\n        if(!(key in keys)){\n            keys.push(key)\n            this.length++\n        }\n        // 针对cookie对象做的操作\n        cookie[key] = value\n        //接下来就是正式操作浏览器中的cookie\n        let domCookie = `${key}=${encodeURIComponent(value)}`\n        if(maxage) domCookie += `; max-age=${maxage}`\n        if(path) domCookie += `; path=${path}`\n        document.cookie = domCookie\n    }\n    // removeCookie\n    this.removeItem = (key) => {\n        if(!(key in cookie)) return\n        delete cookie[key]\n        this.length--\n        let p = keys.indexOf(key)\n        keys.splice(p,1)\n        document.cookie = \n    }\n    // clear\n    this.clear = () => {\n        for(let key of keys){\n            document.cookie = `${key}=; max-age=0`\n        }\n        cookie = {}\n        keys = []\n        this.length = 0\n    }\n}\n```","slug":"javascript权威指南-第二十章（客户端存储）","published":1,"updated":"2018-06-12T16:14:07.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvma000jmsvmltuqukr0","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>二十章讲的是客户端存储，很详细的介绍了常见的几种客户端存储的方式。涉及到一些同源策略的东西，所以就想看一下13章的安全性的问题。也记录一下</p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>同源策略：脚本不能读取不同服务器载入的文档内容。比如说一个页面的脚本不能监听其他页面的用户输入信息，这就是同源策略。这么来看同源策略是必须的，不然浏览一个网页，所有的其他页面的信息都暴露了。<br>    但是确实有场景需要读取其他页面的属性，可以使用document的domain属性，domain默认是载入文档的主机名，可以人为设置，比如home.example.com可以设置成example.com。不能设置成home.example或者ample.com之类的，也必须有一个.（避免出现com的情况）如果2个窗口的domain一致，就没有同源限制啦。<br>    跨域资源共享：origin，请求头设置Access-Control-Allow-Origin</p>\n<h4 id=\"XSS-粗略了讲了一点安全问题\"><a href=\"#XSS-粗略了讲了一点安全问题\" class=\"headerlink\" title=\"XSS(粗略了讲了一点安全问题)\"></a>XSS(粗略了讲了一点安全问题)</h4><p>对于url:<a href=\"http://www.example.com/greet.html?David\" target=\"_blank\" rel=\"noopener\">http://www.example.com/greet.html?David</a><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"built_in\">decodeURIComponent</span>(<span class=\"built_in\">window</span>.location.search.substring(<span class=\"number\">1</span>)) <span class=\"comment\">// search可以拿到？之后的字段（可以理解为query字段？？？），转码之后可以拿到David</span></span><br><span class=\"line\">alert(name)</span><br></pre></td></tr></table></figure></p>\n<p>但是如果调用<a href=\"http://http.www.example.com/greet.html?name=%3Cscript\" target=\"_blank\" rel=\"noopener\">http://http.www.example.com/greet.html?name=%3Cscript</a> src=siteB/evil.js%3E%3C/script%3E<br>这样会注入一个来自siteB的脚本，脚本在sideB中，但是可以在A中进行操作，比较危险</p>\n<p>防止XSS的，通过不可信的数据来的时候，去掉里面的HTML标签（包括script标签）,<br>简单的实现安全函数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = name.replace(<span class=\"regexp\">/&lt;/g</span>, <span class=\"string\">'&lt;'</span>).replace(<span class=\"regexp\">/&lt;/g</span>,<span class=\"string\">'&gt;'</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"localStorage和sessionStorage的区别\"><a href=\"#localStorage和sessionStorage的区别\" class=\"headerlink\" title=\"localStorage和sessionStorage的区别\"></a>localStorage和sessionStorage的区别</h3><p>两者的区别在于存储的<strong>有效期</strong>和<strong>作用域</strong>不同，也就是可以存储多长时间以及谁对数据有访问权。<br>storage都定义了存储、获取、删除的方法</p>\n<h4 id=\"有效期和作用域\"><a href=\"#有效期和作用域\" class=\"headerlink\" title=\"有效期和作用域\"></a>有效期和作用域</h4><p>localStorage的作用域是文档源级别。文档源就是协议主机和端口一致，也就是说同一个浏览器开多个窗口打开一个页面，是可以共享localStorage的。但是受浏览器供应商的限制。<br>sessionStorage的作用域也是文档源级别，但是不太相同，它是限定在窗口中的。在不同的标签中不共享。<br>sessionStorage在浏览器或者标签页关闭，sessionStorage里面存的数据会被删除。</p>\n<h4 id=\"存储的API\"><a href=\"#存储的API\" class=\"headerlink\" title=\"存储的API\"></a>存储的API</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(<span class=\"string\">'x'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">localStorage.getItem(<span class=\"string\">'X'</span>)</span><br><span class=\"line\"><span class=\"comment\">/// 遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i= <span class=\"number\">0</span>; i&lt; localStorage.length; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = localStorage.key(i)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = localStorage.getItem(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">'X'</span>)    <span class=\"comment\">//删除X项</span></span><br><span class=\"line\">localStorage.clear()            <span class=\"comment\">//全部删除</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h3><h4 id=\"cookie属性：有效期和作用域\"><a href=\"#cookie属性：有效期和作用域\" class=\"headerlink\" title=\"cookie属性：有效期和作用域\"></a>cookie属性：有效期和作用域</h4><pre><code>cookie的默认有效期是浏览器的会话期间。但是和sessionStorage有区别，cookie不局限在浏览器单个窗口，有效期和整个浏览器的进程有关。\n通过max-age设置有效期设置有效期，他的作用域可以通过path和domain来配置，默认情况和创建他的web页面有关，对子页面可见。\n</code></pre><p><strong>如果路径设置成’/‘就和localStorage一样的作用域了</strong></p>\n<h4 id=\"保存cookie\"><a href=\"#保存cookie\" class=\"headerlink\" title=\"保存cookie\"></a>保存cookie</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cookie中不允许包含分毫、逗号和空白符，所以一般采用encodeURIComponent转码</span></span><br><span class=\"line\"><span class=\"comment\">// 最简单的cookie设置，浏览器关闭清除</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">'version='</span> + <span class=\"built_in\">encodeURIComponent</span>(<span class=\"built_in\">document</span>.lastModified)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个可选max-age、path、domain、secure属性的方法</span></span><br><span class=\"line\"><span class=\"comment\">// 通过设置domain可以解决cookie跨域的问题</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> setCookie = (name, value, daysTolive, path, path) = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookie = <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>=<span class=\"subst\">$&#123;encodeURLComponent(value)&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(typeOf daysToLive === <span class=\"string\">'number'</span>)&#123;</span><br><span class=\"line\">        cookie += <span class=\"string\">`; max-age=<span class=\"subst\">$&#123;daysToLive * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>&#125;</span>`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(path)&#123;</span><br><span class=\"line\">        cookie += <span class=\"string\">`; path=<span class=\"subst\">$&#123;path&#125;</span>`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(domain)&#123;</span><br><span class=\"line\">        cookie += <span class=\"string\">`; domain=<span class=\"subst\">$&#123;domain&#125;</span>`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.cookie = cookie</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"读取cookie\"><a href=\"#读取cookie\" class=\"headerlink\" title=\"读取cookie\"></a>读取cookie</h4><p>通过document.cookie读取出来的是一个字符串，不同键值对通过f分号和空格隔开。value的解码方式取决于之前存储用的方式，例如上面用到的setCookie中用的方式是encodeURIComponent编码<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getCookie = ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookieObj = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookieStr = <span class=\"built_in\">document</span>.cookie</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cookieStr === <span class=\"string\">''</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cookieObj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookieArr = cookieStr.split(<span class=\"string\">'; '</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> _cookie <span class=\"keyword\">of</span> cookieArr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p = _cookie.indexOf(<span class=\"string\">'='</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = _cookie.slice(<span class=\"number\">0</span>,p)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = _cookie.slice(p+<span class=\"number\">1</span>)</span><br><span class=\"line\">        value = <span class=\"built_in\">decodeURIComponent</span>(value)</span><br><span class=\"line\">        cookieObj[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cookieObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"cookie相关的存储\"><a href=\"#cookie相关的存储\" class=\"headerlink\" title=\"cookie相关的存储\"></a>cookie相关的存储</h4><p>实现类似于sessionStorage的getItem、setItem、remove、delete等功能<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cookieStorage(maxage, path) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//自执行函数实例化一个cookie对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookie = <span class=\"function\">(<span class=\"params\">(</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cookieObj = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cookieStr = <span class=\"built_in\">document</span>.cookie</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cookieStr === <span class=\"string\">''</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cookieObj</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cookieArr = cookieStr.split(<span class=\"string\">'; '</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> _cookie <span class=\"keyword\">of</span> cookieArr)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> p = _cookie.indexOf(<span class=\"string\">'='</span>)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> name = _cookie.slice(<span class=\"number\">0</span>,p)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> value = _cookie.slice(p+<span class=\"number\">1</span>)</span><br><span class=\"line\">            value = <span class=\"built_in\">decodeURIComponent</span>(value)</span><br><span class=\"line\">            cookieObj[name] = value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cookieObj</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    <span class=\"comment\">// 拿出所有的key</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> keys = <span class=\"built_in\">Object</span>.keys(cookie)</span><br><span class=\"line\">    <span class=\"comment\">//存储API公共的属性和方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.length = keys.length</span><br><span class=\"line\">    <span class=\"comment\">//返回第n个key的名字，即key方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n&lt;<span class=\"number\">0</span> || n &gt;= keys.length) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys[n]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//getItem方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getItem = <span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> cookie[name] || <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">// setItem方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setItem = <span class=\"function\">(<span class=\"params\">key,value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//首先判断要存储的cookie存在不,不存在先操作一次keys和length</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(key <span class=\"keyword\">in</span> keys))&#123;</span><br><span class=\"line\">            keys.push(key)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.length++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 针对cookie对象做的操作</span></span><br><span class=\"line\">        cookie[key] = value</span><br><span class=\"line\">        <span class=\"comment\">//接下来就是正式操作浏览器中的cookie</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> domCookie = <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;<span class=\"built_in\">encodeURIComponent</span>(value)&#125;</span>`</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(maxage) domCookie += <span class=\"string\">`; max-age=<span class=\"subst\">$&#123;maxage&#125;</span>`</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(path) domCookie += <span class=\"string\">`; path=<span class=\"subst\">$&#123;path&#125;</span>`</span></span><br><span class=\"line\">        <span class=\"built_in\">document</span>.cookie = domCookie</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// removeCookie</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.removeItem = <span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(key <span class=\"keyword\">in</span> cookie)) <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> cookie[key]</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.length--</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p = keys.indexOf(key)</span><br><span class=\"line\">        keys.splice(p,<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.cookie = </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// clear</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> keys)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.cookie = <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=; max-age=0`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cookie = &#123;&#125;</span><br><span class=\"line\">        keys = []</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>二十章讲的是客户端存储，很详细的介绍了常见的几种客户端存储的方式。涉及到一些同源策略的东西，所以就想看一下13章的安全性的问题。也记录一下</p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>同源策略：脚本不能读取不同服务器载入的文档内容。比如说一个页面的脚本不能监听其他页面的用户输入信息，这就是同源策略。这么来看同源策略是必须的，不然浏览一个网页，所有的其他页面的信息都暴露了。<br>    但是确实有场景需要读取其他页面的属性，可以使用document的domain属性，domain默认是载入文档的主机名，可以人为设置，比如home.example.com可以设置成example.com。不能设置成home.example或者ample.com之类的，也必须有一个.（避免出现com的情况）如果2个窗口的domain一致，就没有同源限制啦。<br>    跨域资源共享：origin，请求头设置Access-Control-Allow-Origin</p>\n<h4 id=\"XSS-粗略了讲了一点安全问题\"><a href=\"#XSS-粗略了讲了一点安全问题\" class=\"headerlink\" title=\"XSS(粗略了讲了一点安全问题)\"></a>XSS(粗略了讲了一点安全问题)</h4><p>对于url:<a href=\"http://www.example.com/greet.html?David\" target=\"_blank\" rel=\"noopener\">http://www.example.com/greet.html?David</a><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"built_in\">decodeURIComponent</span>(<span class=\"built_in\">window</span>.location.search.substring(<span class=\"number\">1</span>)) <span class=\"comment\">// search可以拿到？之后的字段（可以理解为query字段？？？），转码之后可以拿到David</span></span><br><span class=\"line\">alert(name)</span><br></pre></td></tr></table></figure></p>\n<p>但是如果调用<a href=\"http://http.www.example.com/greet.html?name=%3Cscript\" target=\"_blank\" rel=\"noopener\">http://http.www.example.com/greet.html?name=%3Cscript</a> src=siteB/evil.js%3E%3C/script%3E<br>这样会注入一个来自siteB的脚本，脚本在sideB中，但是可以在A中进行操作，比较危险</p>\n<p>防止XSS的，通过不可信的数据来的时候，去掉里面的HTML标签（包括script标签）,<br>简单的实现安全函数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = name.replace(<span class=\"regexp\">/&lt;/g</span>, <span class=\"string\">'&lt;'</span>).replace(<span class=\"regexp\">/&lt;/g</span>,<span class=\"string\">'&gt;'</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"localStorage和sessionStorage的区别\"><a href=\"#localStorage和sessionStorage的区别\" class=\"headerlink\" title=\"localStorage和sessionStorage的区别\"></a>localStorage和sessionStorage的区别</h3><p>两者的区别在于存储的<strong>有效期</strong>和<strong>作用域</strong>不同，也就是可以存储多长时间以及谁对数据有访问权。<br>storage都定义了存储、获取、删除的方法</p>\n<h4 id=\"有效期和作用域\"><a href=\"#有效期和作用域\" class=\"headerlink\" title=\"有效期和作用域\"></a>有效期和作用域</h4><p>localStorage的作用域是文档源级别。文档源就是协议主机和端口一致，也就是说同一个浏览器开多个窗口打开一个页面，是可以共享localStorage的。但是受浏览器供应商的限制。<br>sessionStorage的作用域也是文档源级别，但是不太相同，它是限定在窗口中的。在不同的标签中不共享。<br>sessionStorage在浏览器或者标签页关闭，sessionStorage里面存的数据会被删除。</p>\n<h4 id=\"存储的API\"><a href=\"#存储的API\" class=\"headerlink\" title=\"存储的API\"></a>存储的API</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(<span class=\"string\">'x'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">localStorage.getItem(<span class=\"string\">'X'</span>)</span><br><span class=\"line\"><span class=\"comment\">/// 遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i= <span class=\"number\">0</span>; i&lt; localStorage.length; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = localStorage.key(i)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = localStorage.getItem(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">'X'</span>)    <span class=\"comment\">//删除X项</span></span><br><span class=\"line\">localStorage.clear()            <span class=\"comment\">//全部删除</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h3><h4 id=\"cookie属性：有效期和作用域\"><a href=\"#cookie属性：有效期和作用域\" class=\"headerlink\" title=\"cookie属性：有效期和作用域\"></a>cookie属性：有效期和作用域</h4><pre><code>cookie的默认有效期是浏览器的会话期间。但是和sessionStorage有区别，cookie不局限在浏览器单个窗口，有效期和整个浏览器的进程有关。\n通过max-age设置有效期设置有效期，他的作用域可以通过path和domain来配置，默认情况和创建他的web页面有关，对子页面可见。\n</code></pre><p><strong>如果路径设置成’/‘就和localStorage一样的作用域了</strong></p>\n<h4 id=\"保存cookie\"><a href=\"#保存cookie\" class=\"headerlink\" title=\"保存cookie\"></a>保存cookie</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cookie中不允许包含分毫、逗号和空白符，所以一般采用encodeURIComponent转码</span></span><br><span class=\"line\"><span class=\"comment\">// 最简单的cookie设置，浏览器关闭清除</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">'version='</span> + <span class=\"built_in\">encodeURIComponent</span>(<span class=\"built_in\">document</span>.lastModified)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个可选max-age、path、domain、secure属性的方法</span></span><br><span class=\"line\"><span class=\"comment\">// 通过设置domain可以解决cookie跨域的问题</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> setCookie = (name, value, daysTolive, path, path) = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookie = <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>=<span class=\"subst\">$&#123;encodeURLComponent(value)&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(typeOf daysToLive === <span class=\"string\">'number'</span>)&#123;</span><br><span class=\"line\">        cookie += <span class=\"string\">`; max-age=<span class=\"subst\">$&#123;daysToLive * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>&#125;</span>`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(path)&#123;</span><br><span class=\"line\">        cookie += <span class=\"string\">`; path=<span class=\"subst\">$&#123;path&#125;</span>`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(domain)&#123;</span><br><span class=\"line\">        cookie += <span class=\"string\">`; domain=<span class=\"subst\">$&#123;domain&#125;</span>`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.cookie = cookie</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"读取cookie\"><a href=\"#读取cookie\" class=\"headerlink\" title=\"读取cookie\"></a>读取cookie</h4><p>通过document.cookie读取出来的是一个字符串，不同键值对通过f分号和空格隔开。value的解码方式取决于之前存储用的方式，例如上面用到的setCookie中用的方式是encodeURIComponent编码<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getCookie = ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookieObj = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookieStr = <span class=\"built_in\">document</span>.cookie</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cookieStr === <span class=\"string\">''</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cookieObj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookieArr = cookieStr.split(<span class=\"string\">'; '</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> _cookie <span class=\"keyword\">of</span> cookieArr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p = _cookie.indexOf(<span class=\"string\">'='</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = _cookie.slice(<span class=\"number\">0</span>,p)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = _cookie.slice(p+<span class=\"number\">1</span>)</span><br><span class=\"line\">        value = <span class=\"built_in\">decodeURIComponent</span>(value)</span><br><span class=\"line\">        cookieObj[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cookieObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"cookie相关的存储\"><a href=\"#cookie相关的存储\" class=\"headerlink\" title=\"cookie相关的存储\"></a>cookie相关的存储</h4><p>实现类似于sessionStorage的getItem、setItem、remove、delete等功能<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cookieStorage(maxage, path) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//自执行函数实例化一个cookie对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cookie = <span class=\"function\">(<span class=\"params\">(</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cookieObj = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cookieStr = <span class=\"built_in\">document</span>.cookie</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cookieStr === <span class=\"string\">''</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cookieObj</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cookieArr = cookieStr.split(<span class=\"string\">'; '</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> _cookie <span class=\"keyword\">of</span> cookieArr)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> p = _cookie.indexOf(<span class=\"string\">'='</span>)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> name = _cookie.slice(<span class=\"number\">0</span>,p)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> value = _cookie.slice(p+<span class=\"number\">1</span>)</span><br><span class=\"line\">            value = <span class=\"built_in\">decodeURIComponent</span>(value)</span><br><span class=\"line\">            cookieObj[name] = value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cookieObj</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    <span class=\"comment\">// 拿出所有的key</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> keys = <span class=\"built_in\">Object</span>.keys(cookie)</span><br><span class=\"line\">    <span class=\"comment\">//存储API公共的属性和方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.length = keys.length</span><br><span class=\"line\">    <span class=\"comment\">//返回第n个key的名字，即key方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n&lt;<span class=\"number\">0</span> || n &gt;= keys.length) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keys[n]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//getItem方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getItem = <span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> cookie[name] || <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">// setItem方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setItem = <span class=\"function\">(<span class=\"params\">key,value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//首先判断要存储的cookie存在不,不存在先操作一次keys和length</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(key <span class=\"keyword\">in</span> keys))&#123;</span><br><span class=\"line\">            keys.push(key)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.length++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 针对cookie对象做的操作</span></span><br><span class=\"line\">        cookie[key] = value</span><br><span class=\"line\">        <span class=\"comment\">//接下来就是正式操作浏览器中的cookie</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> domCookie = <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;<span class=\"built_in\">encodeURIComponent</span>(value)&#125;</span>`</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(maxage) domCookie += <span class=\"string\">`; max-age=<span class=\"subst\">$&#123;maxage&#125;</span>`</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(path) domCookie += <span class=\"string\">`; path=<span class=\"subst\">$&#123;path&#125;</span>`</span></span><br><span class=\"line\">        <span class=\"built_in\">document</span>.cookie = domCookie</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// removeCookie</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.removeItem = <span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(key <span class=\"keyword\">in</span> cookie)) <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> cookie[key]</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.length--</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p = keys.indexOf(key)</span><br><span class=\"line\">        keys.splice(p,<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.cookie = </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// clear</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> keys)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.cookie = <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=; max-age=0`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cookie = &#123;&#125;</span><br><span class=\"line\">        keys = []</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"js继承","date":"2018-05-07T09:28:58.000Z","_content":"\n## 继承\njs一直在模仿其他oop语言的继承机制。但是本质上是一种代理，以下归纳了常见的实现继承的方法\n\n### 原型链 + new\n\n```js\nfunction Parent(){\n    this.colors = ['red','blue']\n\tthis.name = 'edguan'\n}\n\nParent.prototype.getName = function(){\n\tconsole.log(this.name)\n}\n\nfunction Child(age){\n\tthis.age = age\n}\n\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\nChild.prototype.getAge = function(){\n\tconsole.log(this.age)\n}\n\nlet child1 = new Child(25)\nlet child2 = new Child(26)\nchild1.colors.push('white')\nconsole.log(child1.colors)\nconsole.log(child2.colors)\n```\n缺点:\n1. 父类引用类型共享\n2. 创建子类型的实例的时候不能向父类设置传递参数，比如设置name\n\n### 借用构造函数\n\n```js\nfunction Parent(name){\n\tthis.name = name\n\tthis.color = [\"blue\",\"white\"]\n}\n\nParent.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Child(name, age){\n\tParent.call(this,name)\n\tthis.age = age\n}\n\nChild.prototype.getAge = function(){\n\treturn this.age\n}\n\nlet child1 = new Child('edguan',25)\nlet child2 = new Child('sandy',34)\nchild1.color.push(\"black\")\nchild2.color //[\"blue\",\"white\"] \nchild1.getName // undefined\n```\n缺点： 虽然可以传递参数了，引用类型不会共享，但是Father的原型中的方法(getName)在child中不可以被调用\n\n### 混合继承\n结合上面的2种思路\n\n```js\nfunction Parent(name){\n\tthis.color = [\"blue\",\"red\"]\n\tthis.name = name\n}\n\nParent.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Child(name,age){\n\tParent.call(this,name)\n\tthis.age = age\n}\n\nChild.prototype.getAge = function(){\n\treturn this.age\n}\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\nlet child1 = new Child(\"edguan\",25)\nlet child2 = new Child(\"sandy\",34)\n```\n\n缺点：new Parent()会产生Parent.prototype对象，并且会执行函数。函数内部可能有一些额外操作，这些是我们不需要的。\n\n### 原型式继承\n用Object.create代替new Parent()的方式，避免了一些risky\nnew实现Object.create的polyfill如下\nes6 的 Object.setPrototypeOf(obj1,obj2)作用相似\n```js\nconst create = (o) = > {\n\tlet func = function Func(){}\n\tFunc.prototype = o\n\treturn new Func()\n}\n```\n**但是Object.create可以接收第二个参数，但是不常用**\n\n```js\nfunction Parent(name){\n\tthis.color = [\"blue\",\"red\"]\n\tthis.name = name\n}\n\nParent.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Child(name,age){\n\tParent.call(this,name)\n\tthis.age = age\n}\n\nChild.prototype = Object.create(Parent.prototype)\nChild.prototype.constructor = Child\nChild.prototype.getAge = function(){\n\treturn this.age\n}\nlet child1 = new Child(\"edguan\",25)\nlet child2 = new Child(\"sandy\",34)\n```\n\n比较常见的方式\n\n### es6 class\n\n```js\nclass Parent{\n\tconstructor(name){\n\t\tthis.name = name;\n\t\tthis.color = [\"while\",\"red\"]\n\t}\n\tgetName(){\n\t\treturn this.name\n\t}\n\tstatic getColor(){\n\t\treturn this.color\n\t}\n\t_getColor(){\n\t\treturn this.color\n\t}\n}\n\n\nclass Child extends Parent{\n\tconstructor(name,age){\n\t\tsuper(name);\n\t\tthis.age = age\n\t}\n\n\tgetAge(){\n\t\treturn this.age\n\t}\n}\nlet child1 = new Child(\"edguan\",26)\nlet child2 = new Child(\"sandy\",34)\nchild1.color.push('blue')\n\n```\nclass 本质上就是基于prototype的语法糖。和之前原型式继承差别不大，就是写法上的区别，给人一种类生成对象的感觉。\n\n```js\ntypeof Child // \"function\"\nChild.prototype === child1.__proto__\n```\n\n","source":"_posts/js继承.md","raw":"---\ntitle: js继承\ndate: 2018-05-07 17:28:58\ntags: 点滴\ncategory: JavaScript\n---\n\n## 继承\njs一直在模仿其他oop语言的继承机制。但是本质上是一种代理，以下归纳了常见的实现继承的方法\n\n### 原型链 + new\n\n```js\nfunction Parent(){\n    this.colors = ['red','blue']\n\tthis.name = 'edguan'\n}\n\nParent.prototype.getName = function(){\n\tconsole.log(this.name)\n}\n\nfunction Child(age){\n\tthis.age = age\n}\n\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\nChild.prototype.getAge = function(){\n\tconsole.log(this.age)\n}\n\nlet child1 = new Child(25)\nlet child2 = new Child(26)\nchild1.colors.push('white')\nconsole.log(child1.colors)\nconsole.log(child2.colors)\n```\n缺点:\n1. 父类引用类型共享\n2. 创建子类型的实例的时候不能向父类设置传递参数，比如设置name\n\n### 借用构造函数\n\n```js\nfunction Parent(name){\n\tthis.name = name\n\tthis.color = [\"blue\",\"white\"]\n}\n\nParent.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Child(name, age){\n\tParent.call(this,name)\n\tthis.age = age\n}\n\nChild.prototype.getAge = function(){\n\treturn this.age\n}\n\nlet child1 = new Child('edguan',25)\nlet child2 = new Child('sandy',34)\nchild1.color.push(\"black\")\nchild2.color //[\"blue\",\"white\"] \nchild1.getName // undefined\n```\n缺点： 虽然可以传递参数了，引用类型不会共享，但是Father的原型中的方法(getName)在child中不可以被调用\n\n### 混合继承\n结合上面的2种思路\n\n```js\nfunction Parent(name){\n\tthis.color = [\"blue\",\"red\"]\n\tthis.name = name\n}\n\nParent.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Child(name,age){\n\tParent.call(this,name)\n\tthis.age = age\n}\n\nChild.prototype.getAge = function(){\n\treturn this.age\n}\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\nlet child1 = new Child(\"edguan\",25)\nlet child2 = new Child(\"sandy\",34)\n```\n\n缺点：new Parent()会产生Parent.prototype对象，并且会执行函数。函数内部可能有一些额外操作，这些是我们不需要的。\n\n### 原型式继承\n用Object.create代替new Parent()的方式，避免了一些risky\nnew实现Object.create的polyfill如下\nes6 的 Object.setPrototypeOf(obj1,obj2)作用相似\n```js\nconst create = (o) = > {\n\tlet func = function Func(){}\n\tFunc.prototype = o\n\treturn new Func()\n}\n```\n**但是Object.create可以接收第二个参数，但是不常用**\n\n```js\nfunction Parent(name){\n\tthis.color = [\"blue\",\"red\"]\n\tthis.name = name\n}\n\nParent.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Child(name,age){\n\tParent.call(this,name)\n\tthis.age = age\n}\n\nChild.prototype = Object.create(Parent.prototype)\nChild.prototype.constructor = Child\nChild.prototype.getAge = function(){\n\treturn this.age\n}\nlet child1 = new Child(\"edguan\",25)\nlet child2 = new Child(\"sandy\",34)\n```\n\n比较常见的方式\n\n### es6 class\n\n```js\nclass Parent{\n\tconstructor(name){\n\t\tthis.name = name;\n\t\tthis.color = [\"while\",\"red\"]\n\t}\n\tgetName(){\n\t\treturn this.name\n\t}\n\tstatic getColor(){\n\t\treturn this.color\n\t}\n\t_getColor(){\n\t\treturn this.color\n\t}\n}\n\n\nclass Child extends Parent{\n\tconstructor(name,age){\n\t\tsuper(name);\n\t\tthis.age = age\n\t}\n\n\tgetAge(){\n\t\treturn this.age\n\t}\n}\nlet child1 = new Child(\"edguan\",26)\nlet child2 = new Child(\"sandy\",34)\nchild1.color.push('blue')\n\n```\nclass 本质上就是基于prototype的语法糖。和之前原型式继承差别不大，就是写法上的区别，给人一种类生成对象的感觉。\n\n```js\ntypeof Child // \"function\"\nChild.prototype === child1.__proto__\n```\n\n","slug":"js继承","published":1,"updated":"2018-06-21T14:35:48.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvmc000nmsvml1nnmalh","content":"<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>js一直在模仿其他oop语言的继承机制。但是本质上是一种代理，以下归纳了常见的实现继承的方法</p>\n<h3 id=\"原型链-new\"><a href=\"#原型链-new\" class=\"headerlink\" title=\"原型链 + new\"></a>原型链 + new</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>,<span class=\"string\">'blue'</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = <span class=\"string\">'edguan'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">age</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"number\">25</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"number\">26</span>)</span><br><span class=\"line\">child1.colors.push(<span class=\"string\">'white'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.colors)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.colors)</span><br></pre></td></tr></table></figure>\n<p>缺点:</p>\n<ol>\n<li>父类引用类型共享</li>\n<li>创建子类型的实例的时候不能向父类设置传递参数，比如设置name</li>\n</ol>\n<h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = [<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"white\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">\tParent.call(<span class=\"keyword\">this</span>,name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'edguan'</span>,<span class=\"number\">25</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'sandy'</span>,<span class=\"number\">34</span>)</span><br><span class=\"line\">child1.color.push(<span class=\"string\">\"black\"</span>)</span><br><span class=\"line\">child2.color <span class=\"comment\">//[\"blue\",\"white\"] </span></span><br><span class=\"line\">child1.getName <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>缺点： 虽然可以传递参数了，引用类型不会共享，但是Father的原型中的方法(getName)在child中不可以被调用</p>\n<h3 id=\"混合继承\"><a href=\"#混合继承\" class=\"headerlink\" title=\"混合继承\"></a>混合继承</h3><p>结合上面的2种思路</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = [<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"red\"</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">\tParent.call(<span class=\"keyword\">this</span>,name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"edguan\"</span>,<span class=\"number\">25</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"sandy\"</span>,<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n<p>缺点：new Parent()会产生Parent.prototype对象，并且会执行函数。函数内部可能有一些额外操作，这些是我们不需要的。</p>\n<h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><p>用Object.create代替new Parent()的方式，避免了一些risky<br>new实现Object.create的polyfill如下<br>es6 的 Object.setPrototypeOf(obj1,obj2)作用相似<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> create = (o) = &gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> func = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Func</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">\tFunc.prototype = o</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Func()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>但是Object.create可以接收第二个参数，但是不常用</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = [<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"red\"</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">\tParent.call(<span class=\"keyword\">this</span>,name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"built_in\">Object</span>.create(Parent.prototype)</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"edguan\"</span>,<span class=\"number\">25</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"sandy\"</span>,<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n<p>比较常见的方式</p>\n<h3 id=\"es6-class\"><a href=\"#es6-class\" class=\"headerlink\" title=\"es6 class\"></a>es6 class</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.color = [<span class=\"string\">\"while\"</span>,<span class=\"string\">\"red\"</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetName()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> getColor()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_getColor()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(name,age)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetAge()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"edguan\"</span>,<span class=\"number\">26</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"sandy\"</span>,<span class=\"number\">34</span>)</span><br><span class=\"line\">child1.color.push(<span class=\"string\">'blue'</span>)</span><br></pre></td></tr></table></figure>\n<p>class 本质上就是基于prototype的语法糖。和之前原型式继承差别不大，就是写法上的区别，给人一种类生成对象的感觉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> Child <span class=\"comment\">// \"function\"</span></span><br><span class=\"line\">Child.prototype === child1.__proto__</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>js一直在模仿其他oop语言的继承机制。但是本质上是一种代理，以下归纳了常见的实现继承的方法</p>\n<h3 id=\"原型链-new\"><a href=\"#原型链-new\" class=\"headerlink\" title=\"原型链 + new\"></a>原型链 + new</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>,<span class=\"string\">'blue'</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = <span class=\"string\">'edguan'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">age</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"number\">25</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"number\">26</span>)</span><br><span class=\"line\">child1.colors.push(<span class=\"string\">'white'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.colors)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.colors)</span><br></pre></td></tr></table></figure>\n<p>缺点:</p>\n<ol>\n<li>父类引用类型共享</li>\n<li>创建子类型的实例的时候不能向父类设置传递参数，比如设置name</li>\n</ol>\n<h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = [<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"white\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">\tParent.call(<span class=\"keyword\">this</span>,name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'edguan'</span>,<span class=\"number\">25</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'sandy'</span>,<span class=\"number\">34</span>)</span><br><span class=\"line\">child1.color.push(<span class=\"string\">\"black\"</span>)</span><br><span class=\"line\">child2.color <span class=\"comment\">//[\"blue\",\"white\"] </span></span><br><span class=\"line\">child1.getName <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>缺点： 虽然可以传递参数了，引用类型不会共享，但是Father的原型中的方法(getName)在child中不可以被调用</p>\n<h3 id=\"混合继承\"><a href=\"#混合继承\" class=\"headerlink\" title=\"混合继承\"></a>混合继承</h3><p>结合上面的2种思路</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = [<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"red\"</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">\tParent.call(<span class=\"keyword\">this</span>,name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"edguan\"</span>,<span class=\"number\">25</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"sandy\"</span>,<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n<p>缺点：new Parent()会产生Parent.prototype对象，并且会执行函数。函数内部可能有一些额外操作，这些是我们不需要的。</p>\n<h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><p>用Object.create代替new Parent()的方式，避免了一些risky<br>new实现Object.create的polyfill如下<br>es6 的 Object.setPrototypeOf(obj1,obj2)作用相似<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> create = (o) = &gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> func = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Func</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">\tFunc.prototype = o</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Func()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>但是Object.create可以接收第二个参数，但是不常用</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.color = [<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"red\"</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">\tParent.call(<span class=\"keyword\">this</span>,name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"built_in\">Object</span>.create(Parent.prototype)</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"edguan\"</span>,<span class=\"number\">25</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"sandy\"</span>,<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n<p>比较常见的方式</p>\n<h3 id=\"es6-class\"><a href=\"#es6-class\" class=\"headerlink\" title=\"es6 class\"></a>es6 class</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.color = [<span class=\"string\">\"while\"</span>,<span class=\"string\">\"red\"</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetName()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> getColor()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_getColor()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(name,age)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetAge()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"edguan\"</span>,<span class=\"number\">26</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"sandy\"</span>,<span class=\"number\">34</span>)</span><br><span class=\"line\">child1.color.push(<span class=\"string\">'blue'</span>)</span><br></pre></td></tr></table></figure>\n<p>class 本质上就是基于prototype的语法糖。和之前原型式继承差别不大，就是写法上的区别，给人一种类生成对象的感觉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> Child <span class=\"comment\">// \"function\"</span></span><br><span class=\"line\">Child.prototype === child1.__proto__</span><br></pre></td></tr></table></figure>\n"},{"title":"你不知道的Javascript上卷——上","date":"2018-03-26T06:28:08.000Z","_content":"## 概述\n一直都想好好读一下这本书，很多同行安利过了。每次都是读一点都读不下去，最近很仔细的品读了一下，真的非常棒，读完之后受益匪浅。\n这次的读书笔记是读完本书上卷的前半部分——作用域和闭包之后写的。\n\n#### 作用域是什么\n一言以蔽之，作用域是一套完整的变量存储的规则。\n变量存在哪里，怎么找到这个变量，都是这套规则决定的。\n\n##### 编译原理\n最初学习js的时候就会说js是一门解释性的语言，事实上他是编译语言，但是又和传统的编译语言不一样，比如JAVA，打个war包或者编译成class文件，js并不是提前编译的，编译的结果也不能在分布式系统中进行移植。\n对于传统的语言，代码执行之前有3个步骤，分词/词法分析 => 解析/语法分析 => 代码生成\n\n##### 理解作用域\n引擎：从头到尾负责整个js的编译和执行过程\n\n编译器： 引擎的好朋友，负责语法分析和代码生成\n\n作用域：收集和维护所有的变量组成一系列查询和一套严格的规则。\n\n#### 词法作用域\n词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块级作用域写在哪里来决定的。欺骗词法，eval和with，对性能会有影响。\n\n#### 函数作用域和块作用域\n函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。\n \n块作用域：IIFE，let，const，try\n\n**变量提升中函数优先**\n\n#### 闭包\n闭包是基于词法作用域书写产生的自然结果。函数在定义时的词法作用域以外的地方被调用，闭包可以让函数继续访问定义时的词法作用域。\n\n```javascript\n\nfunction wait(msg){\n    setTimeout(function timer(){\n        console.log(msg)\n    },1000)\n}\n\nwait('hello closure')\n```\n将内部函数（timer）传递给setTimeout，timer具有覆盖wait的作用域，\nwait执行1000ms后，他的作用域不会消失，timer依然保持对wait作用域的闭包\n\n##### 循环和闭包\n经典面试题\n```js\nfor(var i = 0;i<5; i++){\n\tsetTimeout(function(){\n\t\tconsole.log(i)\n\t},i*2000)\n}\n```\n首先 setTimeout中的回调会在循环之后执行\nvar 没有块作用域，所有的i都在全局作用域，最后打印的只能是5\n\n可以采用IIFE和let\n\n```js\nfor(let i = 0;i<5; i++){\n\tsetTimeout(function(){\n\t\tconsole.log(i)\n\t},i*2000)\n}\n```\n\n```js\nfor(var i = 0;i<5; i++){\n\t((i)=>{\n\t\tsetTimeout(function(){\n\t\tconsole.log(i)\n\t},i*2000)\n\t})(i)\n}\n```\n\n## 小结\n书中有很多原理性知识的讲解，但是不想浪费时间去截取了。直接看书就很好啦。","source":"_posts/你不知道的Javascript上卷——上.md","raw":"---\ntitle: 你不知道的Javascript上卷——上\ndate: 2018-03-26 14:28:08\ntags: 读书笔记\ncategory: 读书笔记\n---\n## 概述\n一直都想好好读一下这本书，很多同行安利过了。每次都是读一点都读不下去，最近很仔细的品读了一下，真的非常棒，读完之后受益匪浅。\n这次的读书笔记是读完本书上卷的前半部分——作用域和闭包之后写的。\n\n#### 作用域是什么\n一言以蔽之，作用域是一套完整的变量存储的规则。\n变量存在哪里，怎么找到这个变量，都是这套规则决定的。\n\n##### 编译原理\n最初学习js的时候就会说js是一门解释性的语言，事实上他是编译语言，但是又和传统的编译语言不一样，比如JAVA，打个war包或者编译成class文件，js并不是提前编译的，编译的结果也不能在分布式系统中进行移植。\n对于传统的语言，代码执行之前有3个步骤，分词/词法分析 => 解析/语法分析 => 代码生成\n\n##### 理解作用域\n引擎：从头到尾负责整个js的编译和执行过程\n\n编译器： 引擎的好朋友，负责语法分析和代码生成\n\n作用域：收集和维护所有的变量组成一系列查询和一套严格的规则。\n\n#### 词法作用域\n词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块级作用域写在哪里来决定的。欺骗词法，eval和with，对性能会有影响。\n\n#### 函数作用域和块作用域\n函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。\n \n块作用域：IIFE，let，const，try\n\n**变量提升中函数优先**\n\n#### 闭包\n闭包是基于词法作用域书写产生的自然结果。函数在定义时的词法作用域以外的地方被调用，闭包可以让函数继续访问定义时的词法作用域。\n\n```javascript\n\nfunction wait(msg){\n    setTimeout(function timer(){\n        console.log(msg)\n    },1000)\n}\n\nwait('hello closure')\n```\n将内部函数（timer）传递给setTimeout，timer具有覆盖wait的作用域，\nwait执行1000ms后，他的作用域不会消失，timer依然保持对wait作用域的闭包\n\n##### 循环和闭包\n经典面试题\n```js\nfor(var i = 0;i<5; i++){\n\tsetTimeout(function(){\n\t\tconsole.log(i)\n\t},i*2000)\n}\n```\n首先 setTimeout中的回调会在循环之后执行\nvar 没有块作用域，所有的i都在全局作用域，最后打印的只能是5\n\n可以采用IIFE和let\n\n```js\nfor(let i = 0;i<5; i++){\n\tsetTimeout(function(){\n\t\tconsole.log(i)\n\t},i*2000)\n}\n```\n\n```js\nfor(var i = 0;i<5; i++){\n\t((i)=>{\n\t\tsetTimeout(function(){\n\t\tconsole.log(i)\n\t},i*2000)\n\t})(i)\n}\n```\n\n## 小结\n书中有很多原理性知识的讲解，但是不想浪费时间去截取了。直接看书就很好啦。","slug":"你不知道的Javascript上卷——上","published":1,"updated":"2018-06-21T14:30:10.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvme000pmsvmflifjg5y","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>一直都想好好读一下这本书，很多同行安利过了。每次都是读一点都读不下去，最近很仔细的品读了一下，真的非常棒，读完之后受益匪浅。<br>这次的读书笔记是读完本书上卷的前半部分——作用域和闭包之后写的。</p>\n<h4 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h4><p>一言以蔽之，作用域是一套完整的变量存储的规则。<br>变量存在哪里，怎么找到这个变量，都是这套规则决定的。</p>\n<h5 id=\"编译原理\"><a href=\"#编译原理\" class=\"headerlink\" title=\"编译原理\"></a>编译原理</h5><p>最初学习js的时候就会说js是一门解释性的语言，事实上他是编译语言，但是又和传统的编译语言不一样，比如JAVA，打个war包或者编译成class文件，js并不是提前编译的，编译的结果也不能在分布式系统中进行移植。<br>对于传统的语言，代码执行之前有3个步骤，分词/词法分析 =&gt; 解析/语法分析 =&gt; 代码生成</p>\n<h5 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h5><p>引擎：从头到尾负责整个js的编译和执行过程</p>\n<p>编译器： 引擎的好朋友，负责语法分析和代码生成</p>\n<p>作用域：收集和维护所有的变量组成一系列查询和一套严格的规则。</p>\n<h4 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h4><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块级作用域写在哪里来决定的。欺骗词法，eval和with，对性能会有影响。</p>\n<h4 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h4><p>函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。</p>\n<p>块作用域：IIFE，let，const，try</p>\n<p><strong>变量提升中函数优先</strong></p>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>闭包是基于词法作用域书写产生的自然结果。函数在定义时的词法作用域以外的地方被调用，闭包可以让函数继续访问定义时的词法作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(msg)</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wait(<span class=\"string\">'hello closure'</span>)</span><br></pre></td></tr></table></figure>\n<p>将内部函数（timer）传递给setTimeout，timer具有覆盖wait的作用域，<br>wait执行1000ms后，他的作用域不会消失，timer依然保持对wait作用域的闭包</p>\n<h5 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h5><p>经典面试题<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">\t&#125;,i*<span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先 setTimeout中的回调会在循环之后执行<br>var 没有块作用域，所有的i都在全局作用域，最后打印的只能是5</p>\n<p>可以采用IIFE和let</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">\t&#125;,i*<span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\t(<span class=\"function\">(<span class=\"params\">i</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">\t&#125;,i*<span class=\"number\">2000</span>)</span><br><span class=\"line\">\t&#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>书中有很多原理性知识的讲解，但是不想浪费时间去截取了。直接看书就很好啦。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>一直都想好好读一下这本书，很多同行安利过了。每次都是读一点都读不下去，最近很仔细的品读了一下，真的非常棒，读完之后受益匪浅。<br>这次的读书笔记是读完本书上卷的前半部分——作用域和闭包之后写的。</p>\n<h4 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h4><p>一言以蔽之，作用域是一套完整的变量存储的规则。<br>变量存在哪里，怎么找到这个变量，都是这套规则决定的。</p>\n<h5 id=\"编译原理\"><a href=\"#编译原理\" class=\"headerlink\" title=\"编译原理\"></a>编译原理</h5><p>最初学习js的时候就会说js是一门解释性的语言，事实上他是编译语言，但是又和传统的编译语言不一样，比如JAVA，打个war包或者编译成class文件，js并不是提前编译的，编译的结果也不能在分布式系统中进行移植。<br>对于传统的语言，代码执行之前有3个步骤，分词/词法分析 =&gt; 解析/语法分析 =&gt; 代码生成</p>\n<h5 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h5><p>引擎：从头到尾负责整个js的编译和执行过程</p>\n<p>编译器： 引擎的好朋友，负责语法分析和代码生成</p>\n<p>作用域：收集和维护所有的变量组成一系列查询和一套严格的规则。</p>\n<h4 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h4><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块级作用域写在哪里来决定的。欺骗词法，eval和with，对性能会有影响。</p>\n<h4 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h4><p>函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。</p>\n<p>块作用域：IIFE，let，const，try</p>\n<p><strong>变量提升中函数优先</strong></p>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>闭包是基于词法作用域书写产生的自然结果。函数在定义时的词法作用域以外的地方被调用，闭包可以让函数继续访问定义时的词法作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(msg)</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wait(<span class=\"string\">'hello closure'</span>)</span><br></pre></td></tr></table></figure>\n<p>将内部函数（timer）传递给setTimeout，timer具有覆盖wait的作用域，<br>wait执行1000ms后，他的作用域不会消失，timer依然保持对wait作用域的闭包</p>\n<h5 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h5><p>经典面试题<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">\t&#125;,i*<span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先 setTimeout中的回调会在循环之后执行<br>var 没有块作用域，所有的i都在全局作用域，最后打印的只能是5</p>\n<p>可以采用IIFE和let</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">\t&#125;,i*<span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\t(<span class=\"function\">(<span class=\"params\">i</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">\t&#125;,i*<span class=\"number\">2000</span>)</span><br><span class=\"line\">\t&#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>书中有很多原理性知识的讲解，但是不想浪费时间去截取了。直接看书就很好啦。</p>\n"},{"title":"你不知道的Javascript上卷——下","date":"2018-04-26T07:31:20.000Z","_content":"看了一个月，全书终于看完了，上下分别是关于作用域与闭包，this。而最后一部分是关于原型链的，这部分看了很久，很多地方理解都没到点上，所以一直没写。这次尝试写一下。\n\n## 概述\n本文主要分为2部分，一部分是对象，一部分是原型。对象这个章节讲了一些平时见怪不怪但是一直不知其所以然的tips。\n\n### 对象\n\n### 内置对象\n内置对象可以理解为内置的函数，加上new 操作后，作为构造函数使用，创建一个对应子类型的新对象。\n```js\nlet str = \"i am a string\"\ntypeof str // \"string\"\nstr instanceof String // false\n\nlet _str = new String('i am a string two')\ntypeof _str // \"object\"\nstr instanceof String // true\n```\nstr 是一个变量，\"i am a string\"是一个字面量，不是对象。如果对这个字面量做一些操作，比如获取长度等，需要转成String 对象。必要的时候语言会自动转成对象。\n\nnull和undefined没有构造形式，他们也不是内置对象\n\n### 属性描述符\nes5以后所有的属性都具备了属性描述符\n```js\nvar obj = {\n\ta:'a'\n}\n\nObject.getOwnPropertyDescriptor(obj,\"a\") // {value: \"a\", writable: true, enumerable: true, configurable: true}\n```\n\n* writable: 是否可以修改值\n* enumrable：是否可以被遍历中被找到\n* configuarable： 是否可以用defineProperty配置属性。configuable为false的时候会阻止delete这个属性\n\n### 不变性\n1. 对象常量\n```js\nvar obj = {}\nObject.defineProperty(obj, \"a\",{\n\tvalue: 'aaa',\n\tconfigurable: false,\n\twriteable: false\n})\n```\n\n2. 禁止扩展\n```js\nvar obj = {\n    a: \"aaa\"\n}\nObject.preventExtensions(obj) // 阻止扩展，但是a还是writeable\n```\n\n3. 密封\n\nObject.seal(..)会创建一个密封的对象，这个方法的本质就是调用preventExtensions方法并且在所有的属性设置为configurable：false。\n所以密封不仅不能添加属性，也不能重新配置。但是可以修改属性的值\n\n4. 冻结\n\nObject.freeze(..)会创建一个冻结对象。调用了Object.seal()并且设置writable为false。当然，利用递归也可以进行深度冻结。\n\n### [[Get]] and [[Put]]\n\n访问属性有一个很微妙的细节，我一直的理解是obj.a,是在obj这个对象中寻找名字为a的属性，实际上这里面有一个内部实现的[[get]]操作。\n默认的[get]操作就是查找是否有与名称相同的属性，如果没有并且在原型链上也没有找到找到就会返回undefined。\n**注意：这里和访问变量是不一样的**，属性访问找不到会报异常。\n\n### Getter和Setter\n\n```js\nvar myObj = {\n    get a(){\n        return 2\n    }\n}\n\nObject.definePropery(myObj,'b',{\n    get: function(){\n        return this.a * 2\n    },\n    enumerable: true // 确保b穿现在属性列表中\n})\n```\n这里执行 myObj.a = 3,myObj.a依旧还是2.因为自身定义的getter只能返回2.所有set没意义。\n\n为了更加合理\n```js\nvar obj = {\n    get a(){\n        return this._a_\n    }\n\n    set a(a){\n        this._a_ = value*2\n    }\n}\n\nobj.a = 2\nobj.a // 4\n```\n\n## 原型\n\n### 类函数\n\n```js\nfunction Foo(){\n    this.a = 1\n}\n\nlet a = new Foo()\na.__proto__ === Foo.prototype // true\n```\n首先必须明白几个概念 **Foo的原型**： Foo.prototype.\n回顾一下new操作符干了什么\n1. 新建一个对象\n2. this指向\n3. 建立prototype连接：将新建对象的[[prototype]]指向 Foo.prototype\n4. 返回新对象\n\nJavascript的原型继承可以并不会复制对象属性，只是会在2个对象之间建立关联，这样一个对象就可以**委托**访问另一个对象的属性和方法。\n\n### 原型继承\n```js\nfunction Foo(name){\n\tthis.name = name\n}\n\nFoo.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Bar(name,age){\n\tFoo.call(this, name)\n\tthis.age = age\n}\n\nBar.prototype = Object.create(Foo.prototype)\n\nBar.prototype.getAge = function(){\n\treturn this.age\n}\n\nlet bar = new Bar('edguan', 25)\n```\nObject.create会创建一个新对象，并将新对象的[[prototype]]关联到指定的对象。","source":"_posts/你不知道的Javascript上卷——下.md","raw":"---\ntitle: 你不知道的Javascript上卷——下\ndate: 2018-04-26 15:31:20\ntags: 读书笔记\ncategory: 读书笔记\n---\n看了一个月，全书终于看完了，上下分别是关于作用域与闭包，this。而最后一部分是关于原型链的，这部分看了很久，很多地方理解都没到点上，所以一直没写。这次尝试写一下。\n\n## 概述\n本文主要分为2部分，一部分是对象，一部分是原型。对象这个章节讲了一些平时见怪不怪但是一直不知其所以然的tips。\n\n### 对象\n\n### 内置对象\n内置对象可以理解为内置的函数，加上new 操作后，作为构造函数使用，创建一个对应子类型的新对象。\n```js\nlet str = \"i am a string\"\ntypeof str // \"string\"\nstr instanceof String // false\n\nlet _str = new String('i am a string two')\ntypeof _str // \"object\"\nstr instanceof String // true\n```\nstr 是一个变量，\"i am a string\"是一个字面量，不是对象。如果对这个字面量做一些操作，比如获取长度等，需要转成String 对象。必要的时候语言会自动转成对象。\n\nnull和undefined没有构造形式，他们也不是内置对象\n\n### 属性描述符\nes5以后所有的属性都具备了属性描述符\n```js\nvar obj = {\n\ta:'a'\n}\n\nObject.getOwnPropertyDescriptor(obj,\"a\") // {value: \"a\", writable: true, enumerable: true, configurable: true}\n```\n\n* writable: 是否可以修改值\n* enumrable：是否可以被遍历中被找到\n* configuarable： 是否可以用defineProperty配置属性。configuable为false的时候会阻止delete这个属性\n\n### 不变性\n1. 对象常量\n```js\nvar obj = {}\nObject.defineProperty(obj, \"a\",{\n\tvalue: 'aaa',\n\tconfigurable: false,\n\twriteable: false\n})\n```\n\n2. 禁止扩展\n```js\nvar obj = {\n    a: \"aaa\"\n}\nObject.preventExtensions(obj) // 阻止扩展，但是a还是writeable\n```\n\n3. 密封\n\nObject.seal(..)会创建一个密封的对象，这个方法的本质就是调用preventExtensions方法并且在所有的属性设置为configurable：false。\n所以密封不仅不能添加属性，也不能重新配置。但是可以修改属性的值\n\n4. 冻结\n\nObject.freeze(..)会创建一个冻结对象。调用了Object.seal()并且设置writable为false。当然，利用递归也可以进行深度冻结。\n\n### [[Get]] and [[Put]]\n\n访问属性有一个很微妙的细节，我一直的理解是obj.a,是在obj这个对象中寻找名字为a的属性，实际上这里面有一个内部实现的[[get]]操作。\n默认的[get]操作就是查找是否有与名称相同的属性，如果没有并且在原型链上也没有找到找到就会返回undefined。\n**注意：这里和访问变量是不一样的**，属性访问找不到会报异常。\n\n### Getter和Setter\n\n```js\nvar myObj = {\n    get a(){\n        return 2\n    }\n}\n\nObject.definePropery(myObj,'b',{\n    get: function(){\n        return this.a * 2\n    },\n    enumerable: true // 确保b穿现在属性列表中\n})\n```\n这里执行 myObj.a = 3,myObj.a依旧还是2.因为自身定义的getter只能返回2.所有set没意义。\n\n为了更加合理\n```js\nvar obj = {\n    get a(){\n        return this._a_\n    }\n\n    set a(a){\n        this._a_ = value*2\n    }\n}\n\nobj.a = 2\nobj.a // 4\n```\n\n## 原型\n\n### 类函数\n\n```js\nfunction Foo(){\n    this.a = 1\n}\n\nlet a = new Foo()\na.__proto__ === Foo.prototype // true\n```\n首先必须明白几个概念 **Foo的原型**： Foo.prototype.\n回顾一下new操作符干了什么\n1. 新建一个对象\n2. this指向\n3. 建立prototype连接：将新建对象的[[prototype]]指向 Foo.prototype\n4. 返回新对象\n\nJavascript的原型继承可以并不会复制对象属性，只是会在2个对象之间建立关联，这样一个对象就可以**委托**访问另一个对象的属性和方法。\n\n### 原型继承\n```js\nfunction Foo(name){\n\tthis.name = name\n}\n\nFoo.prototype.getName = function(){\n\treturn this.name\n}\n\nfunction Bar(name,age){\n\tFoo.call(this, name)\n\tthis.age = age\n}\n\nBar.prototype = Object.create(Foo.prototype)\n\nBar.prototype.getAge = function(){\n\treturn this.age\n}\n\nlet bar = new Bar('edguan', 25)\n```\nObject.create会创建一个新对象，并将新对象的[[prototype]]关联到指定的对象。","slug":"你不知道的Javascript上卷——下","published":1,"updated":"2018-06-12T16:14:07.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvmg000umsvm7ij002hj","content":"<p>看了一个月，全书终于看完了，上下分别是关于作用域与闭包，this。而最后一部分是关于原型链的，这部分看了很久，很多地方理解都没到点上，所以一直没写。这次尝试写一下。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文主要分为2部分，一部分是对象，一部分是原型。对象这个章节讲了一些平时见怪不怪但是一直不知其所以然的tips。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><h3 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h3><p>内置对象可以理解为内置的函数，加上new 操作后，作为构造函数使用，创建一个对应子类型的新对象。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"i am a string\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> str <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\">str <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'i am a string two'</span>)</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> _str <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\">str <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>str 是一个变量，”i am a string”是一个字面量，不是对象。如果对这个字面量做一些操作，比如获取长度等，需要转成String 对象。必要的时候语言会自动转成对象。</p>\n<p>null和undefined没有构造形式，他们也不是内置对象</p>\n<h3 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h3><p>es5以后所有的属性都具备了属性描述符<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\ta:<span class=\"string\">'a'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj,<span class=\"string\">\"a\"</span>) <span class=\"comment\">// &#123;value: \"a\", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>writable: 是否可以修改值</li>\n<li>enumrable：是否可以被遍历中被找到</li>\n<li>configuarable： 是否可以用defineProperty配置属性。configuable为false的时候会阻止delete这个属性</li>\n</ul>\n<h3 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h3><ol>\n<li><p>对象常量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">\"a\"</span>,&#123;</span><br><span class=\"line\">\tvalue: <span class=\"string\">'aaa'</span>,</span><br><span class=\"line\">\tconfigurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\twriteable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>禁止扩展</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">\"aaa\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(obj) <span class=\"comment\">// 阻止扩展，但是a还是writeable</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>密封</p>\n</li>\n</ol>\n<p>Object.seal(..)会创建一个密封的对象，这个方法的本质就是调用preventExtensions方法并且在所有的属性设置为configurable：false。<br>所以密封不仅不能添加属性，也不能重新配置。但是可以修改属性的值</p>\n<ol>\n<li>冻结</li>\n</ol>\n<p>Object.freeze(..)会创建一个冻结对象。调用了Object.seal()并且设置writable为false。当然，利用递归也可以进行深度冻结。</p>\n<h3 id=\"Get-and-Put\"><a href=\"#Get-and-Put\" class=\"headerlink\" title=\"[[Get]] and [[Put]]\"></a>[[Get]] and [[Put]]</h3><p>访问属性有一个很微妙的细节，我一直的理解是obj.a,是在obj这个对象中寻找名字为a的属性，实际上这里面有一个内部实现的[[get]]操作。<br>默认的[get]操作就是查找是否有与名称相同的属性，如果没有并且在原型链上也没有找到找到就会返回undefined。<br><strong>注意：这里和访问变量是不一样的</strong>，属性访问找不到会报异常。</p>\n<h3 id=\"Getter和Setter\"><a href=\"#Getter和Setter\" class=\"headerlink\" title=\"Getter和Setter\"></a>Getter和Setter</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    get a()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.definePropery(myObj,<span class=\"string\">'b'</span>,&#123;</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span> <span class=\"comment\">// 确保b穿现在属性列表中</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里执行 myObj.a = 3,myObj.a依旧还是2.因为自身定义的getter只能返回2.所有set没意义。</p>\n<p>为了更加合理<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    get a()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._a_</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    set a(a)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._a_ = value*<span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.a = <span class=\"number\">2</span></span><br><span class=\"line\">obj.a <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"类函数\"><a href=\"#类函数\" class=\"headerlink\" title=\"类函数\"></a>类函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Foo()</span><br><span class=\"line\">a.__proto__ === Foo.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>首先必须明白几个概念 <strong>Foo的原型</strong>： Foo.prototype.<br>回顾一下new操作符干了什么</p>\n<ol>\n<li>新建一个对象</li>\n<li>this指向</li>\n<li>建立prototype连接：将新建对象的[[prototype]]指向 Foo.prototype</li>\n<li>返回新对象</li>\n</ol>\n<p>Javascript的原型继承可以并不会复制对象属性，只是会在2个对象之间建立关联，这样一个对象就可以<strong>委托</strong>访问另一个对象的属性和方法。</p>\n<h3 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">\tFoo.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create(Foo.prototype)</span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">new</span> Bar(<span class=\"string\">'edguan'</span>, <span class=\"number\">25</span>)</span><br></pre></td></tr></table></figure>\n<p>Object.create会创建一个新对象，并将新对象的[[prototype]]关联到指定的对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>看了一个月，全书终于看完了，上下分别是关于作用域与闭包，this。而最后一部分是关于原型链的，这部分看了很久，很多地方理解都没到点上，所以一直没写。这次尝试写一下。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文主要分为2部分，一部分是对象，一部分是原型。对象这个章节讲了一些平时见怪不怪但是一直不知其所以然的tips。</p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><h3 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h3><p>内置对象可以理解为内置的函数，加上new 操作后，作为构造函数使用，创建一个对应子类型的新对象。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"i am a string\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> str <span class=\"comment\">// \"string\"</span></span><br><span class=\"line\">str <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'i am a string two'</span>)</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> _str <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\">str <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>str 是一个变量，”i am a string”是一个字面量，不是对象。如果对这个字面量做一些操作，比如获取长度等，需要转成String 对象。必要的时候语言会自动转成对象。</p>\n<p>null和undefined没有构造形式，他们也不是内置对象</p>\n<h3 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h3><p>es5以后所有的属性都具备了属性描述符<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\ta:<span class=\"string\">'a'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj,<span class=\"string\">\"a\"</span>) <span class=\"comment\">// &#123;value: \"a\", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>writable: 是否可以修改值</li>\n<li>enumrable：是否可以被遍历中被找到</li>\n<li>configuarable： 是否可以用defineProperty配置属性。configuable为false的时候会阻止delete这个属性</li>\n</ul>\n<h3 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h3><ol>\n<li><p>对象常量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">\"a\"</span>,&#123;</span><br><span class=\"line\">\tvalue: <span class=\"string\">'aaa'</span>,</span><br><span class=\"line\">\tconfigurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\twriteable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>禁止扩展</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">\"aaa\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(obj) <span class=\"comment\">// 阻止扩展，但是a还是writeable</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>密封</p>\n</li>\n</ol>\n<p>Object.seal(..)会创建一个密封的对象，这个方法的本质就是调用preventExtensions方法并且在所有的属性设置为configurable：false。<br>所以密封不仅不能添加属性，也不能重新配置。但是可以修改属性的值</p>\n<ol>\n<li>冻结</li>\n</ol>\n<p>Object.freeze(..)会创建一个冻结对象。调用了Object.seal()并且设置writable为false。当然，利用递归也可以进行深度冻结。</p>\n<h3 id=\"Get-and-Put\"><a href=\"#Get-and-Put\" class=\"headerlink\" title=\"[[Get]] and [[Put]]\"></a>[[Get]] and [[Put]]</h3><p>访问属性有一个很微妙的细节，我一直的理解是obj.a,是在obj这个对象中寻找名字为a的属性，实际上这里面有一个内部实现的[[get]]操作。<br>默认的[get]操作就是查找是否有与名称相同的属性，如果没有并且在原型链上也没有找到找到就会返回undefined。<br><strong>注意：这里和访问变量是不一样的</strong>，属性访问找不到会报异常。</p>\n<h3 id=\"Getter和Setter\"><a href=\"#Getter和Setter\" class=\"headerlink\" title=\"Getter和Setter\"></a>Getter和Setter</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">    get a()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.definePropery(myObj,<span class=\"string\">'b'</span>,&#123;</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span> <span class=\"comment\">// 确保b穿现在属性列表中</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里执行 myObj.a = 3,myObj.a依旧还是2.因为自身定义的getter只能返回2.所有set没意义。</p>\n<p>为了更加合理<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    get a()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._a_</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    set a(a)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._a_ = value*<span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.a = <span class=\"number\">2</span></span><br><span class=\"line\">obj.a <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"类函数\"><a href=\"#类函数\" class=\"headerlink\" title=\"类函数\"></a>类函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Foo()</span><br><span class=\"line\">a.__proto__ === Foo.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>首先必须明白几个概念 <strong>Foo的原型</strong>： Foo.prototype.<br>回顾一下new操作符干了什么</p>\n<ol>\n<li>新建一个对象</li>\n<li>this指向</li>\n<li>建立prototype连接：将新建对象的[[prototype]]指向 Foo.prototype</li>\n<li>返回新对象</li>\n</ol>\n<p>Javascript的原型继承可以并不会复制对象属性，只是会在2个对象之间建立关联，这样一个对象就可以<strong>委托</strong>访问另一个对象的属性和方法。</p>\n<h3 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">\tFoo.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype = <span class=\"built_in\">Object</span>.create(Foo.prototype)</span><br><span class=\"line\"></span><br><span class=\"line\">Bar.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">new</span> Bar(<span class=\"string\">'edguan'</span>, <span class=\"number\">25</span>)</span><br></pre></td></tr></table></figure>\n<p>Object.create会创建一个新对象，并将新对象的[[prototype]]关联到指定的对象。</p>\n"},{"title":"指令集","date":"2018-05-16T16:01:11.000Z","_content":"## 常用指令\n\n### 防火墙\n* 查看已经开放的端口：firewall-cmd --list-ports\n* 开启端口： firewall-cmd --zone=public --add-port=80/tcp --permanent\n>命令含义：\n\n> –zone #作用域\n\n> –add-port=80/tcp #添加端口，格式为：端口/通讯协议\n\n> –permanent #永久生效，没有此参数重启后失效\n\n* 重启防火墙\n\n> firewall-cmd --reload #重启firewall\n> systemctl stop firewalld.service #停止firewall\n> systemctl disable firewalld.service #禁止firewall开机启动\n> firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）\n\n### \b数据库\n\n* 切换数据库：use mysql\n* 显示所有的表：show tables;\n* 刷新权限： flush privileges\n\b* root用户登陆系统：mysql -u root -p mysql\n\n### nginx\n* 解决SPA刷新404的方案： try_files $uri /index.html;\n* nginx重启：service nginx restart\n\n### pm2\n* 支持es6： pm2 start ** --node-args=\"harmony\"","source":"_posts/指令集.md","raw":"---\ntitle: 指令集\ndate: 2018-05-17 00:01:11\ntags: 点滴\ncategory: JavaScript\n---\n## 常用指令\n\n### 防火墙\n* 查看已经开放的端口：firewall-cmd --list-ports\n* 开启端口： firewall-cmd --zone=public --add-port=80/tcp --permanent\n>命令含义：\n\n> –zone #作用域\n\n> –add-port=80/tcp #添加端口，格式为：端口/通讯协议\n\n> –permanent #永久生效，没有此参数重启后失效\n\n* 重启防火墙\n\n> firewall-cmd --reload #重启firewall\n> systemctl stop firewalld.service #停止firewall\n> systemctl disable firewalld.service #禁止firewall开机启动\n> firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）\n\n### \b数据库\n\n* 切换数据库：use mysql\n* 显示所有的表：show tables;\n* 刷新权限： flush privileges\n\b* root用户登陆系统：mysql -u root -p mysql\n\n### nginx\n* 解决SPA刷新404的方案： try_files $uri /index.html;\n* nginx重启：service nginx restart\n\n### pm2\n* 支持es6： pm2 start ** --node-args=\"harmony\"","slug":"指令集","published":1,"updated":"2018-06-24T14:30:56.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvmh000wmsvmrjtvgc7w","content":"<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><h3 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h3><ul>\n<li>查看已经开放的端口：firewall-cmd –list-ports</li>\n<li>开启端口： firewall-cmd –zone=public –add-port=80/tcp –permanent<blockquote>\n<p>命令含义：</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>–zone #作用域</p>\n</blockquote>\n<blockquote>\n<p>–add-port=80/tcp #添加端口，格式为：端口/通讯协议</p>\n</blockquote>\n<blockquote>\n<p>–permanent #永久生效，没有此参数重启后失效</p>\n</blockquote>\n<ul>\n<li>重启防火墙</li>\n</ul>\n<blockquote>\n<p>firewall-cmd –reload #重启firewall<br>systemctl stop firewalld.service #停止firewall<br>systemctl disable firewalld.service #禁止firewall开机启动<br>firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</p>\n</blockquote>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"\b数据库\"></a>\b数据库</h3><ul>\n<li>切换数据库：use mysql</li>\n<li>显示所有的表：show tables;</li>\n<li>刷新权限： flush privileges<br>\b* root用户登陆系统：mysql -u root -p mysql</li>\n</ul>\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ul>\n<li>解决SPA刷新404的方案： try_files $uri /index.html;</li>\n<li>nginx重启：service nginx restart</li>\n</ul>\n<h3 id=\"pm2\"><a href=\"#pm2\" class=\"headerlink\" title=\"pm2\"></a>pm2</h3><ul>\n<li>支持es6： pm2 start ** –node-args=”harmony”</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><h3 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h3><ul>\n<li>查看已经开放的端口：firewall-cmd –list-ports</li>\n<li>开启端口： firewall-cmd –zone=public –add-port=80/tcp –permanent<blockquote>\n<p>命令含义：</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>–zone #作用域</p>\n</blockquote>\n<blockquote>\n<p>–add-port=80/tcp #添加端口，格式为：端口/通讯协议</p>\n</blockquote>\n<blockquote>\n<p>–permanent #永久生效，没有此参数重启后失效</p>\n</blockquote>\n<ul>\n<li>重启防火墙</li>\n</ul>\n<blockquote>\n<p>firewall-cmd –reload #重启firewall<br>systemctl stop firewalld.service #停止firewall<br>systemctl disable firewalld.service #禁止firewall开机启动<br>firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</p>\n</blockquote>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"\b数据库\"></a>\b数据库</h3><ul>\n<li>切换数据库：use mysql</li>\n<li>显示所有的表：show tables;</li>\n<li>刷新权限： flush privileges<br>\b* root用户登陆系统：mysql -u root -p mysql</li>\n</ul>\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ul>\n<li>解决SPA刷新404的方案： try_files $uri /index.html;</li>\n<li>nginx重启：service nginx restart</li>\n</ul>\n<h3 id=\"pm2\"><a href=\"#pm2\" class=\"headerlink\" title=\"pm2\"></a>pm2</h3><ul>\n<li>支持es6： pm2 start ** –node-args=”harmony”</li>\n</ul>\n"},{"title":"你不知道的Javascript上卷——中","date":"2018-03-29T09:37:33.000Z","_content":"\n上卷中花了2章的时间来讲this，涉及到词法作用域，动态作用域，执行上下文等概念。this让函数可以自动引用合适的上下文对象，不需要显示的传递。\n\n## 对this的误解\n一开始学习的时候，我对this也产生了很多误解，最常见的2种误解就是指向本身和指向作用域，比如函数里面的this就指代函数本身\n\n### 误解之指向本身\n\n看一个demo\n```js\nfunction foo(num){\n    console.log(\"num:\", num)\n    this.count++\n}\nfoo.count = 0\nfor(var i = 0 ; i<5; i++){\n    foo(i)\n}\n\nconsole.log(\"count:\", foo.count) //0\n```\n这里跟理想的结果不一样了，如果函数内部的this指向这个函数本身，那么this.count会是5。可以得出一个结论，函数内部的属性count和this.count不是一个。虽然属性名相同，。但是跟对象不同。\n\n为了解决这个问题，如果用以下的方法：\n```js\nfunction foo(num){\n    console.log('num:', num)\n    data.count++\n}\n\nvar data = {\n    count: 0\n}\nfor(let i = 0; i < 5; i++){\n    foo(i)\n}\nconsole.log(data.count)\n```\n这样做肯定没问题，但是无法理解this的含义和工作原理————而是返回的舒适区，单纯的用了一下词法作用域\n比较合理的解决方法是：**强制让this指向foo函数对象**\n\n```js\nfunction foo(num){\n    console.log('num:', num)\n    this.count++\n}\n\nfoo.count= 0\n\bfor(let i = 0; i < 5; i++){\n    foo.call(foo, i)\n}\nconsole.log(foo.count)\n```\n通过上面的demo得出的结论是this指向函数本身是不正确的。\n\n### 误解之指向函数的作用域\n```js\nfuntion foo(){\n    var a = 1\n    this.bar()\n}\nfunction bar(){\n    console.log(this.a) // undefined\n}\nfoo()\n```\n这里的this并不指函数的词法作用域，而是window对象\n\n### this到底是什么\n\n排除了上面2种理解之后，this到底是什么呢。\nthis是在运行时绑定的，不是在编写的时候，那就肯定不是词法作用域。他的上下文取决于函数调用时的各种条件。\n所以可以说this只取决于函数调用的方式。\n当一个函数被调用的时候，会创建一个活动记录（有些地方会叫执行上下文），这个记录包含了函数在那被调用，调用方式，传入的参数信息，this也在里面。\n\n## this全面解析\nthis有4种绑定的规则，并且有优先级排列，具体如下\n### 默认绑定\n默认绑定的this指向全局对象，window和global（node环境）\n```js\nfunction foo(){\n    var a = 'foo'\n    console.log(this.a) // window\n}\nvar a = 'window'\nfunction bar(){\n    var a = 'bar'\n    foo()\n}\nbar()\n```\n那么怎么判断采用默认绑定的方式呢？这个demo中foo直接采用不带任何修饰的函数引用进行调用的，因此就是默认绑定。\n又一个小细节，foo运行在strict模式下，this不能绑定到全局对象。\n**注意是运行不是调用，外部的调用函数在strict模式下没影响。**\n### 隐式绑定\n这条规则需要考虑调用位置是否有上下文的对象\n```js\nfunction foo(){\n    console.log(this.a)\n}\n\nvar obj = {\n    a: 1;\n    foo: foo\n}\nobj.foo() // 1\n```\n当函数有上下文对象时，隐式绑定会把this绑定到这个上下文对象。\n**对象属性引用作用域链中只有上一层或者说最后一层在调用位置中起作用**\n```js\nfunction foo(){\n    console.log(this.a)\n}\n\nvar obj1 = {\n    a: 'obj1',\n    foo: foo\n}\nvar obj2 = {\n    obj1: obj1,\n    a:'obj2'\n}\nobj2.obj1.foo() // obj1\n```\n**隐性丢失**\n以下情况都会丢失绑定对象\n```js\nfunction foo(){\n    console.log(this.a)\n}\nvar obj = {\n    foo: foo,\n    a:'inner'\n}\nvar _foo = obj.foo\nvar a = 'global'\n_foo() // global\n```\n_foo是obj.foo的 一个引用，实际上他是引用foo函数本身，因此此时的调用也是一个不带任何修辞的函数调用，默认绑定。\n\n**还有一种更加常见的丢失情况在回调函数中发生。**\n```js\nfunction foo(){\n    console.log(this.a)\n}\nvar a = 'global'\nvar obj = {\n    a:1,\n    foo:foo\n}\nfunction doFoo(fn){\n    fn()\n}\ndoFoo(obj.foo) // global\n\n```\n参数传递也是一种隐式赋值，结果跟上面的一样，丢失上下文对象\n同样原生内置的方法，也是一样的。\n```js\nfunction foo(){\n    console.log(this.a)\n}\nvar obj = {\n    foo: foo,\n    a: 'inner'\n}\nvar a = 'global'\n\nsetTimeout(obj.foo,1000) // global\n```\n### 显式绑定\n\nJavascript所有的函数原型链上都有call和apply方法。这2个方法是如何工作的呢？第一个参数是一个对象，为this准备的，调用的时候绑定到this。\n\n```js\nfunction foo(){\n    console.log(this.a)\n}\nvar obj = {\n    a:'inner'\n}\nfoo.call(obj) // inner\n```\n解决绑定丢失的问题\n```js\nfunction foo(){\n    console.log(this.a)\n}\n\nvar obj1 = {\n    a:'inner'\n}\n\nfunction bar(){\n    foo.call(obj1)\n}\n\nsetTimeout(bar,2000) // inner\n```\n\napply 实现 bind\ncall 和 apply的区别在于第二个参数，跟bind的区别，bind()是绑定this并返回一个函数，并没有执行。call和apply直接执行\n```js\nfunction foo(something){\n    console.log(this.a,something)\n}\n\nFunction.prototype.bind = function(obj){\n    let self = this\n    return function(){\n        self.apply(obj,arguments)\n    }\n}\n\nvar obj1 = {\n    a:'try to do'\n}\n\nvar bar = foo.bind(obj1)\nbar('what you want') // try to do what you want\n```\n### new绑定\n\n使用new调用函数，会执行以下操作\n\n> 1. 创建全新的对象\n> 2. 这个新对象会执行[[prototype]]连接\n> 3. 这个新对象会绑定到函数调用的this\n> 4. 如果函数没有返回其他对象，new表达式中的函数调用会自动返回这个新对象\n\n```js\nfunction foo(a){\n    this.a = a\n}\n\nvar obj = new foo('inner')\nconsole.log(obj) // {a: inner}\n```\n\n**四种规则的优先级依次升高，new > 显式 > 隐式 > 默认**\n\n## this词法\n\n箭头函数中的this并不根据以上的几条规则来决定，根据外层作用域决定（词法作用域）。\n```js\nfunction foo(){\n    return (a)=>{\n        console.log(this.a)\n    }\n}\nvar obj1 = {\n    a:'obj1'\n}\nvar obj2 = {\n    a:'obj2'\n}\n\nvar bar = foo.call(obj1)\nbar.call(obj2) // obj1\n```\n这里输出的是obj1，箭头函数的词法作用域中的this是obj1，所以继承下来了。\n可以解决一些隐式绑定中丢失的问题。\n以前一直好奇为啥有时候会写：**var self = this**\n```js\nvar a = 'global'\nvar obj = {\n    a:'inner'\n}\n\nfunction foo(){\n    console.log('outThis:',this)\n    var self = this\n    setTimeout(function(){\n        console.log('innerThis',this)\n        console.log('self',self)\n        console.log(self.a)\n    },2000)\n}\n\nfoo.call(obj)\n```\n现在我理解了，foo.call(obj)的时候，outThis是指向obj的，但是在回调中，隐式丢失，innerThis是global对象了，所以用一个变量self保存outThis，由于闭包的原理，self会一直保存对这个变量的引用并且内层函数有访问权限。\n\n那么换一种实现呢\n```js\nvar a = 'global'\nvar obj = {\n    a: 'inner'\n}\n\nfunction foo(){\n    setTimeout(()=>{\n        console.log(this.a)\n    },2000)\n}\n\nfoo.call(obj) // inner\n```\n\n箭头函数的this绑定规则不遵守以上的4种规则。如下例\n```js\nconst foo = () => {\n    console.log(this.a)\n}\nvar obj = {\n    a: 'inner',\n    foo: ()=> {\n        console.log(this.a)\n    }\n}\nvar a = 'global'\nobj.foo() // global\n```\n## 小结\n\nthis判断的规则\n1. 由new调用？绑定到新创建的对象\n2. 由call或者apply或者（bind）调用？绑定指定对象\n3. 由上下文对象调用？绑定上下文对象\n4. 默认，严格模式下到undefined，否则绑定global对象\n\n箭头函数根据词法作用域决定","source":"_posts/你不知道的Javascript上卷——中.md","raw":"---\ntitle: 你不知道的Javascript上卷——中\ndate: 2018-03-29 17:37:33\ntags: 读书笔记\ncategory: 读书笔记\n---\n\n上卷中花了2章的时间来讲this，涉及到词法作用域，动态作用域，执行上下文等概念。this让函数可以自动引用合适的上下文对象，不需要显示的传递。\n\n## 对this的误解\n一开始学习的时候，我对this也产生了很多误解，最常见的2种误解就是指向本身和指向作用域，比如函数里面的this就指代函数本身\n\n### 误解之指向本身\n\n看一个demo\n```js\nfunction foo(num){\n    console.log(\"num:\", num)\n    this.count++\n}\nfoo.count = 0\nfor(var i = 0 ; i<5; i++){\n    foo(i)\n}\n\nconsole.log(\"count:\", foo.count) //0\n```\n这里跟理想的结果不一样了，如果函数内部的this指向这个函数本身，那么this.count会是5。可以得出一个结论，函数内部的属性count和this.count不是一个。虽然属性名相同，。但是跟对象不同。\n\n为了解决这个问题，如果用以下的方法：\n```js\nfunction foo(num){\n    console.log('num:', num)\n    data.count++\n}\n\nvar data = {\n    count: 0\n}\nfor(let i = 0; i < 5; i++){\n    foo(i)\n}\nconsole.log(data.count)\n```\n这样做肯定没问题，但是无法理解this的含义和工作原理————而是返回的舒适区，单纯的用了一下词法作用域\n比较合理的解决方法是：**强制让this指向foo函数对象**\n\n```js\nfunction foo(num){\n    console.log('num:', num)\n    this.count++\n}\n\nfoo.count= 0\n\bfor(let i = 0; i < 5; i++){\n    foo.call(foo, i)\n}\nconsole.log(foo.count)\n```\n通过上面的demo得出的结论是this指向函数本身是不正确的。\n\n### 误解之指向函数的作用域\n```js\nfuntion foo(){\n    var a = 1\n    this.bar()\n}\nfunction bar(){\n    console.log(this.a) // undefined\n}\nfoo()\n```\n这里的this并不指函数的词法作用域，而是window对象\n\n### this到底是什么\n\n排除了上面2种理解之后，this到底是什么呢。\nthis是在运行时绑定的，不是在编写的时候，那就肯定不是词法作用域。他的上下文取决于函数调用时的各种条件。\n所以可以说this只取决于函数调用的方式。\n当一个函数被调用的时候，会创建一个活动记录（有些地方会叫执行上下文），这个记录包含了函数在那被调用，调用方式，传入的参数信息，this也在里面。\n\n## this全面解析\nthis有4种绑定的规则，并且有优先级排列，具体如下\n### 默认绑定\n默认绑定的this指向全局对象，window和global（node环境）\n```js\nfunction foo(){\n    var a = 'foo'\n    console.log(this.a) // window\n}\nvar a = 'window'\nfunction bar(){\n    var a = 'bar'\n    foo()\n}\nbar()\n```\n那么怎么判断采用默认绑定的方式呢？这个demo中foo直接采用不带任何修饰的函数引用进行调用的，因此就是默认绑定。\n又一个小细节，foo运行在strict模式下，this不能绑定到全局对象。\n**注意是运行不是调用，外部的调用函数在strict模式下没影响。**\n### 隐式绑定\n这条规则需要考虑调用位置是否有上下文的对象\n```js\nfunction foo(){\n    console.log(this.a)\n}\n\nvar obj = {\n    a: 1;\n    foo: foo\n}\nobj.foo() // 1\n```\n当函数有上下文对象时，隐式绑定会把this绑定到这个上下文对象。\n**对象属性引用作用域链中只有上一层或者说最后一层在调用位置中起作用**\n```js\nfunction foo(){\n    console.log(this.a)\n}\n\nvar obj1 = {\n    a: 'obj1',\n    foo: foo\n}\nvar obj2 = {\n    obj1: obj1,\n    a:'obj2'\n}\nobj2.obj1.foo() // obj1\n```\n**隐性丢失**\n以下情况都会丢失绑定对象\n```js\nfunction foo(){\n    console.log(this.a)\n}\nvar obj = {\n    foo: foo,\n    a:'inner'\n}\nvar _foo = obj.foo\nvar a = 'global'\n_foo() // global\n```\n_foo是obj.foo的 一个引用，实际上他是引用foo函数本身，因此此时的调用也是一个不带任何修辞的函数调用，默认绑定。\n\n**还有一种更加常见的丢失情况在回调函数中发生。**\n```js\nfunction foo(){\n    console.log(this.a)\n}\nvar a = 'global'\nvar obj = {\n    a:1,\n    foo:foo\n}\nfunction doFoo(fn){\n    fn()\n}\ndoFoo(obj.foo) // global\n\n```\n参数传递也是一种隐式赋值，结果跟上面的一样，丢失上下文对象\n同样原生内置的方法，也是一样的。\n```js\nfunction foo(){\n    console.log(this.a)\n}\nvar obj = {\n    foo: foo,\n    a: 'inner'\n}\nvar a = 'global'\n\nsetTimeout(obj.foo,1000) // global\n```\n### 显式绑定\n\nJavascript所有的函数原型链上都有call和apply方法。这2个方法是如何工作的呢？第一个参数是一个对象，为this准备的，调用的时候绑定到this。\n\n```js\nfunction foo(){\n    console.log(this.a)\n}\nvar obj = {\n    a:'inner'\n}\nfoo.call(obj) // inner\n```\n解决绑定丢失的问题\n```js\nfunction foo(){\n    console.log(this.a)\n}\n\nvar obj1 = {\n    a:'inner'\n}\n\nfunction bar(){\n    foo.call(obj1)\n}\n\nsetTimeout(bar,2000) // inner\n```\n\napply 实现 bind\ncall 和 apply的区别在于第二个参数，跟bind的区别，bind()是绑定this并返回一个函数，并没有执行。call和apply直接执行\n```js\nfunction foo(something){\n    console.log(this.a,something)\n}\n\nFunction.prototype.bind = function(obj){\n    let self = this\n    return function(){\n        self.apply(obj,arguments)\n    }\n}\n\nvar obj1 = {\n    a:'try to do'\n}\n\nvar bar = foo.bind(obj1)\nbar('what you want') // try to do what you want\n```\n### new绑定\n\n使用new调用函数，会执行以下操作\n\n> 1. 创建全新的对象\n> 2. 这个新对象会执行[[prototype]]连接\n> 3. 这个新对象会绑定到函数调用的this\n> 4. 如果函数没有返回其他对象，new表达式中的函数调用会自动返回这个新对象\n\n```js\nfunction foo(a){\n    this.a = a\n}\n\nvar obj = new foo('inner')\nconsole.log(obj) // {a: inner}\n```\n\n**四种规则的优先级依次升高，new > 显式 > 隐式 > 默认**\n\n## this词法\n\n箭头函数中的this并不根据以上的几条规则来决定，根据外层作用域决定（词法作用域）。\n```js\nfunction foo(){\n    return (a)=>{\n        console.log(this.a)\n    }\n}\nvar obj1 = {\n    a:'obj1'\n}\nvar obj2 = {\n    a:'obj2'\n}\n\nvar bar = foo.call(obj1)\nbar.call(obj2) // obj1\n```\n这里输出的是obj1，箭头函数的词法作用域中的this是obj1，所以继承下来了。\n可以解决一些隐式绑定中丢失的问题。\n以前一直好奇为啥有时候会写：**var self = this**\n```js\nvar a = 'global'\nvar obj = {\n    a:'inner'\n}\n\nfunction foo(){\n    console.log('outThis:',this)\n    var self = this\n    setTimeout(function(){\n        console.log('innerThis',this)\n        console.log('self',self)\n        console.log(self.a)\n    },2000)\n}\n\nfoo.call(obj)\n```\n现在我理解了，foo.call(obj)的时候，outThis是指向obj的，但是在回调中，隐式丢失，innerThis是global对象了，所以用一个变量self保存outThis，由于闭包的原理，self会一直保存对这个变量的引用并且内层函数有访问权限。\n\n那么换一种实现呢\n```js\nvar a = 'global'\nvar obj = {\n    a: 'inner'\n}\n\nfunction foo(){\n    setTimeout(()=>{\n        console.log(this.a)\n    },2000)\n}\n\nfoo.call(obj) // inner\n```\n\n箭头函数的this绑定规则不遵守以上的4种规则。如下例\n```js\nconst foo = () => {\n    console.log(this.a)\n}\nvar obj = {\n    a: 'inner',\n    foo: ()=> {\n        console.log(this.a)\n    }\n}\nvar a = 'global'\nobj.foo() // global\n```\n## 小结\n\nthis判断的规则\n1. 由new调用？绑定到新创建的对象\n2. 由call或者apply或者（bind）调用？绑定指定对象\n3. 由上下文对象调用？绑定上下文对象\n4. 默认，严格模式下到undefined，否则绑定global对象\n\n箭头函数根据词法作用域决定","slug":"你不知道的Javascript上卷——中","published":1,"updated":"2018-06-12T16:14:07.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvmi000zmsvmbxd9rg8y","content":"<p>上卷中花了2章的时间来讲this，涉及到词法作用域，动态作用域，执行上下文等概念。this让函数可以自动引用合适的上下文对象，不需要显示的传递。</p>\n<h2 id=\"对this的误解\"><a href=\"#对this的误解\" class=\"headerlink\" title=\"对this的误解\"></a>对this的误解</h2><p>一开始学习的时候，我对this也产生了很多误解，最常见的2种误解就是指向本身和指向作用域，比如函数里面的this就指代函数本身</p>\n<h3 id=\"误解之指向本身\"><a href=\"#误解之指向本身\" class=\"headerlink\" title=\"误解之指向本身\"></a>误解之指向本身</h3><p>看一个demo<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"num:\"</span>, num)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    foo(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"count:\"</span>, foo.count) <span class=\"comment\">//0</span></span><br></pre></td></tr></table></figure></p>\n<p>这里跟理想的结果不一样了，如果函数内部的this指向这个函数本身，那么this.count会是5。可以得出一个结论，函数内部的属性count和this.count不是一个。虽然属性名相同，。但是跟对象不同。</p>\n<p>为了解决这个问题，如果用以下的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'num:'</span>, num)</span><br><span class=\"line\">    data.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    foo(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data.count)</span><br></pre></td></tr></table></figure></p>\n<p>这样做肯定没问题，但是无法理解this的含义和工作原理————而是返回的舒适区，单纯的用了一下词法作用域<br>比较合理的解决方法是：<strong>强制让this指向foo函数对象</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'num:'</span>, num)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.count= <span class=\"number\">0</span></span><br><span class=\"line\">\b<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    foo.call(foo, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count)</span><br></pre></td></tr></table></figure>\n<p>通过上面的demo得出的结论是this指向函数本身是不正确的。</p>\n<h3 id=\"误解之指向函数的作用域\"><a href=\"#误解之指向函数的作用域\" class=\"headerlink\" title=\"误解之指向函数的作用域\"></a>误解之指向函数的作用域</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funtion foo()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>这里的this并不指函数的词法作用域，而是window对象</p>\n<h3 id=\"this到底是什么\"><a href=\"#this到底是什么\" class=\"headerlink\" title=\"this到底是什么\"></a>this到底是什么</h3><p>排除了上面2种理解之后，this到底是什么呢。<br>this是在运行时绑定的，不是在编写的时候，那就肯定不是词法作用域。他的上下文取决于函数调用时的各种条件。<br>所以可以说this只取决于函数调用的方式。<br>当一个函数被调用的时候，会创建一个活动记录（有些地方会叫执行上下文），这个记录包含了函数在那被调用，调用方式，传入的参数信息，this也在里面。</p>\n<h2 id=\"this全面解析\"><a href=\"#this全面解析\" class=\"headerlink\" title=\"this全面解析\"></a>this全面解析</h2><p>this有4种绑定的规则，并且有优先级排列，具体如下</p>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><p>默认绑定的this指向全局对象，window和global（node环境）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">'foo'</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// window</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'window'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">'bar'</span></span><br><span class=\"line\">    foo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure></p>\n<p>那么怎么判断采用默认绑定的方式呢？这个demo中foo直接采用不带任何修饰的函数引用进行调用的，因此就是默认绑定。<br>又一个小细节，foo运行在strict模式下，this不能绑定到全局对象。<br><strong>注意是运行不是调用，外部的调用函数在strict模式下没影响。</strong></p>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>这条规则需要考虑调用位置是否有上下文的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>;</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>当函数有上下文对象时，隐式绑定会把this绑定到这个上下文对象。<br><strong>对象属性引用作用域链中只有上一层或者说最后一层在调用位置中起作用</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'obj1'</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    obj1: obj1,</span><br><span class=\"line\">    a:<span class=\"string\">'obj2'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj2.obj1.foo() <span class=\"comment\">// obj1</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>隐性丢失</strong><br>以下情况都会丢失绑定对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    foo: foo,</span><br><span class=\"line\">    a:<span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _foo = obj.foo</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\">_foo() <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure></p>\n<p>_foo是obj.foo的 一个引用，实际上他是引用foo函数本身，因此此时的调用也是一个不带任何修辞的函数调用，默认绑定。</p>\n<p><strong>还有一种更加常见的丢失情况在回调函数中发生。</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">    fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doFoo(obj.foo) <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure></p>\n<p>参数传递也是一种隐式赋值，结果跟上面的一样，丢失上下文对象<br>同样原生内置的方法，也是一样的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    foo: foo,</span><br><span class=\"line\">    a: <span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(obj.foo,<span class=\"number\">1000</span>) <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><p>Javascript所有的函数原型链上都有call和apply方法。这2个方法是如何工作的呢？第一个参数是一个对象，为this准备的，调用的时候绑定到this。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.call(obj) <span class=\"comment\">// inner</span></span><br></pre></td></tr></table></figure>\n<p>解决绑定丢失的问题<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    foo.call(obj1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(bar,<span class=\"number\">2000</span>) <span class=\"comment\">// inner</span></span><br></pre></td></tr></table></figure></p>\n<p>apply 实现 bind<br>call 和 apply的区别在于第二个参数，跟bind的区别，bind()是绑定this并返回一个函数，并没有执行。call和apply直接执行<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a,something)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        self.apply(obj,<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'try to do'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind(obj1)</span><br><span class=\"line\">bar(<span class=\"string\">'what you want'</span>) <span class=\"comment\">// try to do what you want</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h3><p>使用new调用函数，会执行以下操作</p>\n<blockquote>\n<ol>\n<li>创建全新的对象</li>\n<li>这个新对象会执行[[prototype]]连接</li>\n<li>这个新对象会绑定到函数调用的this</li>\n<li>如果函数没有返回其他对象，new表达式中的函数调用会自动返回这个新对象</li>\n</ol>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> foo(<span class=\"string\">'inner'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj) <span class=\"comment\">// &#123;a: inner&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>四种规则的优先级依次升高，new &gt; 显式 &gt; 隐式 &gt; 默认</strong></p>\n<h2 id=\"this词法\"><a href=\"#this词法\" class=\"headerlink\" title=\"this词法\"></a>this词法</h2><p>箭头函数中的this并不根据以上的几条规则来决定，根据外层作用域决定（词法作用域）。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'obj1'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'obj2'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call(obj1)</span><br><span class=\"line\">bar.call(obj2) <span class=\"comment\">// obj1</span></span><br></pre></td></tr></table></figure></p>\n<p>这里输出的是obj1，箭头函数的词法作用域中的this是obj1，所以继承下来了。<br>可以解决一些隐式绑定中丢失的问题。<br>以前一直好奇为啥有时候会写：<strong>var self = this</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'outThis:'</span>,<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'innerThis'</span>,<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'self'</span>,self)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(self.a)</span><br><span class=\"line\">    &#125;,<span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(obj)</span><br></pre></td></tr></table></figure></p>\n<p>现在我理解了，foo.call(obj)的时候，outThis是指向obj的，但是在回调中，隐式丢失，innerThis是global对象了，所以用一个变量self保存outThis，由于闭包的原理，self会一直保存对这个变量的引用并且内层函数有访问权限。</p>\n<p>那么换一种实现呢<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">    &#125;,<span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(obj) <span class=\"comment\">// inner</span></span><br></pre></td></tr></table></figure></p>\n<p>箭头函数的this绑定规则不遵守以上的4种规则。如下例<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'inner'</span>,</span><br><span class=\"line\">    foo: <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>this判断的规则</p>\n<ol>\n<li>由new调用？绑定到新创建的对象</li>\n<li>由call或者apply或者（bind）调用？绑定指定对象</li>\n<li>由上下文对象调用？绑定上下文对象</li>\n<li>默认，严格模式下到undefined，否则绑定global对象</li>\n</ol>\n<p>箭头函数根据词法作用域决定</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上卷中花了2章的时间来讲this，涉及到词法作用域，动态作用域，执行上下文等概念。this让函数可以自动引用合适的上下文对象，不需要显示的传递。</p>\n<h2 id=\"对this的误解\"><a href=\"#对this的误解\" class=\"headerlink\" title=\"对this的误解\"></a>对this的误解</h2><p>一开始学习的时候，我对this也产生了很多误解，最常见的2种误解就是指向本身和指向作用域，比如函数里面的this就指代函数本身</p>\n<h3 id=\"误解之指向本身\"><a href=\"#误解之指向本身\" class=\"headerlink\" title=\"误解之指向本身\"></a>误解之指向本身</h3><p>看一个demo<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"num:\"</span>, num)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    foo(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"count:\"</span>, foo.count) <span class=\"comment\">//0</span></span><br></pre></td></tr></table></figure></p>\n<p>这里跟理想的结果不一样了，如果函数内部的this指向这个函数本身，那么this.count会是5。可以得出一个结论，函数内部的属性count和this.count不是一个。虽然属性名相同，。但是跟对象不同。</p>\n<p>为了解决这个问题，如果用以下的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'num:'</span>, num)</span><br><span class=\"line\">    data.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    foo(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data.count)</span><br></pre></td></tr></table></figure></p>\n<p>这样做肯定没问题，但是无法理解this的含义和工作原理————而是返回的舒适区，单纯的用了一下词法作用域<br>比较合理的解决方法是：<strong>强制让this指向foo函数对象</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'num:'</span>, num)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.count= <span class=\"number\">0</span></span><br><span class=\"line\">\b<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">    foo.call(foo, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count)</span><br></pre></td></tr></table></figure>\n<p>通过上面的demo得出的结论是this指向函数本身是不正确的。</p>\n<h3 id=\"误解之指向函数的作用域\"><a href=\"#误解之指向函数的作用域\" class=\"headerlink\" title=\"误解之指向函数的作用域\"></a>误解之指向函数的作用域</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funtion foo()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>这里的this并不指函数的词法作用域，而是window对象</p>\n<h3 id=\"this到底是什么\"><a href=\"#this到底是什么\" class=\"headerlink\" title=\"this到底是什么\"></a>this到底是什么</h3><p>排除了上面2种理解之后，this到底是什么呢。<br>this是在运行时绑定的，不是在编写的时候，那就肯定不是词法作用域。他的上下文取决于函数调用时的各种条件。<br>所以可以说this只取决于函数调用的方式。<br>当一个函数被调用的时候，会创建一个活动记录（有些地方会叫执行上下文），这个记录包含了函数在那被调用，调用方式，传入的参数信息，this也在里面。</p>\n<h2 id=\"this全面解析\"><a href=\"#this全面解析\" class=\"headerlink\" title=\"this全面解析\"></a>this全面解析</h2><p>this有4种绑定的规则，并且有优先级排列，具体如下</p>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><p>默认绑定的this指向全局对象，window和global（node环境）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">'foo'</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// window</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'window'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">'bar'</span></span><br><span class=\"line\">    foo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure></p>\n<p>那么怎么判断采用默认绑定的方式呢？这个demo中foo直接采用不带任何修饰的函数引用进行调用的，因此就是默认绑定。<br>又一个小细节，foo运行在strict模式下，this不能绑定到全局对象。<br><strong>注意是运行不是调用，外部的调用函数在strict模式下没影响。</strong></p>\n<h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>这条规则需要考虑调用位置是否有上下文的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>;</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>当函数有上下文对象时，隐式绑定会把this绑定到这个上下文对象。<br><strong>对象属性引用作用域链中只有上一层或者说最后一层在调用位置中起作用</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'obj1'</span>,</span><br><span class=\"line\">    foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    obj1: obj1,</span><br><span class=\"line\">    a:<span class=\"string\">'obj2'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj2.obj1.foo() <span class=\"comment\">// obj1</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>隐性丢失</strong><br>以下情况都会丢失绑定对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    foo: foo,</span><br><span class=\"line\">    a:<span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _foo = obj.foo</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\">_foo() <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure></p>\n<p>_foo是obj.foo的 一个引用，实际上他是引用foo函数本身，因此此时的调用也是一个不带任何修辞的函数调用，默认绑定。</p>\n<p><strong>还有一种更加常见的丢失情况在回调函数中发生。</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span>,</span><br><span class=\"line\">    foo:foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">    fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doFoo(obj.foo) <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure></p>\n<p>参数传递也是一种隐式赋值，结果跟上面的一样，丢失上下文对象<br>同样原生内置的方法，也是一样的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    foo: foo,</span><br><span class=\"line\">    a: <span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(obj.foo,<span class=\"number\">1000</span>) <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h3><p>Javascript所有的函数原型链上都有call和apply方法。这2个方法是如何工作的呢？第一个参数是一个对象，为this准备的，调用的时候绑定到this。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.call(obj) <span class=\"comment\">// inner</span></span><br></pre></td></tr></table></figure>\n<p>解决绑定丢失的问题<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    foo.call(obj1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(bar,<span class=\"number\">2000</span>) <span class=\"comment\">// inner</span></span><br></pre></td></tr></table></figure></p>\n<p>apply 实现 bind<br>call 和 apply的区别在于第二个参数，跟bind的区别，bind()是绑定this并返回一个函数，并没有执行。call和apply直接执行<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a,something)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        self.apply(obj,<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'try to do'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind(obj1)</span><br><span class=\"line\">bar(<span class=\"string\">'what you want'</span>) <span class=\"comment\">// try to do what you want</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h3><p>使用new调用函数，会执行以下操作</p>\n<blockquote>\n<ol>\n<li>创建全新的对象</li>\n<li>这个新对象会执行[[prototype]]连接</li>\n<li>这个新对象会绑定到函数调用的this</li>\n<li>如果函数没有返回其他对象，new表达式中的函数调用会自动返回这个新对象</li>\n</ol>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> foo(<span class=\"string\">'inner'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj) <span class=\"comment\">// &#123;a: inner&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>四种规则的优先级依次升高，new &gt; 显式 &gt; 隐式 &gt; 默认</strong></p>\n<h2 id=\"this词法\"><a href=\"#this词法\" class=\"headerlink\" title=\"this词法\"></a>this词法</h2><p>箭头函数中的this并不根据以上的几条规则来决定，根据外层作用域决定（词法作用域）。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'obj1'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'obj2'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.call(obj1)</span><br><span class=\"line\">bar.call(obj2) <span class=\"comment\">// obj1</span></span><br></pre></td></tr></table></figure></p>\n<p>这里输出的是obj1，箭头函数的词法作用域中的this是obj1，所以继承下来了。<br>可以解决一些隐式绑定中丢失的问题。<br>以前一直好奇为啥有时候会写：<strong>var self = this</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'outThis:'</span>,<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'innerThis'</span>,<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'self'</span>,self)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(self.a)</span><br><span class=\"line\">    &#125;,<span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(obj)</span><br></pre></td></tr></table></figure></p>\n<p>现在我理解了，foo.call(obj)的时候，outThis是指向obj的，但是在回调中，隐式丢失，innerThis是global对象了，所以用一个变量self保存outThis，由于闭包的原理，self会一直保存对这个变量的引用并且内层函数有访问权限。</p>\n<p>那么换一种实现呢<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'inner'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">    &#125;,<span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(obj) <span class=\"comment\">// inner</span></span><br></pre></td></tr></table></figure></p>\n<p>箭头函数的this绑定规则不遵守以上的4种规则。如下例<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'inner'</span>,</span><br><span class=\"line\">    foo: <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'global'</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// global</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>this判断的规则</p>\n<ol>\n<li>由new调用？绑定到新创建的对象</li>\n<li>由call或者apply或者（bind）调用？绑定指定对象</li>\n<li>由上下文对象调用？绑定上下文对象</li>\n<li>默认，严格模式下到undefined，否则绑定global对象</li>\n</ol>\n<p>箭头函数根据词法作用域决定</p>\n"},{"title":"字符串加法与全排列问题","date":"2018-04-22T14:33:18.000Z","_content":"\n## 概述\n依旧来源于codewar的5星题，现在刷codewar，4星题还是蛮吃力的，5星题正好，能锻炼自己也不太吃力。\n\n### 字符串全排列\n* 字符串全排列，以数组的形式输出\n\n#### solution1 递归 + 插入\n\n> 假如要得到字符串为“abcd”的全排列数组permutation('abcd')，bcd的全排列结果为permutation('bcd')，这个结果是一个数组['bcd','bdc','cbd','cdb','dbc','dcb']，map这个数组，\b将a插入到每个字符串的每个位置，就是permutation('abcd')\n\n```js\nfunction sort(str){\n    if(str.length <= 1) return [str]\n    let left = str[0]\n    let arr = []\n    let rest = str.substr(1)\n    let strArr = sort(rest)\n    strArr.forEach(v=>{\n        for(let j = 0; j <= v.length; j++){\n            let _str = v.slice(0,j) + left + v.slice(j)\n            arr.push(_str)\n        }\n    })\n    return arr\n}\n```\n## 字符串加法\n数据太大会有溢出问题，所以不能直接+\n\n```js\nfunction sumStrings(a,b) {\n// get the min len\n  var len = a.length > b.length ? a.length : b.length\n\n  let arr = [0]\n  for(let i = 1; i <= len ; i++){\n    let num = arr.pop();\n    let _a = (a[a.length - i] === undefined) ? 0 : (+a[a.length - i]);\n    let _b = (b[b.length -i] === undefined) ? 0 : (+b[b.length -i]);\n    let sum1 = _a + _b + num\n    let num1 = sum1%10\n    let num2 = parseInt(sum1/10)\n    arr.push(num1,num2)\n  }\n  //let _pop = arr.pop()\n  let str = arr.reverse().join('')\n  for(let i = 0; i < str.length; i++){\n    (str[0] === '0') && (str = str.substr(1))\n  }\n  return str\n}\n```\n\n## find next bigger\nInstructions\nOutput\nYou have to create a function that takes a positive integer number and returns the next bigger number formed by the same digits:\n\nnextBigger(12)==21\nnextBigger(513)==531\nnextBigger(2017)==2071\n\n```js\nfunction nextBigger(n){\n  let arr = permutation(\"\"+n)7\n  return +arr[arr.indexOf(\"\" + n) + 1]\n}\n\nfunction permutation(str){\n  if(str.length === 1) return [str]\n  let arr = []\n  let left = str[0]\n  let rest = str.slice(1)\n  let strArr = permutation(rest)\n  strArr.forEach(v=>{\n    for(let i = 0; i <= v.length; i++){\n      let _str = v.slice(0,i) + left + v.slice(i)\n      arr.push(_str)\n    }\n  })\n  \n  return [... new Set(arr)].sort((a,b)=> a - b)\n}\n```","source":"_posts/字符串加法与全排列问题.md","raw":"---\ntitle: 字符串加法与全排列问题\ndate: 2018-04-22 22:33:18\ntags: 算法\ncategory: JavaScript\n---\n\n## 概述\n依旧来源于codewar的5星题，现在刷codewar，4星题还是蛮吃力的，5星题正好，能锻炼自己也不太吃力。\n\n### 字符串全排列\n* 字符串全排列，以数组的形式输出\n\n#### solution1 递归 + 插入\n\n> 假如要得到字符串为“abcd”的全排列数组permutation('abcd')，bcd的全排列结果为permutation('bcd')，这个结果是一个数组['bcd','bdc','cbd','cdb','dbc','dcb']，map这个数组，\b将a插入到每个字符串的每个位置，就是permutation('abcd')\n\n```js\nfunction sort(str){\n    if(str.length <= 1) return [str]\n    let left = str[0]\n    let arr = []\n    let rest = str.substr(1)\n    let strArr = sort(rest)\n    strArr.forEach(v=>{\n        for(let j = 0; j <= v.length; j++){\n            let _str = v.slice(0,j) + left + v.slice(j)\n            arr.push(_str)\n        }\n    })\n    return arr\n}\n```\n## 字符串加法\n数据太大会有溢出问题，所以不能直接+\n\n```js\nfunction sumStrings(a,b) {\n// get the min len\n  var len = a.length > b.length ? a.length : b.length\n\n  let arr = [0]\n  for(let i = 1; i <= len ; i++){\n    let num = arr.pop();\n    let _a = (a[a.length - i] === undefined) ? 0 : (+a[a.length - i]);\n    let _b = (b[b.length -i] === undefined) ? 0 : (+b[b.length -i]);\n    let sum1 = _a + _b + num\n    let num1 = sum1%10\n    let num2 = parseInt(sum1/10)\n    arr.push(num1,num2)\n  }\n  //let _pop = arr.pop()\n  let str = arr.reverse().join('')\n  for(let i = 0; i < str.length; i++){\n    (str[0] === '0') && (str = str.substr(1))\n  }\n  return str\n}\n```\n\n## find next bigger\nInstructions\nOutput\nYou have to create a function that takes a positive integer number and returns the next bigger number formed by the same digits:\n\nnextBigger(12)==21\nnextBigger(513)==531\nnextBigger(2017)==2071\n\n```js\nfunction nextBigger(n){\n  let arr = permutation(\"\"+n)7\n  return +arr[arr.indexOf(\"\" + n) + 1]\n}\n\nfunction permutation(str){\n  if(str.length === 1) return [str]\n  let arr = []\n  let left = str[0]\n  let rest = str.slice(1)\n  let strArr = permutation(rest)\n  strArr.forEach(v=>{\n    for(let i = 0; i <= v.length; i++){\n      let _str = v.slice(0,i) + left + v.slice(i)\n      arr.push(_str)\n    }\n  })\n  \n  return [... new Set(arr)].sort((a,b)=> a - b)\n}\n```","slug":"字符串加法与全排列问题","published":1,"updated":"2018-06-12T16:14:07.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkvml0013msvm73oc2js3","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>依旧来源于codewar的5星题，现在刷codewar，4星题还是蛮吃力的，5星题正好，能锻炼自己也不太吃力。</p>\n<h3 id=\"字符串全排列\"><a href=\"#字符串全排列\" class=\"headerlink\" title=\"字符串全排列\"></a>字符串全排列</h3><ul>\n<li>字符串全排列，以数组的形式输出</li>\n</ul>\n<h4 id=\"solution1-递归-插入\"><a href=\"#solution1-递归-插入\" class=\"headerlink\" title=\"solution1 递归 + 插入\"></a>solution1 递归 + 插入</h4><blockquote>\n<p>假如要得到字符串为“abcd”的全排列数组permutation(‘abcd’)，bcd的全排列结果为permutation(‘bcd’)，这个结果是一个数组[‘bcd’,’bdc’,’cbd’,’cdb’,’dbc’,’dcb’]，map这个数组，\b将a插入到每个字符串的每个位置，就是permutation(‘abcd’)</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sort</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> [str]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = str[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = []</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rest = str.substr(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> strArr = sort(rest)</span><br><span class=\"line\">    strArr.forEach(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= v.length; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> _str = v.slice(<span class=\"number\">0</span>,j) + left + v.slice(j)</span><br><span class=\"line\">            arr.push(_str)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串加法\"><a href=\"#字符串加法\" class=\"headerlink\" title=\"字符串加法\"></a>字符串加法</h2><p>数据太大会有溢出问题，所以不能直接+</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumStrings</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// get the min len</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> len = a.length &gt; b.length ? a.length : b.length</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= len ; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = arr.pop();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _a = (a[a.length - i] === <span class=\"literal\">undefined</span>) ? <span class=\"number\">0</span> : (+a[a.length - i]);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _b = (b[b.length -i] === <span class=\"literal\">undefined</span>) ? <span class=\"number\">0</span> : (+b[b.length -i]);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum1 = _a + _b + num</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num1 = sum1%<span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> num2 = <span class=\"built_in\">parseInt</span>(sum1/<span class=\"number\">10</span>)</span><br><span class=\"line\">    arr.push(num1,num2)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//let _pop = arr.pop()</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> str = arr.reverse().join(<span class=\"string\">''</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; str.length; i++)&#123;</span><br><span class=\"line\">    (str[<span class=\"number\">0</span>] === <span class=\"string\">'0'</span>) &amp;&amp; (str = str.substr(<span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"find-next-bigger\"><a href=\"#find-next-bigger\" class=\"headerlink\" title=\"find next bigger\"></a>find next bigger</h2><p>Instructions<br>Output<br>You have to create a function that takes a positive integer number and returns the next bigger number formed by the same digits:</p>\n<p>nextBigger(12)==21<br>nextBigger(513)==531<br>nextBigger(2017)==2071</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nextBigger</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = permutation(<span class=\"string\">\"\"</span>+n)<span class=\"number\">7</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> +arr[arr.indexOf(<span class=\"string\">\"\"</span> + n) + <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">permutation</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(str.length === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> [str]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = str[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rest = str.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> strArr = permutation(rest)</span><br><span class=\"line\">  strArr.forEach(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= v.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> _str = v.slice(<span class=\"number\">0</span>,i) + left + v.slice(i)</span><br><span class=\"line\">      arr.push(_str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> [... new <span class=\"built_in\">Set</span>(arr)].sort(<span class=\"function\">(<span class=\"params\">a,b</span>)=&gt;</span> a - b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>依旧来源于codewar的5星题，现在刷codewar，4星题还是蛮吃力的，5星题正好，能锻炼自己也不太吃力。</p>\n<h3 id=\"字符串全排列\"><a href=\"#字符串全排列\" class=\"headerlink\" title=\"字符串全排列\"></a>字符串全排列</h3><ul>\n<li>字符串全排列，以数组的形式输出</li>\n</ul>\n<h4 id=\"solution1-递归-插入\"><a href=\"#solution1-递归-插入\" class=\"headerlink\" title=\"solution1 递归 + 插入\"></a>solution1 递归 + 插入</h4><blockquote>\n<p>假如要得到字符串为“abcd”的全排列数组permutation(‘abcd’)，bcd的全排列结果为permutation(‘bcd’)，这个结果是一个数组[‘bcd’,’bdc’,’cbd’,’cdb’,’dbc’,’dcb’]，map这个数组，\b将a插入到每个字符串的每个位置，就是permutation(‘abcd’)</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sort</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> [str]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = str[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = []</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rest = str.substr(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> strArr = sort(rest)</span><br><span class=\"line\">    strArr.forEach(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= v.length; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> _str = v.slice(<span class=\"number\">0</span>,j) + left + v.slice(j)</span><br><span class=\"line\">            arr.push(_str)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串加法\"><a href=\"#字符串加法\" class=\"headerlink\" title=\"字符串加法\"></a>字符串加法</h2><p>数据太大会有溢出问题，所以不能直接+</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumStrings</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// get the min len</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> len = a.length &gt; b.length ? a.length : b.length</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= len ; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = arr.pop();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _a = (a[a.length - i] === <span class=\"literal\">undefined</span>) ? <span class=\"number\">0</span> : (+a[a.length - i]);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _b = (b[b.length -i] === <span class=\"literal\">undefined</span>) ? <span class=\"number\">0</span> : (+b[b.length -i]);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum1 = _a + _b + num</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num1 = sum1%<span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> num2 = <span class=\"built_in\">parseInt</span>(sum1/<span class=\"number\">10</span>)</span><br><span class=\"line\">    arr.push(num1,num2)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//let _pop = arr.pop()</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> str = arr.reverse().join(<span class=\"string\">''</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; str.length; i++)&#123;</span><br><span class=\"line\">    (str[<span class=\"number\">0</span>] === <span class=\"string\">'0'</span>) &amp;&amp; (str = str.substr(<span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"find-next-bigger\"><a href=\"#find-next-bigger\" class=\"headerlink\" title=\"find next bigger\"></a>find next bigger</h2><p>Instructions<br>Output<br>You have to create a function that takes a positive integer number and returns the next bigger number formed by the same digits:</p>\n<p>nextBigger(12)==21<br>nextBigger(513)==531<br>nextBigger(2017)==2071</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nextBigger</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = permutation(<span class=\"string\">\"\"</span>+n)<span class=\"number\">7</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> +arr[arr.indexOf(<span class=\"string\">\"\"</span> + n) + <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">permutation</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(str.length === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> [str]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = str[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rest = str.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> strArr = permutation(rest)</span><br><span class=\"line\">  strArr.forEach(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= v.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> _str = v.slice(<span class=\"number\">0</span>,i) + left + v.slice(i)</span><br><span class=\"line\">      arr.push(_str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> [... new <span class=\"built_in\">Set</span>(arr)].sort(<span class=\"function\">(<span class=\"params\">a,b</span>)=&gt;</span> a - b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"青蛙跳阶梯和丢色子问题","date":"2018-04-20T07:11:20.000Z","_content":"\n## 概述 \n最近刷codewar，收获挺大的，原生方法的熟练度明显提升了。\n遇到了一些有意思的题目。记录一下\n\n### 青蛙跳阶梯问题基础版\n\n* 青蛙一次可以跳1层楼梯，也可以跳2层，问青蛙跳上n层一共有多少跳法\n\n青蛙要跳到n层，最后一步必须是从第n-1或第n-2层跳到n层，只需要统计跳到n-1和n-2的跳法。\n\n > 假设n>2,青蛙跳n层的方法有jump(n)种。jump(n) = jump(n-1) + jump(n-2)。其实就是Fibonacci sequence\n\n```js\nfunction jump(n){\n    if(n <= 1){\n        return 1\n    }\n\n    return jump(n-1) + jump(n-2)\n}\n```\nFibonacci sequence都知道，但是具体的模型抽象成这个数列，有时候难得想到。\n\n### 优化版本\n同样是Finbonacci数列，上面的递归每次都要算重复的。肯定不是最优解，或者是这是很笨的方法\n\n```js\nfunction jump(n,a = 1,b = 1){\n    if(n <= 1){\n        return 1\n    }\n    return jump(n-1,b,a+b)\n}\n```\n同样是递归，但是轻巧的多，这种递归方式叫尾递归，最后return一个函数（仅仅只有一个函数），很好玩有没有。\n### 青蛙跳阶梯问题进阶版\n\n* 青蛙一次可以跳1层楼梯，也可以跳2层....也可以跳n层，问青蛙跳上n层一共有多少跳法\n如果理解了上面的分析，这里就比较好理解了\n\n青蛙要跳到n层，最后一步必须是从第n-1或第n-2层或n-3、n-4、...、 0 层跳到n层，只需要统计跳到n-1和n-2、n-3、n-4、... 1层的跳法。\n> jump(n) = jump(n-1) + jump(n-2) + jump(n-3) + ... + jump(2) + jump(1)\n> 根据上面的等式可以化简一下,令 n - 1 = n\n> jump(n-1) = jump(n-2) + jump(n-3) + ... + jump(2) + jump(1)。2式带入1式，jump(n) = 2jump(n-1)\n哈哈，不就是比例为2的等比数列嘛\n\n```js\nfunction jump(n){\n    if(n === 1){\n        return 1\n    }\n     return 2*jump(n-1)\n}\n\nconsole.log(jump(3))\n```\n\n实际问题抽象成模型^_^\n\n### 丢色子问题\n\n* m个色子丢出的数字和为n的概率是多少\n假设概率为fn(n,m)\n> 假设色子是按顺序丢的，最后一个色子丢出来的数字肯定是1-6之间的\n那么fn(n,m) = (fn(n-1,m-1) + fn(n-2,m-1) + ... + fn(n-6,m-1))/6\n\n\n```js\nfunction fn(n,m){\n    if( n > 6*m || n < m){\n        return 0\n    }\n    if(m === 0) return 1\n    let p = 0\n    for(let i = 1; i <= 6 ; i++){\n        p += fn(n-i,m-1)/6\n    }\n    return p\n}\n```\n\n\n## 小结\n这2个问题用到的都是递归，这种思维模式挺好的。学习！\n","source":"_posts/青蛙跳阶梯和丢色子问题.md","raw":"---\ntitle: 青蛙跳阶梯和丢色子问题\ndate: 2018-04-20 15:11:20\ntags: 算法\ncategory: JavaScript\n---\n\n## 概述 \n最近刷codewar，收获挺大的，原生方法的熟练度明显提升了。\n遇到了一些有意思的题目。记录一下\n\n### 青蛙跳阶梯问题基础版\n\n* 青蛙一次可以跳1层楼梯，也可以跳2层，问青蛙跳上n层一共有多少跳法\n\n青蛙要跳到n层，最后一步必须是从第n-1或第n-2层跳到n层，只需要统计跳到n-1和n-2的跳法。\n\n > 假设n>2,青蛙跳n层的方法有jump(n)种。jump(n) = jump(n-1) + jump(n-2)。其实就是Fibonacci sequence\n\n```js\nfunction jump(n){\n    if(n <= 1){\n        return 1\n    }\n\n    return jump(n-1) + jump(n-2)\n}\n```\nFibonacci sequence都知道，但是具体的模型抽象成这个数列，有时候难得想到。\n\n### 优化版本\n同样是Finbonacci数列，上面的递归每次都要算重复的。肯定不是最优解，或者是这是很笨的方法\n\n```js\nfunction jump(n,a = 1,b = 1){\n    if(n <= 1){\n        return 1\n    }\n    return jump(n-1,b,a+b)\n}\n```\n同样是递归，但是轻巧的多，这种递归方式叫尾递归，最后return一个函数（仅仅只有一个函数），很好玩有没有。\n### 青蛙跳阶梯问题进阶版\n\n* 青蛙一次可以跳1层楼梯，也可以跳2层....也可以跳n层，问青蛙跳上n层一共有多少跳法\n如果理解了上面的分析，这里就比较好理解了\n\n青蛙要跳到n层，最后一步必须是从第n-1或第n-2层或n-3、n-4、...、 0 层跳到n层，只需要统计跳到n-1和n-2、n-3、n-4、... 1层的跳法。\n> jump(n) = jump(n-1) + jump(n-2) + jump(n-3) + ... + jump(2) + jump(1)\n> 根据上面的等式可以化简一下,令 n - 1 = n\n> jump(n-1) = jump(n-2) + jump(n-3) + ... + jump(2) + jump(1)。2式带入1式，jump(n) = 2jump(n-1)\n哈哈，不就是比例为2的等比数列嘛\n\n```js\nfunction jump(n){\n    if(n === 1){\n        return 1\n    }\n     return 2*jump(n-1)\n}\n\nconsole.log(jump(3))\n```\n\n实际问题抽象成模型^_^\n\n### 丢色子问题\n\n* m个色子丢出的数字和为n的概率是多少\n假设概率为fn(n,m)\n> 假设色子是按顺序丢的，最后一个色子丢出来的数字肯定是1-6之间的\n那么fn(n,m) = (fn(n-1,m-1) + fn(n-2,m-1) + ... + fn(n-6,m-1))/6\n\n\n```js\nfunction fn(n,m){\n    if( n > 6*m || n < m){\n        return 0\n    }\n    if(m === 0) return 1\n    let p = 0\n    for(let i = 1; i <= 6 ; i++){\n        p += fn(n-i,m-1)/6\n    }\n    return p\n}\n```\n\n\n## 小结\n这2个问题用到的都是递归，这种思维模式挺好的。学习！\n","slug":"青蛙跳阶梯和丢色子问题","published":1,"updated":"2018-06-18T14:05:25.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj1bkw7h001umsvm2oen11vm","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>最近刷codewar，收获挺大的，原生方法的熟练度明显提升了。<br>遇到了一些有意思的题目。记录一下</p>\n<h3 id=\"青蛙跳阶梯问题基础版\"><a href=\"#青蛙跳阶梯问题基础版\" class=\"headerlink\" title=\"青蛙跳阶梯问题基础版\"></a>青蛙跳阶梯问题基础版</h3><ul>\n<li>青蛙一次可以跳1层楼梯，也可以跳2层，问青蛙跳上n层一共有多少跳法</li>\n</ul>\n<p>青蛙要跳到n层，最后一步必须是从第n-1或第n-2层跳到n层，只需要统计跳到n-1和n-2的跳法。</p>\n<blockquote>\n<p>假设n&gt;2,青蛙跳n层的方法有jump(n)种。jump(n) = jump(n-1) + jump(n-2)。其实就是Fibonacci sequence</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jump</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jump(n<span class=\"number\">-1</span>) + jump(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Fibonacci sequence都知道，但是具体的模型抽象成这个数列，有时候难得想到。</p>\n<h3 id=\"优化版本\"><a href=\"#优化版本\" class=\"headerlink\" title=\"优化版本\"></a>优化版本</h3><p>同样是Finbonacci数列，上面的递归每次都要算重复的。肯定不是最优解，或者是这是很笨的方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jump</span>(<span class=\"params\">n,a = <span class=\"number\">1</span>,b = <span class=\"number\">1</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jump(n<span class=\"number\">-1</span>,b,a+b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样是递归，但是轻巧的多，这种递归方式叫尾递归，最后return一个函数（仅仅只有一个函数），很好玩有没有。</p>\n<h3 id=\"青蛙跳阶梯问题进阶版\"><a href=\"#青蛙跳阶梯问题进阶版\" class=\"headerlink\" title=\"青蛙跳阶梯问题进阶版\"></a>青蛙跳阶梯问题进阶版</h3><ul>\n<li>青蛙一次可以跳1层楼梯，也可以跳2层….也可以跳n层，问青蛙跳上n层一共有多少跳法<br>如果理解了上面的分析，这里就比较好理解了</li>\n</ul>\n<p>青蛙要跳到n层，最后一步必须是从第n-1或第n-2层或n-3、n-4、…、 0 层跳到n层，只需要统计跳到n-1和n-2、n-3、n-4、… 1层的跳法。</p>\n<blockquote>\n<p>jump(n) = jump(n-1) + jump(n-2) + jump(n-3) + … + jump(2) + jump(1)<br>根据上面的等式可以化简一下,令 n - 1 = n<br>jump(n-1) = jump(n-2) + jump(n-3) + … + jump(2) + jump(1)。2式带入1式，jump(n) = 2jump(n-1)<br>哈哈，不就是比例为2的等比数列嘛</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jump</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">2</span>*jump(n<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(jump(<span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n<p>实际问题抽象成模型^_^</p>\n<h3 id=\"丢色子问题\"><a href=\"#丢色子问题\" class=\"headerlink\" title=\"丢色子问题\"></a>丢色子问题</h3><ul>\n<li>m个色子丢出的数字和为n的概率是多少<br>假设概率为fn(n,m)<blockquote>\n<p>假设色子是按顺序丢的，最后一个色子丢出来的数字肯定是1-6之间的<br>那么fn(n,m) = (fn(n-1,m-1) + fn(n-2,m-1) + … + fn(n-6,m-1))/6</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n,m</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( n &gt; <span class=\"number\">6</span>*m || n &lt; m)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span> ; i++)&#123;</span><br><span class=\"line\">        p += fn(n-i,m<span class=\"number\">-1</span>)/<span class=\"number\">6</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这2个问题用到的都是递归，这种思维模式挺好的。学习！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>最近刷codewar，收获挺大的，原生方法的熟练度明显提升了。<br>遇到了一些有意思的题目。记录一下</p>\n<h3 id=\"青蛙跳阶梯问题基础版\"><a href=\"#青蛙跳阶梯问题基础版\" class=\"headerlink\" title=\"青蛙跳阶梯问题基础版\"></a>青蛙跳阶梯问题基础版</h3><ul>\n<li>青蛙一次可以跳1层楼梯，也可以跳2层，问青蛙跳上n层一共有多少跳法</li>\n</ul>\n<p>青蛙要跳到n层，最后一步必须是从第n-1或第n-2层跳到n层，只需要统计跳到n-1和n-2的跳法。</p>\n<blockquote>\n<p>假设n&gt;2,青蛙跳n层的方法有jump(n)种。jump(n) = jump(n-1) + jump(n-2)。其实就是Fibonacci sequence</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jump</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jump(n<span class=\"number\">-1</span>) + jump(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Fibonacci sequence都知道，但是具体的模型抽象成这个数列，有时候难得想到。</p>\n<h3 id=\"优化版本\"><a href=\"#优化版本\" class=\"headerlink\" title=\"优化版本\"></a>优化版本</h3><p>同样是Finbonacci数列，上面的递归每次都要算重复的。肯定不是最优解，或者是这是很笨的方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jump</span>(<span class=\"params\">n,a = <span class=\"number\">1</span>,b = <span class=\"number\">1</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jump(n<span class=\"number\">-1</span>,b,a+b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样是递归，但是轻巧的多，这种递归方式叫尾递归，最后return一个函数（仅仅只有一个函数），很好玩有没有。</p>\n<h3 id=\"青蛙跳阶梯问题进阶版\"><a href=\"#青蛙跳阶梯问题进阶版\" class=\"headerlink\" title=\"青蛙跳阶梯问题进阶版\"></a>青蛙跳阶梯问题进阶版</h3><ul>\n<li>青蛙一次可以跳1层楼梯，也可以跳2层….也可以跳n层，问青蛙跳上n层一共有多少跳法<br>如果理解了上面的分析，这里就比较好理解了</li>\n</ul>\n<p>青蛙要跳到n层，最后一步必须是从第n-1或第n-2层或n-3、n-4、…、 0 层跳到n层，只需要统计跳到n-1和n-2、n-3、n-4、… 1层的跳法。</p>\n<blockquote>\n<p>jump(n) = jump(n-1) + jump(n-2) + jump(n-3) + … + jump(2) + jump(1)<br>根据上面的等式可以化简一下,令 n - 1 = n<br>jump(n-1) = jump(n-2) + jump(n-3) + … + jump(2) + jump(1)。2式带入1式，jump(n) = 2jump(n-1)<br>哈哈，不就是比例为2的等比数列嘛</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jump</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">2</span>*jump(n<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(jump(<span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n<p>实际问题抽象成模型^_^</p>\n<h3 id=\"丢色子问题\"><a href=\"#丢色子问题\" class=\"headerlink\" title=\"丢色子问题\"></a>丢色子问题</h3><ul>\n<li>m个色子丢出的数字和为n的概率是多少<br>假设概率为fn(n,m)<blockquote>\n<p>假设色子是按顺序丢的，最后一个色子丢出来的数字肯定是1-6之间的<br>那么fn(n,m) = (fn(n-1,m-1) + fn(n-2,m-1) + … + fn(n-6,m-1))/6</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n,m</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( n &gt; <span class=\"number\">6</span>*m || n &lt; m)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span> ; i++)&#123;</span><br><span class=\"line\">        p += fn(n-i,m<span class=\"number\">-1</span>)/<span class=\"number\">6</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这2个问题用到的都是递归，这种思维模式挺好的。学习！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjj1bkvm20005msvmg82o1qea","category_id":"cjj1bkvlz0002msvm14ykrm08","_id":"cjj1bkvm7000dmsvmdwkzb1ak"},{"post_id":"cjj1bkvlq0000msvmj1t2omfg","category_id":"cjj1bkvlz0002msvm14ykrm08","_id":"cjj1bkvma000hmsvmln0bxcyd"},{"post_id":"cjj1bkvlv0001msvmanbtl8lg","category_id":"cjj1bkvm40007msvmmfawin1q","_id":"cjj1bkvmb000lmsvm4ez8rap9"},{"post_id":"cjj1bkvm10004msvm0i4brax3","category_id":"cjj1bkvlz0002msvm14ykrm08","_id":"cjj1bkvmf000qmsvm6fftvw4l"},{"post_id":"cjj1bkvmc000nmsvml1nnmalh","category_id":"cjj1bkvlz0002msvm14ykrm08","_id":"cjj1bkvmi000xmsvmwall642a"},{"post_id":"cjj1bkvm30006msvmclrtit7y","category_id":"cjj1bkvmb000kmsvm3o8dehsk","_id":"cjj1bkvmk0010msvmpnvmomi3"},{"post_id":"cjj1bkvmg000umsvm7ij002hj","category_id":"cjj1bkvmf000rmsvmvqqrjqfu","_id":"cjj1bkvml0014msvmyapnsdry"},{"post_id":"cjj1bkvm5000amsvm8xeo7s63","category_id":"cjj1bkvmf000rmsvmvqqrjqfu","_id":"cjj1bkvmn0017msvm5oskotxa"},{"post_id":"cjj1bkvmh000wmsvmrjtvgc7w","category_id":"cjj1bkvlz0002msvm14ykrm08","_id":"cjj1bkvmo0019msvm24hggr6f"},{"post_id":"cjj1bkvmi000zmsvmbxd9rg8y","category_id":"cjj1bkvmf000rmsvmvqqrjqfu","_id":"cjj1bkvmo001cmsvmz0c8zrnq"},{"post_id":"cjj1bkvm6000cmsvm7ezht8sq","category_id":"cjj1bkvmb000kmsvm3o8dehsk","_id":"cjj1bkvmp001emsvmrrvtoedj"},{"post_id":"cjj1bkvml0013msvm73oc2js3","category_id":"cjj1bkvlz0002msvm14ykrm08","_id":"cjj1bkvmp001hmsvmzvdbzvu5"},{"post_id":"cjj1bkvm9000gmsvmrqjrcoya","category_id":"cjj1bkvmf000rmsvmvqqrjqfu","_id":"cjj1bkvmq001jmsvmhyw31di1"},{"post_id":"cjj1bkvma000jmsvmltuqukr0","category_id":"cjj1bkvmf000rmsvmvqqrjqfu","_id":"cjj1bkvmr001lmsvmw8pazd52"},{"post_id":"cjj1bkvme000pmsvmflifjg5y","category_id":"cjj1bkvmf000rmsvmvqqrjqfu","_id":"cjj1bkvmr001omsvmt7svrzpo"},{"post_id":"cjj1bkw7h001umsvm2oen11vm","category_id":"cjj1bkvlz0002msvm14ykrm08","_id":"cjj1bkw7l001xmsvmogz4twij"}],"PostTag":[{"post_id":"cjj1bkvm20005msvmg82o1qea","tag_id":"cjj1bkvm00003msvmjw3d5dja","_id":"cjj1bkvm50009msvmqu4voe6d"},{"post_id":"cjj1bkvlq0000msvmj1t2omfg","tag_id":"cjj1bkvm00003msvmjw3d5dja","_id":"cjj1bkvm6000bmsvmq9frddr9"},{"post_id":"cjj1bkvlv0001msvmanbtl8lg","tag_id":"cjj1bkvm40008msvm8lqzrya7","_id":"cjj1bkvma000imsvmp5mb25if"},{"post_id":"cjj1bkvm10004msvm0i4brax3","tag_id":"cjj1bkvm8000fmsvmtpub7prg","_id":"cjj1bkvme000omsvmybo7r3mz"},{"post_id":"cjj1bkvmc000nmsvml1nnmalh","tag_id":"cjj1bkvm8000fmsvmtpub7prg","_id":"cjj1bkvmg000smsvmxo5wxdjp"},{"post_id":"cjj1bkvm30006msvmclrtit7y","tag_id":"cjj1bkvmc000mmsvm2zmkmowp","_id":"cjj1bkvmh000vmsvmzwupmnwu"},{"post_id":"cjj1bkvmh000wmsvmrjtvgc7w","tag_id":"cjj1bkvm8000fmsvmtpub7prg","_id":"cjj1bkvml0012msvmx080797d"},{"post_id":"cjj1bkvm5000amsvm8xeo7s63","tag_id":"cjj1bkvmg000tmsvmahhp5wyr","_id":"cjj1bkvmn0015msvmgqb3mkjr"},{"post_id":"cjj1bkvm6000cmsvm7ezht8sq","tag_id":"cjj1bkvmk0011msvmnmqmjdl5","_id":"cjj1bkvmo001amsvmurvsivq2"},{"post_id":"cjj1bkvm9000gmsvmrqjrcoya","tag_id":"cjj1bkvmn0018msvmgnlhtomx","_id":"cjj1bkvmp001fmsvm74znh1tp"},{"post_id":"cjj1bkvma000jmsvmltuqukr0","tag_id":"cjj1bkvmn0018msvmgnlhtomx","_id":"cjj1bkvmq001kmsvmjd0niedp"},{"post_id":"cjj1bkvme000pmsvmflifjg5y","tag_id":"cjj1bkvmn0018msvmgnlhtomx","_id":"cjj1bkvmr001nmsvmtmi6n6ie"},{"post_id":"cjj1bkvmg000umsvm7ij002hj","tag_id":"cjj1bkvmn0018msvmgnlhtomx","_id":"cjj1bkvms001qmsvm3ndxnpeb"},{"post_id":"cjj1bkvmi000zmsvmbxd9rg8y","tag_id":"cjj1bkvmn0018msvmgnlhtomx","_id":"cjj1bkvms001smsvmib0rgpgg"},{"post_id":"cjj1bkvml0013msvm73oc2js3","tag_id":"cjj1bkvms001rmsvmvd72f1bb","_id":"cjj1bkvmt001tmsvma8tj883y"},{"post_id":"cjj1bkw7h001umsvm2oen11vm","tag_id":"cjj1bkvms001rmsvmvd72f1bb","_id":"cjj1bkw7k001wmsvmdf5s6c3y"}],"Tag":[{"name":"Javascript事件","_id":"cjj1bkvm00003msvmjw3d5dja"},{"name":"随便写写","_id":"cjj1bkvm40008msvm8lqzrya7"},{"name":"点滴","_id":"cjj1bkvm8000fmsvmtpub7prg"},{"name":"小知识","_id":"cjj1bkvmc000mmsvm2zmkmowp"},{"name":"es6","_id":"cjj1bkvmg000tmsvmahhp5wyr"},{"name":"页面布局","_id":"cjj1bkvmk0011msvmnmqmjdl5"},{"name":"读书笔记","_id":"cjj1bkvmn0018msvmgnlhtomx"},{"name":"算法","_id":"cjj1bkvms001rmsvmvd72f1bb"}]}}