[{"title":"bind实现","date":"2018-06-12T16:14:07.304Z","path":"2018/06/13/bind实现/","text":"概述首先是MDN上的描述啦：bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 fun.bind(thisArg[, arg1[, arg2[, …]]]) thisArg：当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2, …：当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 我们只要基本实现上面的功能就可以了。 bind乞丐版先不考虑多个参数的情况1234567891011let obj1 = &#123; a: '11111' &#125;function test()&#123; return this.a&#125;Function.prototype._bind = function(obj)&#123; let that = this return function()&#123; return that.apply(obj) &#125;&#125;test._bind(obj1)() // 11111 _bind方法返回一个函数，函数在词法作用域以外的地方被调用，产生了一个闭包。这里的let that = this可以不写，而是把下面的函数改成箭头函数。 进阶版之es6现在需要考虑多个参数的情况es6的解构赋值和rest操作简化了一下数组操作12345678910111213let obj1 = &#123;a: 111&#125;function test(b,c)&#123; return [this.a , b , c]&#125;Function.prototype._bind = function(obj,...args)&#123; return (..._args) =&gt; &#123; console.log([...args,..._args]) return this.apply(obj,[...args,..._args]) &#125;&#125;test._bind(obj1,1000,1)(10000) // [111,1000,1]test.bind(obj1,1000,1)(10000) // [111,1000,1] 进阶版之es5es5不支持rest操作，所以对参数的操作只能改成数组操作。arguments对象不是数组，只是内置了iterator接口，可以被遍历等。但是没有数组的内置方法。123456789101112131415let obj1 = &#123;a: 111&#125;function test(b,c)&#123; return [this.a , b , c]&#125;Function.prototype._bind = function()&#123; var slice = Array.prototype.slice var that = this var obj = arguments[0] var arg = slice.call(arguments,1) return function()&#123; return that.apply(obj,arg.concat(slice.call(arguments,0))) &#125;&#125;test._bind(obj1,1000,1)(10000) // [111,1000,1] 未完待续111111","tags":[{"name":"点滴","slug":"点滴","permalink":"http://yoursite.com/tags/点滴/"}]},{"title":"指令集","date":"2018-05-16T16:01:11.000Z","path":"2018/05/17/指令集/","text":"常用指令防火墙 查看已经开放的端口：firewall-cmd –list-ports 开启端口： firewall-cmd –zone=public –add-port=80/tcp –permanent 命令含义： –zone #作用域 –add-port=80/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效 重启防火墙 firewall-cmd –reload #重启firewallsystemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running） \b数据库 切换数据库：use mysql 显示所有的表：show tables; 刷新权限： flush privileges\b* root用户登陆系统：mysql -u root -p mysql 更改数据库密码：其实就是sql语句，UPDATE user SET password=password(“test123”) WHERE user=’root’; nginx 解决SPA刷新404的方案： try_files $uri /index.html; nginx重启：service nginx restart pm2 支持es6： pm2 start ** –node-args=”harmony”","tags":[{"name":"点滴","slug":"点滴","permalink":"http://yoursite.com/tags/点滴/"}]},{"title":"js继承","date":"2018-05-07T09:28:58.000Z","path":"2018/05/07/js继承/","text":"继承js一直在模仿其他oop语言的继承机制。但是本质上是一种代理，以下归纳了常见的实现继承的方法 原型链 + new12345678910111213141516171819202122232425function Parent()&#123; this.colors = ['red','blue'] this.name = 'edguan'&#125;Parent.prototype.getName = function()&#123; console.log(this.name)&#125;function Child(age)&#123; this.age = age&#125;Child.prototype = new Parent()Child.prototype.constructor = ChildChild.prototype.getAge = function()&#123; console.log(this.age)&#125;let child1 = new Child(25)let child2 = new Child(26)child1.colors.push('white')console.log(child1.colors)console.log(child2.colors) 缺点: 父类引用类型共享 创建子类型的实例的时候不能向父类设置传递参数，比如设置name 借用构造函数1234567891011121314151617181920212223function Parent(name)&#123; this.name = name this.color = [\"blue\",\"white\"]&#125;Parent.prototype.getName = function()&#123; return this.name&#125;function Child(name, age)&#123; Parent.call(this,name) this.age = age&#125;Child.prototype.getAge = function()&#123; return this.age&#125;let child1 = new Child('edguan',25)let child2 = new Child('sandy',34)child1.color.push(\"black\")child2.color //[\"blue\",\"white\"] child1.getName // undefined 缺点： 虽然可以传递参数了，引用类型不会共享，但是Father的原型中的方法(getName)在child中不可以被调用 混合继承结合上面的2种思路 1234567891011121314151617181920212223function Parent(name)&#123; this.color = [\"blue\",\"red\"] this.name = name&#125;Parent.prototype.getName = function()&#123; return this.name&#125;function Child(name,age)&#123; Parent.call(this,name) this.age = age&#125;Child.prototype.getAge = function()&#123; return this.age&#125;Child.prototype = new Parent()Child.prototype.constructor = Childlet child1 = new Child(\"edguan\",25)let child2 = new Child(\"sandy\",34) 缺点：new Parent()会产生Parent.prototype对象，并且会执行函数。函数内部可能有一些额外操作，这些是我们不需要的。 原型式继承用Object.create代替new Parent()的方式，避免了一些riskynew实现Object.create的polyfill如下es6 的 Object.setPrototypeOf(obj1,obj2)作用相似12345const create = (o) = &gt; &#123; let func = function Func()&#123;&#125; Func.prototype = o return new Func()&#125; 但是Object.create可以接收第二个参数，但是不常用 123456789101112131415161718192021function Parent(name)&#123; this.color = [\"blue\",\"red\"] this.name = name&#125;Parent.prototype.getName = function()&#123; return this.name&#125;function Child(name,age)&#123; Parent.call(this,name) this.age = age&#125;Child.prototype = Object.create(Parent.prototype)Child.prototype.constructor = ChildChild.prototype.getAge = function()&#123; return this.age&#125;let child1 = new Child(\"edguan\",25)let child2 = new Child(\"sandy\",34) 比较常见的方式 es6 class123456789101112131415161718192021222324252627282930class Parent&#123; constructor(name)&#123; this.name = name; this.color = [\"while\",\"red\"] &#125; getName()&#123; return this.name &#125; static getColor()&#123; return this.color &#125; _getColor()&#123; return this.color &#125;&#125;class Child extends Parent&#123; constructor(name,age)&#123; super(name); this.age = age &#125; getAge()&#123; return this.age &#125;&#125;let child1 = new Child(\"edguan\",26)let child2 = new Child(\"sandy\",34)child1.color.push('blue') class 本质上就是基于prototype的语法糖。和之前原型式继承差别不大，就是写法上的区别，给人一种类生成对象的感觉。 12typeof Child // \"function\"Child.prototype === child1.__proto__","tags":[{"name":"点滴","slug":"点滴","permalink":"http://yoursite.com/tags/点滴/"}]},{"title":"你不知道的Javascript上卷——下","date":"2018-04-26T07:31:20.000Z","path":"2018/04/26/你不知道的Javascript上卷——下/","text":"看了一个月，全书终于看完了，上下分别是关于作用域与闭包，this。而最后一部分是关于原型链的，这部分看了很久，很多地方理解都没到点上，所以一直没写。这次尝试写一下。 概述本文主要分为2部分，一部分是对象，一部分是原型。对象这个章节讲了一些平时见怪不怪但是一直不知其所以然的tips。 对象内置对象内置对象可以理解为内置的函数，加上new 操作后，作为构造函数使用，创建一个对应子类型的新对象。1234567let str = \"i am a string\"typeof str // \"string\"str instanceof String // falselet _str = new String('i am a string two')typeof _str // \"object\"str instanceof String // true str 是一个变量，”i am a string”是一个字面量，不是对象。如果对这个字面量做一些操作，比如获取长度等，需要转成String 对象。必要的时候语言会自动转成对象。 null和undefined没有构造形式，他们也不是内置对象 属性描述符es5以后所有的属性都具备了属性描述符12345var obj = &#123; a:'a'&#125;Object.getOwnPropertyDescriptor(obj,\"a\") // &#123;value: \"a\", writable: true, enumerable: true, configurable: true&#125; writable: 是否可以修改值 enumrable：是否可以被遍历中被找到 configuarable： 是否可以用defineProperty配置属性。configuable为false的时候会阻止delete这个属性 不变性 对象常量 123456var obj = &#123;&#125;Object.defineProperty(obj, \"a\",&#123; value: 'aaa', configurable: false, writeable: false&#125;) 禁止扩展 1234var obj = &#123; a: \"aaa\"&#125;Object.preventExtensions(obj) // 阻止扩展，但是a还是writeable 密封 Object.seal(..)会创建一个密封的对象，这个方法的本质就是调用preventExtensions方法并且在所有的属性设置为configurable：false。所以密封不仅不能添加属性，也不能重新配置。但是可以修改属性的值 冻结 Object.freeze(..)会创建一个冻结对象。调用了Object.seal()并且设置writable为false。当然，利用递归也可以进行深度冻结。 [[Get]] and [[Put]]访问属性有一个很微妙的细节，我一直的理解是obj.a,是在obj这个对象中寻找名字为a的属性，实际上这里面有一个内部实现的[[get]]操作。默认的[get]操作就是查找是否有与名称相同的属性，如果没有并且在原型链上也没有找到找到就会返回undefined。注意：这里和访问变量是不一样的，属性访问找不到会报异常。 Getter和Setter123456789101112var myObj = &#123; get a()&#123; return 2 &#125;&#125;Object.definePropery(myObj,'b',&#123; get: function()&#123; return this.a * 2 &#125;, enumerable: true // 确保b穿现在属性列表中&#125;) 这里执行 myObj.a = 3,myObj.a依旧还是2.因为自身定义的getter只能返回2.所有set没意义。 为了更加合理123456789101112var obj = &#123; get a()&#123; return this._a_ &#125; set a(a)&#123; this._a_ = value*2 &#125;&#125;obj.a = 2obj.a // 4 原型类函数123456function Foo()&#123; this.a = 1&#125;let a = new Foo()a.__proto__ === Foo.prototype // true 首先必须明白几个概念 Foo的原型： Foo.prototype.回顾一下new操作符干了什么 新建一个对象 this指向 建立prototype连接：将新建对象的[[prototype]]指向 Foo.prototype 返回新对象 Javascript的原型继承可以并不会复制对象属性，只是会在2个对象之间建立关联，这样一个对象就可以委托访问另一个对象的属性和方法。 原型继承1234567891011121314151617181920function Foo(name)&#123; this.name = name&#125;Foo.prototype.getName = function()&#123; return this.name&#125;function Bar(name,age)&#123; Foo.call(this, name) this.age = age&#125;Bar.prototype = Object.create(Foo.prototype)Bar.prototype.getAge = function()&#123; return this.age&#125;let bar = new Bar('edguan', 25) Object.create会创建一个新对象，并将新对象的[[prototype]]关联到指定的对象。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"字符串加法与全排列问题","date":"2018-04-22T14:33:18.000Z","path":"2018/04/22/字符串加法与全排列问题/","text":"概述依旧来源于codewar的5星题，现在刷codewar，4星题还是蛮吃力的，5星题正好，能锻炼自己也不太吃力。 字符串全排列 字符串全排列，以数组的形式输出 solution1 递归 + 插入 假如要得到字符串为“abcd”的全排列数组permutation(‘abcd’)，bcd的全排列结果为permutation(‘bcd’)，这个结果是一个数组[‘bcd’,’bdc’,’cbd’,’cdb’,’dbc’,’dcb’]，map这个数组，\b将a插入到每个字符串的每个位置，就是permutation(‘abcd’) 1234567891011121314function sort(str)&#123; if(str.length &lt;= 1) return [str] let left = str[0] let arr = [] let rest = str.substr(1) let strArr = sort(rest) strArr.forEach(v=&gt;&#123; for(let j = 0; j &lt;= v.length; j++)&#123; let _str = v.slice(0,j) + left + v.slice(j) arr.push(_str) &#125; &#125;) return arr&#125; 字符串加法数据太大会有溢出问题，所以不能直接+ 123456789101112131415161718192021function sumStrings(a,b) &#123;// get the min len var len = a.length &gt; b.length ? a.length : b.length let arr = [0] for(let i = 1; i &lt;= len ; i++)&#123; let num = arr.pop(); let _a = (a[a.length - i] === undefined) ? 0 : (+a[a.length - i]); let _b = (b[b.length -i] === undefined) ? 0 : (+b[b.length -i]); let sum1 = _a + _b + num let num1 = sum1%10 let num2 = parseInt(sum1/10) arr.push(num1,num2) &#125; //let _pop = arr.pop() let str = arr.reverse().join('') for(let i = 0; i &lt; str.length; i++)&#123; (str[0] === '0') &amp;&amp; (str = str.substr(1)) &#125; return str&#125; find next biggerInstructionsOutputYou have to create a function that takes a positive integer number and returns the next bigger number formed by the same digits: nextBigger(12)==21nextBigger(513)==531nextBigger(2017)==2071 1234567891011121314151617181920function nextBigger(n)&#123; let arr = permutation(\"\"+n)7 return +arr[arr.indexOf(\"\" + n) + 1]&#125;function permutation(str)&#123; if(str.length === 1) return [str] let arr = [] let left = str[0] let rest = str.slice(1) let strArr = permutation(rest) strArr.forEach(v=&gt;&#123; for(let i = 0; i &lt;= v.length; i++)&#123; let _str = v.slice(0,i) + left + v.slice(i) arr.push(_str) &#125; &#125;) return [... new Set(arr)].sort((a,b)=&gt; a - b)&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"青蛙跳阶梯和丢色子问题","date":"2018-04-20T07:11:20.000Z","path":"2018/04/20/青蛙跳阶梯和丢色子问题/","text":"概述最近刷codewar，收获挺大的，原生方法的熟练度明显提升了。遇到了一些有意思的题目。记录一下 青蛙跳阶梯问题基础版 青蛙一次可以跳1层楼梯，也可以跳2层，问青蛙跳上n层一共有多少跳法 青蛙要跳到n层，最后一步必须是从第n-1或第n-2层跳到n层，只需要统计跳到n-1和n-2的跳法。 假设n&gt;2,青蛙跳n层的方法有jump(n)种。jump(n) = jump(n-1) + jump(n-2)。其实就是Fibonacci sequence 1234567function jump(n)&#123; if(n &lt;= 1)&#123; return 1 &#125; return jump(n-1) + jump(n-2)&#125; Fibonacci sequence都知道，但是具体的模型抽象成这个数列，有时候难得想到。 优化版本同样是Finbonacci数列，上面的递归每次都要算重复的。肯定不是最优解，或者是这是很笨的方法 123456function jump(n,a = 1,b = 1)&#123; if(n &lt;= 1)&#123; return 1 &#125; return jump(n-1,b,a+b)&#125; 同样是递归，但是轻巧的多，这种递归方式叫尾递归，最后return一个函数（仅仅只有一个函数），很好玩有没有。 青蛙跳阶梯问题进阶版 青蛙一次可以跳1层楼梯，也可以跳2层….也可以跳n层，问青蛙跳上n层一共有多少跳法如果理解了上面的分析，这里就比较好理解了 青蛙要跳到n层，最后一步必须是从第n-1或第n-2层或n-3、n-4、…、 0 层跳到n层，只需要统计跳到n-1和n-2、n-3、n-4、… 1层的跳法。 jump(n) = jump(n-1) + jump(n-2) + jump(n-3) + … + jump(2) + jump(1)根据上面的等式可以化简一下,令 n - 1 = njump(n-1) = jump(n-2) + jump(n-3) + … + jump(2) + jump(1)。2式带入1式，jump(n) = 2jump(n-1)哈哈，不就是比例为2的等比数列嘛 12345678function jump(n)&#123; if(n === 1)&#123; return 1 &#125; return 2*jump(n-1)&#125;console.log(jump(3)) 实际问题抽象成模型^_^ 丢色子问题 m个色子丢出的数字和为n的概率是多少假设概率为fn(n,m) 假设色子是按顺序丢的，最后一个色子丢出来的数字肯定是1-6之间的那么fn(n,m) = (fn(n-1,m-1) + fn(n-2,m-1) + … + fn(n-6,m-1))/6 1234567891011function fn(n,m)&#123; if( n &gt; 6*m || n &lt; m)&#123; return 0 &#125; if(m === 0) return 1 let p = 0 for(let i = 1; i &lt;= 6 ; i++)&#123; p += fn(n-i,m-1)/6 &#125; return p&#125; 小结这2个问题用到的都是递归，这种思维模式挺好的。学习！","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"你不知道的Javascript上卷——中","date":"2018-03-29T09:37:33.000Z","path":"2018/03/29/你不知道的Javascript上卷——中/","text":"上卷中花了2章的时间来讲this，涉及到词法作用域，动态作用域，执行上下文等概念。this让函数可以自动引用合适的上下文对象，不需要显示的传递。 对this的误解一开始学习的时候，我对this也产生了很多误解，最常见的2种误解就是指向本身和指向作用域，比如函数里面的this就指代函数本身 误解之指向本身看一个demo12345678910function foo(num)&#123; console.log(\"num:\", num) this.count++&#125;foo.count = 0for(var i = 0 ; i&lt;5; i++)&#123; foo(i)&#125;console.log(\"count:\", foo.count) //0 这里跟理想的结果不一样了，如果函数内部的this指向这个函数本身，那么this.count会是5。可以得出一个结论，函数内部的属性count和this.count不是一个。虽然属性名相同，。但是跟对象不同。 为了解决这个问题，如果用以下的方法：123456789101112function foo(num)&#123; console.log('num:', num) data.count++&#125;var data = &#123; count: 0&#125;for(let i = 0; i &lt; 5; i++)&#123; foo(i)&#125;console.log(data.count) 这样做肯定没问题，但是无法理解this的含义和工作原理————而是返回的舒适区，单纯的用了一下词法作用域比较合理的解决方法是：强制让this指向foo函数对象 12345678910function foo(num)&#123; console.log('num:', num) this.count++&#125;foo.count= 0\bfor(let i = 0; i &lt; 5; i++)&#123; foo.call(foo, i)&#125;console.log(foo.count) 通过上面的demo得出的结论是this指向函数本身是不正确的。 误解之指向函数的作用域12345678funtion foo()&#123; var a = 1 this.bar()&#125;function bar()&#123; console.log(this.a) // undefined&#125;foo() 这里的this并不指函数的词法作用域，而是window对象 this到底是什么排除了上面2种理解之后，this到底是什么呢。this是在运行时绑定的，不是在编写的时候，那就肯定不是词法作用域。他的上下文取决于函数调用时的各种条件。所以可以说this只取决于函数调用的方式。当一个函数被调用的时候，会创建一个活动记录（有些地方会叫执行上下文），这个记录包含了函数在那被调用，调用方式，传入的参数信息，this也在里面。 this全面解析this有4种绑定的规则，并且有优先级排列，具体如下 默认绑定默认绑定的this指向全局对象，window和global（node环境）12345678910function foo()&#123; var a = 'foo' console.log(this.a) // window&#125;var a = 'window'function bar()&#123; var a = 'bar' foo()&#125;bar() 那么怎么判断采用默认绑定的方式呢？这个demo中foo直接采用不带任何修饰的函数引用进行调用的，因此就是默认绑定。又一个小细节，foo运行在strict模式下，this不能绑定到全局对象。注意是运行不是调用，外部的调用函数在strict模式下没影响。 隐式绑定这条规则需要考虑调用位置是否有上下文的对象123456789function foo()&#123; console.log(this.a)&#125;var obj = &#123; a: 1; foo: foo&#125;obj.foo() // 1 当函数有上下文对象时，隐式绑定会把this绑定到这个上下文对象。对象属性引用作用域链中只有上一层或者说最后一层在调用位置中起作用12345678910111213function foo()&#123; console.log(this.a)&#125;var obj1 = &#123; a: 'obj1', foo: foo&#125;var obj2 = &#123; obj1: obj1, a:'obj2'&#125;obj2.obj1.foo() // obj1 隐性丢失以下情况都会丢失绑定对象12345678910function foo()&#123; console.log(this.a)&#125;var obj = &#123; foo: foo, a:'inner'&#125;var _foo = obj.foovar a = 'global'_foo() // global _foo是obj.foo的 一个引用，实际上他是引用foo函数本身，因此此时的调用也是一个不带任何修辞的函数调用，默认绑定。 还有一种更加常见的丢失情况在回调函数中发生。123456789101112function foo()&#123; console.log(this.a)&#125;var a = 'global'var obj = &#123; a:1, foo:foo&#125;function doFoo(fn)&#123; fn()&#125;doFoo(obj.foo) // global 参数传递也是一种隐式赋值，结果跟上面的一样，丢失上下文对象同样原生内置的方法，也是一样的。12345678910function foo()&#123; console.log(this.a)&#125;var obj = &#123; foo: foo, a: 'inner'&#125;var a = 'global'setTimeout(obj.foo,1000) // global 显式绑定Javascript所有的函数原型链上都有call和apply方法。这2个方法是如何工作的呢？第一个参数是一个对象，为this准备的，调用的时候绑定到this。 1234567function foo()&#123; console.log(this.a)&#125;var obj = &#123; a:'inner'&#125;foo.call(obj) // inner 解决绑定丢失的问题12345678910111213function foo()&#123; console.log(this.a)&#125;var obj1 = &#123; a:'inner'&#125;function bar()&#123; foo.call(obj1)&#125;setTimeout(bar,2000) // inner apply 实现 bindcall 和 apply的区别在于第二个参数，跟bind的区别，bind()是绑定this并返回一个函数，并没有执行。call和apply直接执行1234567891011121314151617function foo(something)&#123; console.log(this.a,something)&#125;Function.prototype.bind = function(obj)&#123; let self = this return function()&#123; self.apply(obj,arguments) &#125;&#125;var obj1 = &#123; a:'try to do'&#125;var bar = foo.bind(obj1)bar('what you want') // try to do what you want new绑定使用new调用函数，会执行以下操作 创建全新的对象 这个新对象会执行[[prototype]]连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，new表达式中的函数调用会自动返回这个新对象 123456function foo(a)&#123; this.a = a&#125;var obj = new foo('inner')console.log(obj) // &#123;a: inner&#125; 四种规则的优先级依次升高，new &gt; 显式 &gt; 隐式 &gt; 默认 this词法箭头函数中的this并不根据以上的几条规则来决定，根据外层作用域决定（词法作用域）。1234567891011121314function foo()&#123; return (a)=&gt;&#123; console.log(this.a) &#125;&#125;var obj1 = &#123; a:'obj1'&#125;var obj2 = &#123; a:'obj2'&#125;var bar = foo.call(obj1)bar.call(obj2) // obj1 这里输出的是obj1，箭头函数的词法作用域中的this是obj1，所以继承下来了。可以解决一些隐式绑定中丢失的问题。以前一直好奇为啥有时候会写：var self = this12345678910111213141516var a = 'global'var obj = &#123; a:'inner'&#125;function foo()&#123; console.log('outThis:',this) var self = this setTimeout(function()&#123; console.log('innerThis',this) console.log('self',self) console.log(self.a) &#125;,2000)&#125;foo.call(obj) 现在我理解了，foo.call(obj)的时候，outThis是指向obj的，但是在回调中，隐式丢失，innerThis是global对象了，所以用一个变量self保存outThis，由于闭包的原理，self会一直保存对这个变量的引用并且内层函数有访问权限。 那么换一种实现呢123456789101112var a = 'global'var obj = &#123; a: 'inner'&#125;function foo()&#123; setTimeout(()=&gt;&#123; console.log(this.a) &#125;,2000)&#125;foo.call(obj) // inner 箭头函数的this绑定规则不遵守以上的4种规则。如下例1234567891011const foo = () =&gt; &#123; console.log(this.a)&#125;var obj = &#123; a: 'inner', foo: ()=&gt; &#123; console.log(this.a) &#125;&#125;var a = 'global'obj.foo() // global 小结this判断的规则 由new调用？绑定到新创建的对象 由call或者apply或者（bind）调用？绑定指定对象 由上下文对象调用？绑定上下文对象 默认，严格模式下到undefined，否则绑定global对象 箭头函数根据词法作用域决定","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"css中的长度单位与居中","date":"2018-03-26T07:45:39.000Z","path":"2018/03/26/css中的长度单位与居中/","text":"css居中问题一只是经典问题啦，实现的方式有很多，但是还是需要记录一下。 长度单位 px：(pixel)像素，像素px是相对于显示器屏幕分辨率而言的(引自CSS2.0手册)。电子屏幕上组成一幅图画或照片的最基本单元； pt: (point)点，印刷行业常用单位，等于1/72英寸，就是我们在Word或者WPS等办公软件中使用的字体大小单位； ppi: (pixel per inch)每英寸像素数，该值越高，则屏幕越细腻，用于计算机和电视屏幕上每英寸显示的像素点的数量； dpi: (dot per inch)每英寸多少点，该值越高，则图片越细腻，用于打印； dp: (dip，Density-independent pixel) 是安卓开发用的长度单位，1dp表示在屏幕像素点密度为160ppi时1px长度； sp: (scale-independent pixel)安卓开发用的字体大小单位； em:(emphasize) 是相对长度单位，相对于当前对象内文本的字体尺寸，即em的计算是基于父级元素font-size的； rem: （root em，根em）是css3新增的一个相对单位，与em的区别在于，它是相对于html根元素的(在body标签里面设置字体大小不起作用)； vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。 vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。 vmin：vw和vh中较小的那个。 vmax：vw和vh中较大的那个。 vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Android browser4.4+支持，chrome for android39支持 居中水平居中","tags":[{"name":"小知识","slug":"小知识","permalink":"http://yoursite.com/tags/小知识/"}]},{"title":"你不知道的Javascript上卷——上","date":"2018-03-26T06:28:08.000Z","path":"2018/03/26/你不知道的Javascript上卷——上/","text":"概述一直都想好好读一下这本书，很多同行安利过了。每次都是读一点都读不下去，最近很仔细的品读了一下，真的非常棒，读完之后受益匪浅。这次的读书笔记是读完本书上卷的前半部分——作用域和闭包之后写的。 作用域是什么一言以蔽之，作用域是一套完整的变量存储的规则。变量存在哪里，怎么找到这个变量，都是这套规则决定的。 编译原理最初学习js的时候就会说js是一门解释性的语言，事实上他是编译语言，但是又和传统的编译语言不一样，比如JAVA，打个war包或者编译成class文件，js并不是提前编译的，编译的结果也不能在分布式系统中进行移植。对于传统的语言，代码执行之前有3个步骤，分词/词法分析 =&gt; 解析/语法分析 =&gt; 代码生成 理解作用域引擎：从头到尾负责整个js的编译和执行过程 编译器： 引擎的好朋友，负责语法分析和代码生成 作用域：收集和维护所有的变量组成一系列查询和一套严格的规则。 词法作用域词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块级作用域写在哪里来决定的。欺骗词法，eval和with，对性能会有影响。 函数作用域和块作用域函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。 块作用域：IIFE，let，const，try 变量提升中函数优先 闭包闭包是基于词法作用域书写产生的自然结果。函数在定义时的词法作用域以外的地方被调用，闭包可以让函数继续访问定义时的词法作用域。 12345678function wait(msg)&#123; setTimeout(function timer()&#123; console.log(msg) &#125;,1000)&#125;wait('hello closure') 将内部函数（timer）传递给setTimeout，timer具有覆盖wait的作用域，wait执行1000ms后，他的作用域不会消失，timer依然保持对wait作用域的闭包 循环和闭包经典面试题12345for(var i = 0;i&lt;5; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,i*2000)&#125; 首先 setTimeout中的回调会在循环之后执行var 没有块作用域，所有的i都在全局作用域，最后打印的只能是5 可以采用IIFE和let 12345for(let i = 0;i&lt;5; i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,i*2000)&#125; 1234567for(var i = 0;i&lt;5; i++)&#123; ((i)=&gt;&#123; setTimeout(function()&#123; console.log(i) &#125;,i*2000) &#125;)(i)&#125; 小结书中有很多原理性知识的讲解，但是不想浪费时间去截取了。直接看书就很好啦。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"css之圣杯布局","date":"2018-03-21T03:08:15.000Z","path":"2018/03/21/css之圣杯布局/","text":"概述css一只是我很薄弱的一个点，也一直不够重视。最近写一个页面的时候，常见的圣杯布局就写得很难受，所以就趁机好好学习一把。哈哈 flex阮一峰老师写的很全面了，浅显易懂。从自己的角度理解一下 flex布局——语法篇 flex布局——实例篇 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器（container）的属性任何容器都可以指定为flex布局123.box &#123; display: flex&#125; 容器一共有以下6个属性,第一个为默认值 这里注释是错误的。但是。。。我懒得改了12345678910111213141516171819.box &#123; // 项目的排列方向 flex-direction: row | row-reverse | column | column-reverse; // 换行方式 flex-wrap: nowrap | wrap | wrap-reverse; // flex-direction 和 flex-wrap的简写，默认为 row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; // justify-content属性定义了项目在主轴上的对齐方式 justify-content: flex-start | flex-end | center | space-between | space-around; // align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; // align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch&#125; 项目的属性项目属性同样也有6个1234567891011121314151617181920.item &#123; // order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 order: &lt;integer&gt;; // flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-grow: &lt;number&gt;; /* default 0 */ // flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-shrink: &lt;number&gt;; /* default 1 */ // flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex-basis: &lt;length&gt; | auto; /* default auto */ // 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] //align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默 align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 相对定位实现直接看demo啦12345&lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt; 通过-margin和相对定位实现 1234567891011121314151617181920212223242526272829 .container &#123; padding: 0 200px 0 150px; height: 100vh; background-color: green&#125;.main &#123; width: 100%; background-color: red; float: left&#125;.left &#123; margin-left: -100%; position: relative; right: 150px; width: 150px; background-color: blue; float: left&#125;.right &#123; position: relative; margin-left: -200px; left:200px; width: 200px; float: left; background-color: pink&#125; 双飞翼布局圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决 “中间栏div内容不被遮挡”问题的思路不一样。 html结构有所改变1234567&lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"content\"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031.container &#123; height: 100vh; text-align: center; background-color: green&#125;.content &#123; height:100%; margin: 0 200px 0 150px;&#125;.main &#123; width: 100%; height: 100%; background-color: red; float: left&#125;.left &#123; margin-left: -100%; height: 100%; width: 150px; background-color: blue; float: left&#125;.right &#123; margin-left: -200px; height: 100%; width: 200px; float: left; background-color: pink&#125; css简单了，不需要相对定位了 flex实现123456789101112131415161718192021222324.container &#123; height: 100vh; display: flex; background-color: green&#125;.main &#123; flex: 1; height: 90vh; background-color: red;&#125;.left &#123; order: -1; flex: 0 0 20%; height: 90vh; background-color: blue;&#125;.right &#123; flex: 0 0 15%; height: 90vh; background-color: pink&#125; 个人最喜欢的实现方式 小节圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性）。","tags":[{"name":"页面布局","slug":"页面布局","permalink":"http://yoursite.com/tags/页面布局/"}]},{"title":"Js事件机制（下）","date":"2018-03-14T07:13:12.000Z","path":"2018/03/14/Js事件机制（下）/","text":"上文介绍了事件流和事件类型，本文介绍事件对象和事件代理 事件对象 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包括所有与事件有关的信息。 DOM中的事件对象兼容DOM的浏览器将一个event对象传入到事件处理程序中。无论指定的事件使用什么方法，DOM 0 级和 DOM 2级，都会传入event对象12345678910111213141516&lt;input onclick=\"alert(event.type)\"/&gt;&lt;input onclick = \"handleClick(event)\"/&gt;&lt;script&gt; //HTML事件，html中参数必须为event function handleClick(e)&#123; console.log(e.type) &#125; let btn = document.getElementById(\"myBtn\") // DOM 0 级事件 btn.onclick = function(e)&#123; console.log(e.type) &#125; btn.addEventListener(\"click\", function(e)&#123; console.log(e.type) &#125;,false)&lt;/script&gt; HTML原生事件，DOM 0 级事件，DOM 2 级事件都可以获取到event对象。Event对象成员 属性/方法 类型 读/写 说明 bubbles Boolean 只读 表明事件是否冒泡 cancelable boolean 只读 表明是否可以取消事件的默认行为 currentTarget Element 只读 表明事件处理程序当前处理的那个程序 defaultPrevented boolean 只读 为true表示事件已经调用过preventDefault details Interger 只读 与事件相关的细节信息 eventPhrase Interger 只读 调用事件处理程序的阶段，1表示捕获，2表示目标阶段，3表示冒泡 preventDefault() Function 只读 取消事件的默认行为 stopImmediatePropagation() Function 只读 取消事件的进一步冒泡，同时阻止任何事件处理程序被调用 stopPropagation() Function 只读 取消事件的进一步冒泡 target Element 只读 事件的目标DOM trusted Boolean 只读 true表示是浏览器生成的 type String 只读 被触发的事件类型 view AbstractView 只读 与事件关联的抽象视图 只有在事件处理程序执行期间，event对象才会存在， 执行完会销毁 IE中的事件对象在使用DOM 0 级方法添加事件处理函数时，event对象作为window对象的一个属性存在。1234 btn.onclick = function()&#123; var event = window.event; console.log(event.type) //\"click\"&#125; 如果用atttchEvent添加的，那么就会有一个event对象作为参数传入事件处理函数中123btn.attachEvent(\"onclick\", function(event)&#123; console.log(event.type)&#125;) IE的event对象同样也包含于创建他的事件相关的属性和方法。 属性/方法 类型 读/写 说明 cancelBubble Boolean 读/写 default value 为 false，当设置为true时等同于DOM中的stopPropagation() returnValue boolean 读/写 default value 为 true，当设置为false时等同于DOM中的preventDefault srcElement Element 只读 与DOM事件中的target相同 type boolean 只读 被触发的事件类型 跨浏览器的事件对象虽然DOM和IE的event对象不同，但是基于他们之间的相似性依然可以拿出跨浏览器的方案来。1234567891011121314151617181920212223242526272829303132333435363738394041let eventUtil = &#123; addHandler: function(element,type,handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type,handler,false) &#125; else if(event.attachEvent) &#123; element.attachEvent(\"on\" + type, handler) &#125; else &#123; element[\"on\" + type] = handler &#125; &#125;, getEvent: function (event) &#123; return event || window.event &#125;, getTarget: function (event) &#123; return event.target || event.srcElement &#125;, stopProparation: function (event) &#123; if(event.stopPropagation) &#123; event.stopPropagation() &#125; else &#123; event.cancelBubble = true &#125; &#125;, preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault() &#125; else &#123; event.returnValue = false &#125; &#125;, removeHandle: function (event) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type,handler,false) &#125; else if(event.detachEvent) &#123; element.detachEvent(\"on\" + type, handler) &#125; else &#123; element[\"on\" + type] = null &#125; &#125;&#125; 事件代理通过之前的学习，我们知道事件处理程序让HTML与JS交互提供了可能。但是每次给DOM元素添加一个事件函数，那么就会在内存中加入一个对象，对象越多，性能也会有很大的影响。其次必须首先指定所有事件处理程序，这个过程需要很多的DOM访问，会影响整个页面的交互就绪时间。举个例子。1234567891011121314151617181920&lt;ul id = \"ul\"&gt; &lt;li id = \"li1\"&gt;1&lt;/li&gt; &lt;li id = \"li2\"&gt;2&lt;/li&gt; &lt;li id = \"li3\"&gt;3&lt;/li&gt; .....&lt;ul&gt;&lt;script&gt; let li1 = document.getElementById('li1') let li2 = document.getElementById('li2') let li3 = document.getElementById('li3') eventUtil.addHandler(li1,\"click\", function(event)&#123; console.log(event.target) &#125;) eventUtil.addHandler(li2,\"click\", function(event)&#123; console.log(event.target.id) &#125;) eventUtil.addHandler(li3,\"click\", function(event)&#123; console.log(event.target.id) &#125;)&lt;/script&gt; 这种方式无疑很粗暴的，如果有成百上千个li，必然需要很大的代码量，就算采用的遍历的方式，代码量会少，但是遍历和过多的直接操作DOM也是不可取的。这个时候需要引入事件代理。 事件代理（有些人会叫事件委托）：只需要在DOM树中尽量最高的层次添加一个事件处理程序，利用事件冒泡的原理，子元素的事件也可以捕获到 还是上面的例子，用事件代理的方式实现12345678910111213141516let ul = document.getElementById(\"ul\")eventUtil.addHandler(ul, \"click\",function(event)&#123; event = eventUtil.getEvent(event) let target = eventUtil.getTarget(event) switch (target.id) &#123; case \"li1\": console.log(target.id) break case \"li2\": console.log(target.id) break case \"li3\": console.log(target.id) break &#125;&#125;) 最适合采用事件委托的事件包括click,mousedown,mouseup,keydown,keyup和keypress。封装一下事件代理 delegate123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id = 'test' style=\"height:200px; background:red\"&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;456&lt;/li&gt; &lt;li&gt;789&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; let ul = document.getElementById('test') function delegate(parent,type,selector,fn)&#123; function handle(e)&#123; let _e = window.e || e let target = _e.target || _e.srcElement if(target.id === selector || target.nodeName.toLowerCase() === selector)&#123; fn(_e) &#125; &#125; parent[type] = handle &#125; delegate(ul,'onclick','li',function(e)&#123; e.target.innerHTML = e.target.innerHTML.split('').reverse().join('') &#125;)&lt;/script&gt;&lt;/html&gt; 事件代理的本质还是利用了事件冒泡","tags":[{"name":"Javascript事件","slug":"Javascript事件","permalink":"http://yoursite.com/tags/Javascript事件/"}]},{"title":"2017年小结","date":"2018-03-13T07:34:03.000Z","path":"2018/03/13/2017年小结/","text":"写在毕业一年之际2017年，毕业一年了。做前端也满打满算一年了。 what i have done一年待了3家公司，不看理由，就冲这一点，感觉自己这方面做的不够好。跳槽中途的狗血不想吐槽了，跳槽的理由也不说了。这一年从最开始学习React开始，当时还是一个前端小白，本科也是学的自动化，自学了半个月只能写写静态页面，很庆幸遇到了亮哥这样的leader，一个10年工作经验的老程序员，看到了很多这个阶段程序员该有的素养，写东西也好，带的团队也让人很舒服，可以说这辈子不奢求能再遇到像亮哥这样的leader了。亮哥曾说过：我做了这么久的开发，java转js，不管是java还是js，我只能说会用，或者说熟练使用他们做东西，不敢说精通。我React，node啥的，算得上会用，不敢说熟练。其实这个年纪了，比较希望一个stable platform to settle down.中途去了一家Pre A互联网公司，跟亮哥提离职的时候，想了很久，说很想去互联网公司看一下，看一下他们的运作模式，看了之后也算是见识了很多，但是更多的还是失望。最大的感触，互联网整体环境还是浮躁的，尤其是规模和体量没到那一步的时候，天天画大饼，天天要融资， 每天都是鸡血。其实做的产品我自己都不能认可，我都觉得不好用，各种华而不实的需求。不过那段时间代码量上去了，天天写的比较多。我担心的是，一个浮躁的公司，人也会浮躁的吧，所以我走了 前端圈的浮躁上面说到了浮躁，整个前端圈子也挺浮躁的，水平参差不齐，新的轮子炒来炒去，培训班每个月一大批出来的人，会用几个api就敢说精通js了。其实也一直害怕自己太浮躁，所以经常会看看书，之前水平不够，看的也很浅，或者说很多看不懂，做了一年了，也需要一个时间沉淀一下了。书读百遍，其义自现。最近开发强度很小，有很多自己支配的时间，也给自己定了一些小任务。 最近干点啥呢前几天仔细读了犀牛书部分章节，也做了了一点记录。准备花2天时间好好看看underscore源码了，跟着敲敲，下一步就是系统的重新看一下css了，看了几个博客还是不太系统。然后就是之前从0开始写了一个react的前后端项目，之前写了个开头。不管读书还是源码学习，demo等都会同步到github。 ###","tags":[{"name":"随便写写","slug":"随便写写","permalink":"http://yoursite.com/tags/随便写写/"}]},{"title":"javascript权威指南-第三章（类型）","date":"2018-03-13T07:29:36.000Z","path":"2018/03/13/javascript权威指南-第三章（类型）/","text":"概述这一章主要是讲类型、值、变量。以前觉得大概都知道，但是静下心来好好看，还是看到了很多以前理解错误的地方。 数据类型js中的数据类型：分为基本类型和引用类型string num boolean undefined null，引用类型就是指object这一个大的类别，包括function array等。null可以理解为特殊的对象值。理解了这个，typeof返回什么之类的就很清晰了。 num Math.max(…args) 居然原生支持取出最大值/最小值的api Infinity 的概念。0/0 ,无穷大除以无穷大，或者强制转不能转成数字的操作都会返回NaN Infinity 和 NaN 都只是可读的 NaN和谁都不相等。判断是不是NaN的方法 x != x.这个函数的作用和isNaN相识 实数有无数个，但是js只能表现有限的个数。That is to say,js中实数都是一个近似值。2进制的表示法表示不了0.1这样的数字，所以 0.3-0.2 === 0.2-0.1返回false stringstring是基本的数据类型，任何操作都不会改变它，虽然可以操作数组一样操作它。注意区分slice、substring、substr的区别简单来说，3个方法都可以截取字符串的一段，从开始位置到结束位置(不包括结束位置)，区别体现在位置参数为负数的时候 bool值涉及到一个强转的问题。null undefined 0 -0 NaN “ ” 都会转为false null 和 undefinednull: 关键字。表示对象字符串num是无值的，也是一个对象，表示‘非对象’ undefined：不是关键字。表示变量没有初始化 包装对象存取字符串数字bool的属性的时候创建的对象，包装对象和原始值不全等这里还是有点坑的，只是不愿意去理解太多。 不可变和可变一言以蔽之，基本类型都是不可变的，引用类型都是可变的。 1234let a = &#123;a:1,b:2&#125;let b = a // b只是通过a拿到对象的引用，a,b指向的都是同一个内存空间b.a = 3a //也会改变 可以看下对象拷贝简单实现 类型转换== 和 === 的区别在于==在比较之前做了一次类型转换。太多规则，记不住。以后再看 变量作用域你不知道的js看了太多了。声明提前的操作在代码编译阶段，不是在执行阶段。一个有意思的代码块123456var scope = 'global'function test()&#123; console.log(scope) // undefined,不是global，一定要注意，局部变量始终在函数体中有定义 var scope = 'local' console.log(scope) // 'local'&#125; ###总结都是自己理解上不太准确的地方，或者说容易忘记的地方。记录一下","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"javascript权威指南-第二十章（客户端存储）","date":"2018-03-13T07:28:14.000Z","path":"2018/03/13/javascript权威指南-第二十章（客户端存储）/","text":"概述二十章讲的是客户端存储，很详细的介绍了常见的几种客户端存储的方式。涉及到一些同源策略的东西，所以就想看一下13章的安全性的问题。也记录一下 安全性同源策略：脚本不能读取不同服务器载入的文档内容。比如说一个页面的脚本不能监听其他页面的用户输入信息，这就是同源策略。这么来看同源策略是必须的，不然浏览一个网页，所有的其他页面的信息都暴露了。 但是确实有场景需要读取其他页面的属性，可以使用document的domain属性，domain默认是载入文档的主机名，可以人为设置，比如home.example.com可以设置成example.com。不能设置成home.example或者ample.com之类的，也必须有一个.（避免出现com的情况）如果2个窗口的domain一致，就没有同源限制啦。 跨域资源共享：origin，请求头设置Access-Control-Allow-Origin XSS(粗略了讲了一点安全问题)对于url:http://www.example.com/greet.html?David12let name = decodeURIComponent(window.location.search.substring(1)) // search可以拿到？之后的字段（可以理解为query字段？？？），转码之后可以拿到Davidalert(name) 但是如果调用http://http.www.example.com/greet.html?name=%3Cscript src=siteB/evil.js%3E%3C/script%3E这样会注入一个来自siteB的脚本，脚本在sideB中，但是可以在A中进行操作，比较危险 防止XSS的，通过不可信的数据来的时候，去掉里面的HTML标签（包括script标签）,简单的实现安全函数1name = name.replace(/&lt;/g, '&lt;').replace(/&lt;/g,'&gt;') localStorage和sessionStorage的区别两者的区别在于存储的有效期和作用域不同，也就是可以存储多长时间以及谁对数据有访问权。storage都定义了存储、获取、删除的方法 有效期和作用域localStorage的作用域是文档源级别。文档源就是协议主机和端口一致，也就是说同一个浏览器开多个窗口打开一个页面，是可以共享localStorage的。但是受浏览器供应商的限制。sessionStorage的作用域也是文档源级别，但是不太相同，它是限定在窗口中的。在不同的标签中不共享。sessionStorage在浏览器或者标签页关闭，sessionStorage里面存的数据会被删除。 存储的API123456789localStorage.setItem('x', 1)localStorage.getItem('X')/// 遍历for(let i= 0; i&lt; localStorage.length; i++ )&#123; let name = localStorage.key(i) let value = localStorage.getItem(name)&#125;localStorage.removeItem('X') //删除X项localStorage.clear() //全部删除 cookiecookie属性：有效期和作用域cookie的默认有效期是浏览器的会话期间。但是和sessionStorage有区别，cookie不局限在浏览器单个窗口，有效期和整个浏览器的进程有关。 通过max-age设置有效期设置有效期，他的作用域可以通过path和domain来配置，默认情况和创建他的web页面有关，对子页面可见。 如果路径设置成’/‘就和localStorage一样的作用域了 保存cookie12345678910111213141516171819// cookie中不允许包含分毫、逗号和空白符，所以一般采用encodeURIComponent转码// 最简单的cookie设置，浏览器关闭清除document.cookie = 'version=' + encodeURIComponent(document.lastModified)// 一个可选max-age、path、domain、secure属性的方法// 通过设置domain可以解决cookie跨域的问题const setCookie = (name, value, daysTolive, path, path) = &#123; let cookie = `$&#123;name&#125;=$&#123;encodeURLComponent(value)&#125;` if(typeOf daysToLive === 'number')&#123; cookie += `; max-age=$&#123;daysToLive * 60 * 60 * 24&#125;` &#125; if(path)&#123; cookie += `; path=$&#123;path&#125;` &#125; if(domain)&#123; cookie += `; domain=$&#123;domain&#125;` &#125; document.cookie = cookie&#125; 读取cookie通过document.cookie读取出来的是一个字符串，不同键值对通过f分号和空格隔开。value的解码方式取决于之前存储用的方式，例如上面用到的setCookie中用的方式是encodeURIComponent编码12345678910111213141516const getCookie = ()&#123; let cookieObj = &#123;&#125; let cookieStr = document.cookie if(cookieStr === '')&#123; return cookieObj &#125; let cookieArr = cookieStr.split('; ') for(let _cookie of cookieArr)&#123; let p = _cookie.indexOf('=') let name = _cookie.slice(0,p) let value = _cookie.slice(p+1) value = decodeURIComponent(value) cookieObj[name] = value &#125; return cookieObj&#125; cookie相关的存储实现类似于sessionStorage的getItem、setItem、remove、delete等功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const cookieStorage(maxage, path) &#123; //自执行函数实例化一个cookie对象 let cookie = (()=&gt;&#123; let cookieObj = &#123;&#125; let cookieStr = document.cookie if(cookieStr === '')&#123; return cookieObj &#125; let cookieArr = cookieStr.split('; ') for(let _cookie of cookieArr)&#123; let p = _cookie.indexOf('=') let name = _cookie.slice(0,p) let value = _cookie.slice(p+1) value = decodeURIComponent(value) cookieObj[name] = value &#125; return cookieObj &#125;()) // 拿出所有的key let keys = Object.keys(cookie) //存储API公共的属性和方法 this.length = keys.length //返回第n个key的名字，即key方法 this.key = (n) =&gt; &#123; if (n&lt;0 || n &gt;= keys.length) return null return keys[n] &#125; //getItem方法 this.getItem = (name) =&gt; cookie[name] || null // setItem方法 this.setItem = (key,value) =&gt; &#123; //首先判断要存储的cookie存在不,不存在先操作一次keys和length if(!(key in keys))&#123; keys.push(key) this.length++ &#125; // 针对cookie对象做的操作 cookie[key] = value //接下来就是正式操作浏览器中的cookie let domCookie = `$&#123;key&#125;=$&#123;encodeURIComponent(value)&#125;` if(maxage) domCookie += `; max-age=$&#123;maxage&#125;` if(path) domCookie += `; path=$&#123;path&#125;` document.cookie = domCookie &#125; // removeCookie this.removeItem = (key) =&gt; &#123; if(!(key in cookie)) return delete cookie[key] this.length-- let p = keys.indexOf(key) keys.splice(p,1) document.cookie = &#125; // clear this.clear = () =&gt; &#123; for(let key of keys)&#123; document.cookie = `$&#123;key&#125;=; max-age=0` &#125; cookie = &#123;&#125; keys = [] this.length = 0 &#125;&#125;","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"es6之let","date":"2018-03-13T07:26:31.000Z","path":"2018/03/13/es6之let/","text":"概述在写上一篇文章，关于cookie的操作时有一个demo，涉及到一个作用域的问题，实验了一下，然后又归纳小结了一波，主要还是参考阮大的es6入门，也算是面试经常问的问题，let和var的区别，之前都会回答块级作用域，具体一点的，申明提前，暂时性死区的都会大概提一提。想想还是好好梳理一下好了。 不存在变量提升变量提升可以换一个词，在代码编译阶段做的申明提前操作。随便看几个demo，和var的对比很容易看出来12345console.log(a) // undefinedvar a = 'var'console.log(b) // 报错，b is not definedlet b = 'let' 那么再看一个demo,涉及到作用域的1234567var globalObj = &#123;a:1&#125;var func = function() &#123; console.log(globalObj) //undefined globalObj.b = 2 //报错，cannot 'b' of undefined var globalObj = asdasd&#125;console.log(globalObj) 虽然globalObj是全局作用域下，func也在里面，但是在内部局部的globalObj优先级高，虽然globalObj在内层是undefined也不影响。今天在看犀牛书关于cookie操作的时候有个demo就有这个问题p591 暂时性死区ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。继续用上一个demo，换成es6的版本，报的错不一样。这么做个人感觉挺好，也算是一种规范，以前变量申明之前是可以用这个变量的，值是undefined，这样造成了很多意想不到的情况。tips：typeOf方法也有可能报错啦1234567let globalObj = &#123;a:1&#125;const func = () =&gt; &#123; console.log(globalObj) //Identifier 'globalObj' has already been declared globalObj.b = 2 let globalObj = asdasd&#125;console.log(globalObj) 不允许重复申明1234var a = 1var a = 2let b = 3let b = 4 // b报错， b has been declared tip: 函数的形参也可以理解为申明了局部变量，所以也不能再次申明 块级作用域先看一下函数作用域不好的地方12345678var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 阮大给的这个demo挺nice的，f调用的时候本来是想tmp没有暴露到f的作用域下，引擎对tmp执行RHS查询，找到上一层作用域的tmp，但是if条件里面的逻辑没有形成作用域，tem在f函数中为局部变量。1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 初学者写这种代码都没注意到内存泄露等问题，暴露过多的全局变量肯定是不好的。","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"Js事件机制（上）","date":"2018-03-13T07:04:46.000Z","path":"2018/03/13/Js事件机制（上）/","text":"很早就想好好总结一下事件机制了，终于有动力写了。文章分为上下2部分JS和HTML的交互是通过事件来实现的。事件就是文档中发生的一些特定的交互瞬间。 事件流 当浏览器发展到第四代时（IE4 和 netscape Communicator 4）,开发团队遇到了一个有意思的问题：页面的哪一部分会拥有某个特定的事件，可以想象在一张纸上画一组同心圆，如果把手指放在圆心上，那么你的手指指向的不是一个圆，而是所有的圆。2家公司看待事件的想法是一致的。当你点击了一个按钮，他们都认为是点击不仅仅发生在按钮上。也就是说 当你点击按钮，你也点击了按钮的容器元素，甚至可以说点击了整个页面。事件流描述的是，页面接收事件的顺序。IE和Netscape开发团队居然提出了完全相反的事件流的概念。IE的事件流是事件冒泡流，netScape是事件捕获流。 事件冒泡IE的事件流叫事件冒泡（event bubbling）所有的现代浏览器都是支持事件冒泡，但是具体实现上有一点区别。IE5.5及其更早的版本会跳过html直接到document 事件捕获netscape 团队提出的另一种事件流叫事件捕获。事件捕获的思想是不太具体的节点应该更早的接收到事件，具体的节点应该最后接受到事件。它的目的是在事件到达预定目标之前捕获它。 DOM事件流 IE9、Opera、Firefox、Chrome、Safari都是支持DOM事件流的。IE8及更早的版本不支持 DOM2级事件规定事件流包括3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截取事件提供了机会。然后是实际的目标接受事件，最后一个阶段是冒泡阶段。 DOM事件级别Dom事件主要分为3个级别，DOM 0 级、DOM2级、DOM3级，但是还有一个HTML事件，直接内嵌在HTML里面的。 HTML事件123456&lt;button onclick = \"handleClick()\"&gt;click&lt;/button&gt;&lt;script&gt; function handleClick()&#123; console.log('do something') &#125;&lt;script&gt; 这种强耦合的的事件方法存在2个弊端，首先是时差问题，用户可能在HTML元素一渲染在页面的时候就点击按钮，但是当时的事件处理程序组可能还没有执行条件，比如这个demo中handleClick是在页面的最底部定义的，如果用户在页面解析handleClick函数之前就点击了按钮，会引发错误。其次这种强耦合也是不被提倡的。 DOM 0 级事件1234567&lt;button id = 'myBtn'&gt;click&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('myBtn') btn.onclick = function ()&#123; console.log('do something', this.id) &#125;&lt;script&gt; DOM0级事件是将一个函数赋给一个dom对象的处理函数属性。可以通过给事件处理属性赋值null来解绑事件。这个demo中就是讲函数赋给了btn的onclick属性通过以下的demo可以看出来，DOM 0 级事件的处理程序会在冒泡阶段被处理。1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;body&gt; &lt;div id=\"box\" style=\"height:100px;width:300px;background-color:pink;\"&gt;&lt;/div&gt; &lt;button id=\"reset\"&gt;还原&lt;/button&gt; &lt;script&gt; //IE8-浏览器返回div body html document //其他浏览器返回div body html document window reset.onclick = function () &#123; history.go(); &#125; box.onclick = function () &#123; box.innerHTML += 'div\\n'; &#125; document.body.onclick = function () &#123; box.innerHTML += 'body\\n'; &#125; document.documentElement.onclick = function () &#123; box.innerHTML += 'html\\n'; &#125; document.onclick = function () &#123; box.innerHTML += 'document\\n'; &#125; window.onclick = function () &#123; box.innerHTML += 'window\\n'; &#125; &lt;/script &lt;/body&gt;&lt;/html&gt; DOM 2 级事件 IE9、Firefix、Safari、Chrome、Opera支持DOM 2 级事件处理程序 Dom 2 级事件定义了2个方法，用于指定和删除事件处理程序：addEventListener 和 removeEventListener。他们都接受3个参数 需要处理的事件名：click，scroll，focuse // 注意没有 on，不是onclick 事件的处理函数： 可以是函数名字 useCapture： true表示在捕获阶段调用处理程序，false表示冒泡阶段调用。默认为false removeEventListener的事件处理程序函数必须与addEventListener的相同。匿名函数没办法移除12btn.addEventListener(\"click\", handleClick, true)btn.removeEventListener(\"click\", handleClick, true) 大多数情况下，都是将是将事件处理程序添加到时间流的冒泡阶段，这样可以最大限度的兼容各种浏览器，但是也不排除有些场合需要在到达目标事件之前捕获它。1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;body&gt; &lt;div id=\"box\" style=\"height:100px;width:300px;background-color:pink;\"&gt;&lt;/div&gt; &lt;button id=\"reset\"&gt;还原&lt;/button&gt; &lt;script&gt; //IE8-浏览器不支持 //其他浏览器返回window document html body div reset.onclick = function () &#123; history.go(); &#125; box.addEventListener('click', function () &#123; box.innerHTML += 'div\\n' &#125;, true) document.body.addEventListener('click', function () &#123; box.innerHTML += 'body\\n'; &#125;, true); document.documentElement.addEventListener('click', function () &#123; box.innerHTML += 'html\\n'; &#125;, true); document.addEventListener('click', function () &#123; box.innerHTML += 'document\\n'; &#125;, true); window.addEventListener('click', function () &#123; box.innerHTML += 'window\\n'; &#125;, true); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; DOM 3 级事件DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下： UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified同时DOM3级事件也允许使用者自定义一些事件。 IE事件处理程序 支持IE事件处理程序的浏览器只有IE和Opera 上文说到IE9以后才支持addEventListener和removeEventListener，IE9以前浏览器有类似的方法，attachEvent和detachEvent，但是这2个方法只接受2个参数，事件名称和事件处理程序函数。由于IE8及其之前的版本并不支持DOM事件流，只有事件冒泡，所以没有第三个参数也是意料之中的。那这个和DOM 0 级事件有什么区别呢？DOM 0 级事件处理函数中的this指代的是当前DOM元素，attachEvent中this指代的是window1234567let btn = document.getElementById(\"myBtn\")btn.attachEventListener(\"onclick\",function()&#123; console.log(\"clicked\")&#125;)btn.attachEventListener(\"onclick\",function()&#123; console.log(\"hello world\")&#125;) 顺序是先hello world 再clicked，这是和addEventListener不一样的地方。还有就是”click”&amp;&amp;”onclick” 小结本文介绍了事件流和几种不同级别的DOM事件，不同浏览器的处理方式需要认真对待。","tags":[{"name":"Javascript事件","slug":"Javascript事件","permalink":"http://yoursite.com/tags/Javascript事件/"}]}]